From c66ac9b228c7ddde5040c24ae197b00797c96f82 Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Mon, 29 Aug 2011 19:34:36 +0300
Subject: [PATCH 01/10] wl12xx: Add support for inband interrupts

TODO:
* we seem to deadlock on unload.
* clean? (export irq handlers instead of passing them?)

Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/io.c       |   13 +++++-
 drivers/net/wireless/ti/wlcore/main.c     |   70 ++++++++++++++++++----------
 drivers/net/wireless/ti/wlcore/sdio.c     |   59 +++++++++++++++++++++++-
 drivers/net/wireless/ti/wlcore/wlcore.h   |    3 +
 drivers/net/wireless/ti/wlcore/wlcore_i.h |    6 +++
 5 files changed, 122 insertions(+), 29 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/io.c b/drivers/net/wireless/ti/wlcore/io.c
index d5bd8a4..1975875 100644
--- a/drivers/net/wireless/ti/wlcore/io.c
+++ b/drivers/net/wireless/ti/wlcore/io.c
@@ -44,13 +44,22 @@ bool wl1271_set_block_size(struct wl1271 *wl)
 
 void wlcore_disable_interrupts(struct wl1271 *wl)
 {
-	disable_irq(wl->irq);
+	if (wl->inband_irq)
+		wl->if_ops->free_inband_irq(wl->dev);
+	else
+		disable_irq(wl->irq);
 }
 EXPORT_SYMBOL_GPL(wlcore_disable_interrupts);
 
 void wlcore_enable_interrupts(struct wl1271 *wl)
 {
-	enable_irq(wl->irq);
+	if (wl->inband_irq)
+		wl->if_ops->request_inband_irq(wl->dev,
+					       wl12xx_hardirq,
+					       wl1271_irq,
+					       wl);
+	else
+		enable_irq(wl->irq);
 }
 EXPORT_SYMBOL_GPL(wlcore_enable_interrupts);
 
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 84cecb2..42f6f0e 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -62,6 +62,7 @@ static bool no_recovery;
 static char *plt_fw_name;
 static char *sr_fw_name;
 static char *mr_fw_name;
+static char *irq_param;
 
 static void __wl1271_op_remove_interface(struct wl1271 *wl,
 					 struct ieee80211_vif *vif,
@@ -513,7 +514,7 @@ static void wl1271_netstack_work(struct work_struct *work)
 
 #define WL1271_IRQ_MAX_LOOPS 256
 
-static irqreturn_t wl1271_irq(int irq, void *cookie)
+irqreturn_t wl1271_irq(int irq, void *cookie)
 {
 	int ret;
 	u32 intr;
@@ -5175,7 +5176,7 @@ int wlcore_free_hw(struct wl1271 *wl)
 }
 EXPORT_SYMBOL_GPL(wlcore_free_hw);
 
-static irqreturn_t wl12xx_hardirq(int irq, void *cookie)
+irqreturn_t wl12xx_hardirq(int irq, void *cookie)
 {
 	struct wl1271 *wl = cookie;
 	unsigned long flags;
@@ -5194,7 +5195,8 @@ static irqreturn_t wl12xx_hardirq(int irq, void *cookie)
 		/* don't enqueue a work right now. mark it as pending */
 		set_bit(WL1271_FLAG_PENDING_WORK, &wl->flags);
 		wl1271_debug(DEBUG_IRQ, "should not enqueue work");
-		disable_irq_nosync(wl->irq);
+		if (!wl->inband_irq)
+			disable_irq_nosync(wl->irq);
 		pm_wakeup_event(wl->dev, 0);
 #ifdef CONFIG_HAS_WAKELOCK
 		if (!test_and_set_bit(WL1271_FLAG_WAKE_LOCK, &wl->flags))
@@ -5241,28 +5243,39 @@ int __devinit wlcore_probe(struct wl1271 *wl, struct platform_device *pdev)
 	else
 		irqflags = IRQF_TRIGGER_HIGH | IRQF_ONESHOT;
 
-	ret = request_threaded_irq(wl->irq, wl12xx_hardirq, wl1271_irq,
-				   irqflags,
-				   pdev->name, wl);
-	if (ret < 0) {
-		wl1271_error("request_irq() failed: %d", ret);
-		goto out_free_hw;
-	}
-
-	ret = enable_irq_wake(wl->irq);
-	if (!ret) {
-		wl->irq_wake_enabled = true;
-		device_init_wakeup(wl->dev, 1);
-		if (pdata->pwr_in_suspend) {
-			wl->hw->wiphy->wowlan.flags = WIPHY_WOWLAN_ANY;
-			wl->hw->wiphy->wowlan.n_patterns = WL1271_MAX_RX_DATA_FILTERS;
-			wl->hw->wiphy->wowlan.pattern_min_len = 1;
-			wl->hw->wiphy->wowlan.pattern_max_len =
-				WL1271_RX_DATA_FILTER_MAX_PATTERN_SIZE;
+	wl->inband_irq = false;
+	if (irq_param) {
+		if (!strcmp(irq_param, "sdio"))
+			wl->inband_irq = true;
+		else if (strcmp(irq_param, "gpio"))
+			wl1271_warning("Unknown interrupt type, using gpio");
+	}
+	wl1271_info("inband_irq: %d", wl->inband_irq);
+	if (!wl->inband_irq) {
+		ret = request_threaded_irq(wl->irq, wl12xx_hardirq, wl1271_irq,
+					   irqflags,
+					   pdev->name, wl);
+		if (ret < 0) {
+			wl1271_error("request_irq() failed: %d", ret);
+			goto out_free_hw;
 		}
 
+		ret = enable_irq_wake(wl->irq);
+		if (!ret) {
+			wl->irq_wake_enabled = true;
+			device_init_wakeup(wl->dev, 1);
+			if (pdata->pwr_in_suspend) {
+				wl->hw->wiphy->wowlan.flags = WIPHY_WOWLAN_ANY;
+				wl->hw->wiphy->wowlan.n_patterns =
+					WL1271_MAX_RX_DATA_FILTERS;
+				wl->hw->wiphy->wowlan.pattern_min_len = 1;
+				wl->hw->wiphy->wowlan.pattern_max_len =
+					WL1271_RX_DATA_FILTER_MAX_PATTERN_SIZE;
+			}
+
+		}
+		disable_irq(wl->irq);
 	}
-	disable_irq(wl->irq);
 
 	ret = wl12xx_get_hw_info(wl);
 	if (ret < 0) {
@@ -5314,7 +5327,8 @@ out_bt_coex_state:
 	device_remove_file(wl->dev, &dev_attr_bt_coex_state);
 
 out_irq:
-	free_irq(wl->irq, wl);
+	if (!wl->inband_irq)
+		free_irq(wl->irq, wl);
 
 out_free_hw:
 	wlcore_free_hw(wl);
@@ -5330,10 +5344,12 @@ int __devexit wlcore_remove(struct platform_device *pdev)
 
 	if (wl->irq_wake_enabled) {
 		device_init_wakeup(wl->dev, 0);
-		disable_irq_wake(wl->irq);
+		if (!wl->inband_irq)
+			disable_irq_wake(wl->irq);
 	}
 	wl1271_unregister_hw(wl);
-	free_irq(wl->irq, wl);
+	if (!wl->inband_irq)
+		free_irq(wl->irq, wl);
 	wlcore_free_hw(wl);
 
 	return 0;
@@ -5349,6 +5365,10 @@ module_param_named(fwlog, fwlog_param, charp, 0);
 MODULE_PARM_DESC(keymap,
 		 "FW logger options: continuous, ondemand, dbgpins or disable");
 
+module_param_named(irq, irq_param, charp, S_IRUSR);
+MODULE_PARM_DESC(irq,
+		 "Set the irq type: sdio or gpio (default)");
+
 module_param(bug_on_recovery, bool, S_IRUSR | S_IWUSR);
 MODULE_PARM_DESC(bug_on_recovery, "BUG() on fw recovery");
 
diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index 2a79b7b..807b685 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -52,6 +52,10 @@ static bool dump = false;
 struct wl12xx_sdio_glue {
 	struct device *dev;
 	struct platform_device *core;
+
+	irq_handler_t handler;
+	irq_handler_t thread_fn;
+	void *irq_cookie;
 };
 
 static const struct sdio_device_id wl1271_devices[] __devinitconst = {
@@ -103,7 +107,7 @@ static void wl12xx_sdio_raw_read(struct device *child, int addr, void *buf,
 
 	sdio_release_host(func);
 
-	if (ret)
+	if (WARN_ON_ONCE(ret))
 		dev_err(child->parent, "sdio read failed (%d)\n", ret);
 }
 
@@ -139,7 +143,7 @@ static void wl12xx_sdio_raw_write(struct device *child, int addr, void *buf,
 
 	sdio_release_host(func);
 
-	if (ret)
+	if (WARN_ON_ONCE(ret))
 		dev_err(child->parent, "sdio write failed (%d)\n", ret);
 }
 
@@ -199,11 +203,62 @@ static int wl12xx_sdio_set_power(struct device *child, bool enable)
 		return wl12xx_sdio_power_off(glue);
 }
 
+static void wl12xx_sdio_interrupt(struct sdio_func *func)
+{
+	struct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);
+	irqreturn_t ret;
+
+	if (WARN_ON(!glue->handler || !glue->thread_fn))
+		return;
+
+	ret = glue->handler(0, glue->irq_cookie);
+	if (ret == IRQ_WAKE_THREAD) {
+		sdio_release_host(func);
+		glue->thread_fn(0, glue->irq_cookie);
+		sdio_claim_host(func);
+	}
+}
+
+void wl12xx_sdio_request_irq(struct device *child,
+			     irq_handler_t handler,
+			     irq_handler_t thread_fn,
+			     void *cookie)
+{
+	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
+	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+	int ret;
+
+	sdio_claim_host(func);
+	glue->handler = handler;
+	glue->thread_fn = thread_fn;
+	glue->irq_cookie = cookie;
+	ret = sdio_claim_irq(func, wl12xx_sdio_interrupt);
+	sdio_release_host(func);
+	printk("claiming sdio irq (func=%d). ret=%d\n", func->num, ret);
+}
+
+static void wl12xx_sdio_free_irq(struct device *child)
+{
+	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
+	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+
+	printk("releasing sdio irq\n");
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	glue->handler = NULL;
+	glue->thread_fn = NULL;
+	glue->irq_cookie = NULL;
+	sdio_release_host(func);
+}
+
+
 static struct wl1271_if_operations sdio_ops = {
 	.read		= wl12xx_sdio_raw_read,
 	.write		= wl12xx_sdio_raw_write,
 	.power		= wl12xx_sdio_set_power,
 	.set_block_size = wl1271_sdio_set_block_size,
+	.request_inband_irq	= wl12xx_sdio_request_irq,
+	.free_inband_irq	= wl12xx_sdio_free_irq,
 };
 
 static int __devinit wl1271_probe(struct sdio_func *func,
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index f45e740..20b523f 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -148,6 +148,7 @@ struct wl1271 {
 	struct wl1271_if_operations *if_ops;
 
 	void (*set_power)(bool enable);
+	bool inband_irq;
 	int irq;
 
 	spinlock_t wl_lock;
@@ -401,6 +402,8 @@ int wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,
 		   struct ieee80211_vif *vif,
 		   struct ieee80211_sta *sta,
 		   struct ieee80211_key_conf *key_conf);
+irqreturn_t wl12xx_hardirq(int irq, void *cookie);
+irqreturn_t wl1271_irq(int irq, void *cookie);
 
 /* Firmware image load chunk size */
 #define CHUNK_SIZE	16384
diff --git a/drivers/net/wireless/ti/wlcore/wlcore_i.h b/drivers/net/wireless/ti/wlcore/wlcore_i.h
index b9ac4d4..a0448ac 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore_i.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore_i.h
@@ -30,6 +30,7 @@
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/bitops.h>
+#include <linux/interrupt.h>
 #include <net/mac80211.h>
 #ifdef CONFIG_HAS_WAKELOCK
 #include <linux/wakelock.h>
@@ -207,6 +208,11 @@ struct wl1271_if_operations {
 	void (*init)(struct device *child);
 	int (*power)(struct device *child, bool enable);
 	void (*set_block_size) (struct device *child, unsigned int blksz);
+	void (*request_inband_irq)(struct device *child,
+				   irq_handler_t handler,
+				   irq_handler_t thread_fn,
+				   void *cookie);
+	void (*free_inband_irq)(struct device *child);
 };
 
 #define MAX_NUM_KEYS 14
-- 
1.7.0.4

