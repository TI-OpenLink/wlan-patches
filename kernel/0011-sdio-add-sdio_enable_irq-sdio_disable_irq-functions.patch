From a97ff8d607a393f3fdd23e927a495d08cbf38282 Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Thu, 3 Nov 2011 14:48:01 +0200
Subject: [PATCH 11/19] sdio: add sdio_enable_irq/sdio_disable_irq functions

In some cases, we'd like to disable the irq, without stopping
the handler thread, as this is our own context (i.e. doing
something similar to disable_irq_nosync).

Add sdio_enable_irq/sdio_disable_irq functions, that only
configure the irq, without touching the handler.

Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/mmc/core/sdio_irq.c   |   72 +++++++++++++++++++++++++++++++++++++++++
 include/linux/mmc/sdio_func.h |    2 +
 2 files changed, 74 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index e05a9c2..17b86d4 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -320,3 +320,75 @@ int sdio_release_irq(struct sdio_func *func)
 }
 EXPORT_SYMBOL_GPL(sdio_release_irq);
 
+int sdio_enable_irq(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));
+
+	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg |= 1 << func->num;
+
+	reg |= 1; /* Master interrupt enable */
+
+	ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	if (func->card->host->caps & MMC_CAP_ASYNC_SDIO_IRQ) {
+		/* read Interrupt Extenstion */
+		ret = mmc_io_rw_direct(func->card, 0, 0,
+				       SDIO_CCCR_IEXx, 0, &reg);
+		if (ret)
+			return ret;
+
+		/* check Support Asynchronous Interrupt (SAI) */
+		if (reg & 0x1) {
+			/* Enable Asynchronous Interrupt */
+			reg |= BIT(1);
+			ret = mmc_io_rw_direct(func->card, 1, 0,
+					       SDIO_CCCR_IEXx, reg, NULL);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdio_enable_irq);
+
+int sdio_disable_irq(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));
+
+	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg &= ~(1 << func->num);
+
+	/* Disable master interrupt with the last function interrupt */
+	if (!(reg & 0xFE))
+		reg = 0;
+
+	ret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdio_disable_irq);
+
diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h
index 557acae..1715c47 100755
--- a/include/linux/mmc/sdio_func.h
+++ b/include/linux/mmc/sdio_func.h
@@ -134,6 +134,8 @@ extern int sdio_set_block_size(struct sdio_func *func, unsigned blksz);
 
 extern int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler);
 extern int sdio_release_irq(struct sdio_func *func);
+extern int sdio_enable_irq(struct sdio_func *func);
+extern int sdio_disable_irq(struct sdio_func *func);
 
 extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
 
-- 
1.7.7.6

