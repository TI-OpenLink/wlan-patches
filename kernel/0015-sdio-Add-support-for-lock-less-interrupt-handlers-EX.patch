From b1426df53a15fd9c229529dfede46204feacfd4e Mon Sep 17 00:00:00 2001
From: Ido Yariv <ido@wizery.com>
Date: Mon, 2 Jan 2012 21:38:21 +0200
Subject: [PATCH 15/21] sdio: Add support for lock-less interrupt handlers *EXPERIMENTAL*

SDIO interrupt handlers are called with the host being claimed. Some
drivers may normally claim the host after acquiring a different lock.
This means that the interrupt handler may not acquire this lock, as the
locking order will be incorrect.

Add support for lock-less interrupt handlers, which will be called
without the host being claimed.

Signed-off-by: Ido Reis <idor@ti.com>
Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/mmc/core/sdio_irq.c   |   55 +++++++++++++++++++++++++++++++++++++---
 include/linux/mmc/card.h      |    1 +
 include/linux/mmc/sdio_func.h |    3 ++
 3 files changed, 54 insertions(+), 5 deletions(-)

diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 17b86d4..d2471e6 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -30,7 +30,6 @@
 static int process_sdio_pending_irqs(struct mmc_card *card)
 {
 	int i, ret, count;
-	unsigned char pending;
 	struct sdio_func *func;
 
 	/*
@@ -43,7 +42,9 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 		return 1;
 	}
 
-	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
+	card->pending_int = 0;
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0,
+		&card->pending_int);
 	if (ret) {
 		printk(KERN_DEBUG "%s: error %d reading SDIO_CCCR_INTx\n",
 		       mmc_card_id(card), ret);
@@ -52,7 +53,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 
 	count = 0;
 	for (i = 1; i <= 7; i++) {
-		if (pending & (1 << i)) {
+		if (card->pending_int & (1 << i)) {
 			func = card->sdio_func[i - 1];
 			if (!func) {
 				printk(KERN_WARNING "%s: pending IRQ for "
@@ -62,7 +63,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 			} else if (func->irq_handler) {
 				func->irq_handler(func);
 				count++;
-			} else {
+			} else if (!func->irq_handler_ll) {
 				printk(KERN_WARNING "%s: pending IRQ with no handler\n",
 				       sdio_func_id(func));
 				ret = -EINVAL;
@@ -76,6 +77,20 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 	return ret;
 }
 
+static void call_sdio_lockless_irqs(struct mmc_card *card)
+{
+	int i;
+
+	for (i = 1; i <= 7; i++) {
+		if (card->pending_int & (1 << i)) {
+			struct sdio_func *func = card->sdio_func[i - 1];
+			if (func && func->irq_handler_ll) {
+				func->irq_handler_ll(func);
+			}
+		}
+	}
+}
+
 static int sdio_irq_thread(void *_host)
 {
 	struct mmc_host *host = _host;
@@ -117,6 +132,7 @@ static int sdio_irq_thread(void *_host)
 			break;
 		ret = process_sdio_pending_irqs(host->card);
 		mmc_release_host(host);
+		call_sdio_lockless_irqs(host->card);
 
 		/*
 		 * Give other threads a chance to run in the presence of
@@ -281,6 +297,34 @@ int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 EXPORT_SYMBOL_GPL(sdio_claim_irq);
 
 /**
+ *	sdio_claim_irq_lockless - claim the IRQ for a SDIO function
+ *	@func: SDIO function
+ *	@handler: IRQ handler callback
+ *
+ *	Claim and activate the IRQ for the given SDIO function. The provided
+ *	handler will be called when that IRQ is asserted. The host is not
+ *	claimed when the handler is called so the handler might need to call
+ *	sdio_claim_host() and sdio_release_host().
+ */
+int sdio_claim_irq_lockless(struct sdio_func *func, sdio_irq_handler_t *handler)
+{
+	int ret;
+
+	if (func->irq_handler_ll) {
+		pr_debug("SDIO: IRQ for %s already in use.\n", sdio_func_id(func));
+		return -EBUSY;
+	}
+
+	func->irq_handler_ll = handler;
+	ret = sdio_claim_irq(func, NULL);
+	if (ret)
+		func->irq_handler_ll = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdio_claim_irq_lockless);
+
+/**
  *	sdio_release_irq - release the IRQ for a SDIO function
  *	@func: SDIO function
  *
@@ -296,8 +340,9 @@ int sdio_release_irq(struct sdio_func *func)
 
 	pr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));
 
-	if (func->irq_handler) {
+	if (func->irq_handler || func->irq_handler_ll) {
 		func->irq_handler = NULL;
+		func->irq_handler_ll = NULL;
 		sdio_card_irq_put(func->card);
 		sdio_single_irq_set(func->card);
 	}
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 1a1066c..3e6ea57 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -217,6 +217,7 @@ struct mmc_card {
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
 
 	struct dentry		*debugfs_root;
+	unsigned char		pending_int;	/* pending sdio interrupts */
 };
 
 /*
diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h
index 1715c47..5dff5e9 100755
--- a/include/linux/mmc/sdio_func.h
+++ b/include/linux/mmc/sdio_func.h
@@ -47,6 +47,7 @@ struct sdio_func {
 	struct mmc_card		*card;		/* the card this device belongs to */
 	struct device		dev;		/* the device */
 	sdio_irq_handler_t	*irq_handler;	/* IRQ callback */
+	sdio_irq_handler_t	*irq_handler_ll;/* IRQ callback, called with the host unclaimed */
 	unsigned int		num;		/* function number */
 
 	unsigned char		class;		/* standard interface class */
@@ -133,6 +134,8 @@ extern int sdio_disable_func(struct sdio_func *func);
 extern int sdio_set_block_size(struct sdio_func *func, unsigned blksz);
 
 extern int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler);
+extern int sdio_claim_irq_lockless(struct sdio_func *func,
+				   sdio_irq_handler_t *handler);
 extern int sdio_release_irq(struct sdio_func *func);
 extern int sdio_enable_irq(struct sdio_func *func);
 extern int sdio_disable_irq(struct sdio_func *func);
-- 
1.7.0.4

