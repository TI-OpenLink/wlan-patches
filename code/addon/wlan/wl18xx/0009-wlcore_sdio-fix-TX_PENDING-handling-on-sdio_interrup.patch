From 06ea0b42f36c713de2a6d167a5e61b8556fc6533 Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Mon, 30 Jul 2012 20:35:54 +0300
Subject: [PATCH 09/10] wlcore_sdio: fix TX_PENDING handling on sdio_interrupt

On wl12xx_sdio_interrupt we set WL1271_FLAG_TX_PENDING
in order to prevent redundant tx_work. However, since
the respective set_bit() is missing, further tx_work
was never enqueued.

In order to add the missing code (clear bit and re-enqueue
tx_work) we have to use the non-exported inline function
wl1271_tx_total_queue_count(). export it by defining a
new exported wrapper function (wlcore_tx_queue_count).

Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/sdio.c   |   15 +++++++++++++++
 drivers/net/wireless/ti/wlcore/tx.c     |   10 ++++++++++
 drivers/net/wireless/ti/wlcore/wlcore.h |    2 ++
 3 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index 08f0957..397dc32 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -216,6 +216,7 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 {
 	struct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);
 	struct wl1271 *wl = platform_get_drvdata(glue->core);
+	unsigned long flags;
 	irqreturn_t ret;
 
 	dev_dbg(&func->dev, "SDIO IRQ");
@@ -248,6 +249,20 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 			wl12xx_queue_recovery_work(wl);
 
 		sdio_release_host(func);
+
+		spin_lock_irqsave(&wl->wl_lock, flags);
+		/* In case TX was not handled here, queue TX work */
+		clear_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
+		if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
+		    wlcore_tx_queue_count(wl) > 0)
+			ieee80211_queue_work(wl->hw, &wl->tx_work);
+
+#ifdef CONFIG_HAS_WAKELOCK
+		if (test_and_clear_bit(WL1271_FLAG_WAKE_LOCK, &wl->flags))
+			wake_unlock(&wl->wake_lock);
+#endif
+		spin_unlock_irqrestore(&wl->wl_lock, flags);
+
 		mutex_unlock(&wl->mutex);
 	}
 	/*
diff --git a/drivers/net/wireless/ti/wlcore/tx.c b/drivers/net/wireless/ti/wlcore/tx.c
index d6d7d27..5f0208a 100644
--- a/drivers/net/wireless/ti/wlcore/tx.c
+++ b/drivers/net/wireless/ti/wlcore/tx.c
@@ -1139,6 +1139,16 @@ out:
 }
 EXPORT_SYMBOL_GPL(wl1271_tx_flush);
 
+/*
+ * this is just a wrapper in order to export wl1271_tx_total_queue_count
+ * while keeping it inline (for other users)
+ */
+int wlcore_tx_queue_count(struct wl1271 *wl)
+{
+	return wl1271_tx_total_queue_count(wl);
+}
+EXPORT_SYMBOL_GPL(wlcore_tx_queue_count);
+
 u32 wl1271_tx_min_rate_get(struct wl1271 *wl, u32 rate_set)
 {
 	if (WARN_ON(!rate_set))
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index 8a922b6..3afb801 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -442,6 +442,8 @@ int wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,
 irqreturn_t wl12xx_hardirq(int irq, void *cookie);
 irqreturn_t wlcore_irq(int irq, void *cookie);
 int wlcore_irq_locked(struct wl1271 *wl);
+/* exported wrapper for wl1271_tx_total_queue_count */
+int wlcore_tx_queue_count(struct wl1271 *wl);
 
 static inline void
 wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band,
-- 
1.7.7.6

