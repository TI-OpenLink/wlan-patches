From 15d1e48a79c5d12d140bcf1b4bb21869c5ff9e55 Mon Sep 17 00:00:00 2001
From: Ido Yariv <ido@wizery.com>
Date: Mon, 2 Jan 2012 21:50:02 +0200
Subject: [PATCH 06/10] wl12xx: Register lock-less IBI handlers *EXPERIMENTAL*

wl->mutex is normally acquired before claiming the mmc host. In the case
of IBI, the handler is called with the host already claimed. This means
that acquiring the mutex in the handler will result in an incorrect
locking order, which could lead to a deadlock.

Fix this by registering the handler as a lock-less one, and claim the
host after acquiring the mutex.

Signed-off-by: Ido Yariv <ido@wizery.com>
Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/main.c   |    4 +++-
 drivers/net/wireless/ti/wlcore/sdio.c   |   30 +++++++++++++++++++++++++++---
 drivers/net/wireless/ti/wlcore/wlcore.h |    1 +
 3 files changed, 31 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 66d02e8..8fcff0d 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -494,7 +494,7 @@ static void wl1271_netstack_work(struct work_struct *work)
 
 #define WL1271_IRQ_MAX_LOOPS 256
 
-static int wlcore_irq_locked(struct wl1271 *wl)
+int wlcore_irq_locked(struct wl1271 *wl)
 {
 	int ret = 0;
 	u32 intr;
@@ -622,6 +622,7 @@ static int wlcore_irq_locked(struct wl1271 *wl)
 out:
 	return ret;
 }
+EXPORT_SYMBOL(wlcore_irq_locked);
 
 irqreturn_t wlcore_irq(int irq, void *cookie)
 {
@@ -790,6 +791,7 @@ void wl12xx_queue_recovery_work(struct wl1271 *wl)
 		ieee80211_queue_work(wl->hw, &wl->recovery_work);
 	}
 }
+EXPORT_SYMBOL(wl12xx_queue_recovery_work);
 
 size_t wl12xx_copy_fwlog(struct wl1271 *wl, u8 *memblock, size_t maxlen)
 {
diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index ef3deb4..d27bbe1 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -219,6 +219,10 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	dev_dbg(&func->dev, "SDIO IRQ");
 
+	/* TX might be handled here, avoid redundant work */
+	set_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
+	cancel_work_sync(&wl->tx_work);
+
 	if (WARN_ON(!glue->handler || !glue->thread_fn))
 		return;
 
@@ -227,10 +231,30 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	ret = glue->handler(0, glue->irq_cookie);
 	if (ret == IRQ_WAKE_THREAD) {
+
+		mutex_lock(&wl->mutex);
+		if (sdio_claim_host_irq(func)) {
+			/*
+			 * Theoretically we need to reschedule TX work.
+			 * Practically, if the irq is freed, there's little
+			 * point in doing so.
+			 */
+			mutex_unlock(&wl->mutex);
+			return;
+		}
+
+		ret = wlcore_irq_locked(wl);
+		if (ret)
+			wl12xx_queue_recovery_work(wl);
+
 		sdio_release_host(func);
-		glue->thread_fn(0, glue->irq_cookie);
-		sdio_claim_host(func);
+		mutex_unlock(&wl->mutex);
 	}
+	/*
+	 * Again, we shouldn't reschedule TX work in an else clause because the
+	 * system is suspended and the interrupt handler will be called when it
+	 * is resumed
+	 */
 }
 
 int wl12xx_sdio_request_irq(struct device *child,
@@ -255,7 +279,7 @@ int wl12xx_sdio_request_irq(struct device *child,
 	glue->handler = handler;
 	glue->thread_fn = thread_fn;
 	glue->irq_cookie = cookie;
-	ret = sdio_claim_irq(func, wl12xx_sdio_interrupt);
+	ret = sdio_claim_irq_lockless(func, wl12xx_sdio_interrupt);
 	sdio_release_host(func);
 	printk("claiming sdio irq (func=%d). ret=%d\n", func->num, ret);
 	return ret;
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index 5c77a67..8a922b6 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -441,6 +441,7 @@ int wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,
 		   struct ieee80211_key_conf *key_conf);
 irqreturn_t wl12xx_hardirq(int irq, void *cookie);
 irqreturn_t wlcore_irq(int irq, void *cookie);
+int wlcore_irq_locked(struct wl1271 *wl);
 
 static inline void
 wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band,
-- 
1.7.7.6

