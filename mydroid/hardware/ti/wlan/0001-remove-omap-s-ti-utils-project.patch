From 8ba4674c3366f0cf931ea6e3a26c21c29c228c8a Mon Sep 17 00:00:00 2001
From: Shahar Levi <shahar_levi@ti.com>
Date: Thu, 17 May 2012 14:40:14 +0300
Subject: [PATCH 1/4] remove omap's ti-utils project

Signed-off-by: Shahar Levi <shahar_levi@ti.com>
---
 mac80211/ti-utils/Android.mk                    |   42 -
 mac80211/ti-utils/COPYING                       |   36 -
 mac80211/ti-utils/Makefile                      |   30 -
 mac80211/ti-utils/README                        |  209 ----
 mac80211/ti-utils/calibrator.c                  |  539 ---------
 mac80211/ti-utils/calibrator.h                  |  157 ---
 mac80211/ti-utils/ini.c                         | 1185 -------------------
 mac80211/ti-utils/ini.h                         |  332 ------
 mac80211/ti-utils/ini_files/127x/RFMD_D_E5.ini  |   77 --
 mac80211/ti-utils/ini_files/127x/RFMD_S_3.5.ini |   63 -
 mac80211/ti-utils/ini_files/127x/TQS_D_1.0.ini  |   78 --
 mac80211/ti-utils/ini_files/127x/TQS_D_1.7.ini  |   78 --
 mac80211/ti-utils/ini_files/127x/TQS_S_2.5.ini  |   63 -
 mac80211/ti-utils/ini_files/127x/TQS_S_2.6.ini  |   63 -
 mac80211/ti-utils/ini_files/128x/RFMD_S_3.5.ini |   69 --
 mac80211/ti-utils/ini_files/128x/TQS_D_1.0.ini  |   85 --
 mac80211/ti-utils/ini_files/128x/TQS_D_1.7.ini  |   85 --
 mac80211/ti-utils/ini_files/128x/TQS_S_2.6.ini  |   69 --
 mac80211/ti-utils/misc_cmds.c                   |  323 -----
 mac80211/ti-utils/nl80211.h                     | 1434 -----------------------
 mac80211/ti-utils/nvs.c                         | 1202 -------------------
 mac80211/ti-utils/nvs.h                         |   31 -
 mac80211/ti-utils/plt.c                         | 1343 ---------------------
 mac80211/ti-utils/plt.h                         |  397 -------
 mac80211/ti-utils/wl18xx_plt.c                  |  308 -----
 mac80211/ti-utils/wl18xx_plt.h                  |  130 --
 26 files changed, 0 insertions(+), 8428 deletions(-)
 delete mode 100644 mac80211/ti-utils/Android.mk
 delete mode 100644 mac80211/ti-utils/COPYING
 delete mode 100644 mac80211/ti-utils/Makefile
 delete mode 100644 mac80211/ti-utils/README
 delete mode 100644 mac80211/ti-utils/calibrator.c
 delete mode 100644 mac80211/ti-utils/calibrator.h
 delete mode 100644 mac80211/ti-utils/ini.c
 delete mode 100644 mac80211/ti-utils/ini.h
 delete mode 100755 mac80211/ti-utils/ini_files/127x/RFMD_D_E5.ini
 delete mode 100755 mac80211/ti-utils/ini_files/127x/RFMD_S_3.5.ini
 delete mode 100755 mac80211/ti-utils/ini_files/127x/TQS_D_1.0.ini
 delete mode 100755 mac80211/ti-utils/ini_files/127x/TQS_D_1.7.ini
 delete mode 100755 mac80211/ti-utils/ini_files/127x/TQS_S_2.5.ini
 delete mode 100755 mac80211/ti-utils/ini_files/127x/TQS_S_2.6.ini
 delete mode 100755 mac80211/ti-utils/ini_files/128x/RFMD_S_3.5.ini
 delete mode 100755 mac80211/ti-utils/ini_files/128x/TQS_D_1.0.ini
 delete mode 100755 mac80211/ti-utils/ini_files/128x/TQS_D_1.7.ini
 delete mode 100755 mac80211/ti-utils/ini_files/128x/TQS_S_2.6.ini
 delete mode 100644 mac80211/ti-utils/misc_cmds.c
 delete mode 100644 mac80211/ti-utils/nl80211.h
 delete mode 100644 mac80211/ti-utils/nvs.c
 delete mode 100644 mac80211/ti-utils/nvs.h
 delete mode 100644 mac80211/ti-utils/plt.c
 delete mode 100644 mac80211/ti-utils/plt.h
 delete mode 100644 mac80211/ti-utils/wl18xx_plt.c
 delete mode 100644 mac80211/ti-utils/wl18xx_plt.h

diff --git a/mac80211/ti-utils/Android.mk b/mac80211/ti-utils/Android.mk
deleted file mode 100644
index 187b706..0000000
--- a/mac80211/ti-utils/Android.mk
+++ /dev/null
@@ -1,42 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-
-#
-# Calibrator
-#
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-        nvs.c \
-        misc_cmds.c \
-        calibrator.c \
-        plt.c \
-        ini.c
-
-LOCAL_CFLAGS := -DCONFIG_LIBNL20
-LOCAL_C_INCLUDES := \
-    $(LOCAL_PATH) \
-    external/libnl-headers
-
-LOCAL_STATIC_LIBRARIES := libnl_2
-LOCAL_MODULE_TAGS := eng
-LOCAL_MODULE := calibrator
-
-include $(BUILD_EXECUTABLE)
-
-#
-# UIM Application
-#
-#include $(CLEAR_VARS)
-
-#LOCAL_C_INCLUDES:= \
-#    $(LOCAL_PATH)/uim_rfkill/ \
-#    external/bluetooth/bluez/
-
-#LOCAL_SRC_FILES:= \
-#    uim_rfkill/uim.c
-#LOCAL_CFLAGS:= -g -c -W -Wall -O2 -D_POSIX_SOURCE
-#LOCAL_SHARED_LIBRARIES:= libnetutils
-#LOCAL_MODULE_TAGS := eng
-#LOCAL_MODULE:=uim-util
-
-#include $(BUILD_EXECUTABLE)
diff --git a/mac80211/ti-utils/COPYING b/mac80211/ti-utils/COPYING
deleted file mode 100644
index def0d30..0000000
--- a/mac80211/ti-utils/COPYING
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright(c) 1998 - 2010 Texas Instruments. All rights reserved.
- * All rights reserved.
- *
- * Base on code from
- *  Copyright (c) 2007, 2008, Johannes Berg <johannes@sipsolutions.net>
- *  Copyright (c) 2007,	Andy Lutomirski
- *  Copyright (c) 2007, Mike Kershaw
- *  Copyright (c) 2008-2009, Luis R. Rodriguez <mcgrof@gmail.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Texas Instruments nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
diff --git a/mac80211/ti-utils/Makefile b/mac80211/ti-utils/Makefile
deleted file mode 100644
index 2b292eb..0000000
--- a/mac80211/ti-utils/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-CC = $(CROSS_COMPILE)gcc
-CFLAGS = -O2 -Wall
-CFLAGS += -DCONFIG_LIBNL20 -I$(NFSROOT)/usr/include -I$(NFSROOT)/include
-
-LDFLAGS += -L$(NFSROOT)/lib
-LIBS += -lnl -lnl-genl -lm
-
-OBJS = nvs.o misc_cmds.o calibrator.o plt.o wl18xx_plt.o ini.o
-
-%.o: %.c calibrator.h nl80211.h plt.h nvs_dual_band.h
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-all: $(OBJS) 
-	$(CC) $(LDFLAGS) $(OBJS) $(LIBS) -o calibrator
-
-uim:
-	$(CC) $(CFLAGS) $(LDFLAGS) uim_rfkill/$@.c -o $@
-
-static: $(OBJS) 
-	$(CC) $(LDFLAGS) --static $(OBJS) $(LIBS) -o calibrator
-
-install:
-	@echo Copy files to $(NFSROOT)/home/root
-	@cp -f ./calibrator $(NFSROOT)/home/root
-	@chmod 755 $(NFSROOT)/home/root/calibrator
-	@cp -f ./scripts/wl12xx-tool.sh $(NFSROOT)/home/root
-	@chmod 755 $(NFSROOT)/home/root/wl12xx-tool.sh
-
-clean:
-	@rm -f *.o calibrator uim
diff --git a/mac80211/ti-utils/README b/mac80211/ti-utils/README
deleted file mode 100644
index 3bd1a0d..0000000
--- a/mac80211/ti-utils/README
+++ /dev/null
@@ -1,209 +0,0 @@
-
-The calibrator and other useful utilities for TI wireless solution,
-based on wl12xx driver.
-
-Calibration is a process in which specific radio configuration parameters are
-generated and saved into the NVS file, later to be used by the wl12xx driver
-upon initialization.
-These configuration parameters are specific to the chip on the specific design
-and therefore are sent back to the driver to store in non-volatile memory for
-later use. Upon initialization, the wl12xx driver will load an NVS file where
-it expects to read those parameters and send them to the chip.
-
-The NVS file contains 2 main parts - one stores the calibration parameters and
-the other one stores initialization information required for the wl12xx driver.
-
---- Build procedure
-
-Kernel configuration.
-Make sure your kernel is configured to support nl80211 testmode commands
-(NL80211_TESTMODE=y). Also enable following configurations:
-CRC7=m
-FW_LOADER=m
-
-In userspace there is dependent on libnl v2.x package. It can be downloaded
-from http://www.infradead.org/~tgr/libnl/files/libnl-2.0.tar.gz
-
-Set follow environment variables:
-export NFSROOT=<path to roofs of a target where installed libnl library>
-export CROSS_COMPILE=arm-none-linux-gnueabi-
-make
-make install
-
---- How to calibrate
-
-Automatic calibration procedure.
-
-* Make sure all modules up to wl12xx.ko are loaded. wl12xx_sdio.ko should NOT be loaded.
-* The firmware directory must be writeable.
-* A "plt firmware" must be present in the firmware directory.
-
-calibrator plt autocalibrate <dev> <kernel mod> <ini> <nvs> <mac>
-	dev		Device name. Probably wlan0
-	kernel mod	Full path to wl12xx_sdio.ko kernel module
-	ini 		Full path to Radio param ini file
-	nvs		Full path of nvs file. Must be the real path as wl12xx will load it
-
-This command will perform the following steps:
-
-* Parse the ini and create an nvs without calibration data.
-* Load kernel module.
-* Perform TxBip and update nvs with calibration data.
-* Unload kernel module.
-
-Android example:
-./calibrator plt autocalibrate wlan0 /system/lib/modules/wl12xx_sdio.ko TQS_D_1.7.ini /etc/firmware/ti-connectivity/wl1271-nvs.bin 00:01:02:03:04:05
-
-Native Linux example:
-./calibrator plt autocalibrate wlan0 /lib/modules/wl12xx_sdio.ko TQS_D_1.7.ini /lib/firmware/ti-connectivity/wl1271-nvs.bin 00:01:02:03:04:05
-
---- How to choose INI file
-
-For Beagle board and Panda board use ini_files/127x/TQS_S_2.6.ini
-For Blaze board with ES2.1 or ES2.1 use ini_files/128x/TQS_D_1.7.ini
-
---- How to change MAC address in calibrated NVS
-
-./calibrator set nvs_mac <nvs file> [<mac addr xx:xx:xx:xx:xx:xx>]
-
-If the MAC address missing, the random valid value will be added.
-
-
---- How to dump NVS file
-
-calibrator get dump_nvs [<nvs filename>]
-
-
---- Detailed instructions for calibrator procedures
-
-Normally you should use the autocalibrate command but it's also possible to
-run each step manually.
-
-	TxBip procedure (calibration)
-
-It is important to set MAC address to an interface before the procedure.
-For example, `ifconfig wlan0 hw ether xx:xx:xx:xx:xx:xx'
-
-calibrator wlan0 plt power_mode on
-calibrator wlan0 plt tx_bip <0|1> <0|1> <0|1> <0|1> <0|1> <0|1> <0|1> <0|1>
-calibrator wlan0 plt power_mode off
-
-Result of this procedure is new NVS file created locally ./new-nvs.bin
-In order to use it, copy the file to /lib/firmware/wl1271-nvs.bin and reload.
-
-	TxCont procedure
-
-calibrator wlan0 plt power_mode on
-calibrator wlan0 plt tune_channel <band> <channel>
-calibrator wlan0 plt tx_cont <delay> <rate> <size> <amount> <power> <seed> <pkt mode> <DC on/off> <gi> <preamble> <type> <scramble> <clpc> <seq nbr mode> <dest mac>
-calibrator wlan0 plt tx_stop
-calibrator wlan0 plt power_mode off
-
-Description: This test sends packets of data directly to air. It receives
-several parameters as described bellow, to enable diversity of
-operational modes.
-It is mostly used to see Energy and radio impact on Air.
-Content of Packet can be Random, or Zero, One, Zero, one...
-
-Packets send are configurable with following parameters:
-  Delay between packets in microseconds
-  Rate
-    1 Mbps -   0x00000001       MCS_0 - 0x00002000
-    2 Mbps -   0x00000002       MCS_1 - 0x00004000
-    5.5 Mbps - 0x00000004       MCS_2 - 0x00008000
-    6 Mbps -   0x00000008       MCS_3 - 0x00010000
-    9 Mbps -   0x00000010       MCS_4 - 0x00020000
-    11 Mbps -  0x00000020       MCS_5 - 0x00040000
-    12 Mbps -  0x00000040       MCS_6 - 0x00080000
-    18 Mbps -  0x00000080       MCS_7 - 0x00100000
-    24 Mbps -  0x00000200
-    36 Mbps -  0x00000400
-    48 Mbps -  0x00000800
-    54 Mbps -  0x00001000
-  Size of data field in MPDU (in bytes, 0 - 2284)
-  Amount - number of packets in case of using series mode
-  Power - output power in dBm*1000
-  Seed - value for the scrambler
-  Packet mode - 0-single, 1-multipile, 3-continuous, 4-FCC
-  DC on/off - activate DCF
-  gi - guard interval on/off for 11n rates
-  Preamble
-    1 Mbps - long preamble mode=0
-    2, 5.5, 11 Mbps - long preamble mode=0, short preamble mode=1
-    6, 9, 12, 18, 24, 36, 48, 54 Mbps - ofdm preamble mode=4
-    from MCS_0 to MCS_7 - n mixed mode preamble mode=6, greenfield preamble mode=7
-  Type is 0-data packet, 1-ack, 2-probe req, 3-random data, 4-user data
-  Scrambler - on/off
-  CLPC
-    range 0-100 is disable calibration
-  Sequence number mode (incremented or fixed)
-  Destination Mac address
-
-	RxStat procedure
-
-There are 2 ways to do it - short where all parameters has default values and
-full where you have to set all parameters manually.
-
-Short way:
-calibrator plt rx_statistics
-
-In the short way each time the statistics will be reseted.
-
-Full way:
-calibrator wlan0 plt power_mode on
-calibrator wlan0 plt start_rx_statcs
-calibrator wlan0 plt get_rx_statcs
-calibrator wlan0 plt stop_rx_statcs
-calibrator wlan0 plt power_mode off
-
-While willing to reset the statistic run:
-calibrator wlan0 plt reset_rx_statcs
-
-	Update NVS file procedure
-
-This is procedure changes ini part of NVS file. It helps when there is need
-to change ini part of NVS which already calibrated.
-
-calibrator set upd_nvs <ini file> [<old nvs file> [<new nvs file>]]
-
-If NVS filename parameter not provided the current NVS file will be used from
-destination directory (usually /lib/firmware).
-
-
---- Miscellaneous procedures
-
-	Read MAC address from NVS file
-
-calibrator get nvs_mac [<nvs filename>]
-
-	Set NVS to use auto FEM detection
-
-calibrator set autofem 1
-
-
-	Set FEM manufacturer
-
-calibrator set fem_manuf 0|1
-
-
-	Tone transmission testing
-Get in PLT mode
-calibrator wlan0 plt power_mode on
-
-Run TxTone transmission
-calibrator wlan0 plt tx_tone <tone type> <power>
-Tone type
-    1 - Carrier FeedThrough
-    2 - Single tone
-Power [0 - 10000] mdB
-
-Stop transmission
-calibrator wlan0 plt tx_stop
-
-Get out from PLT mode
-calibrator wlan0 plt power_mode off
-
--------------------------------------------------------------------------------
-
-The project can be accessed from git repository:
-	git clone git://github.com/TI-OpenLink/ti-utils.git
diff --git a/mac80211/ti-utils/calibrator.c b/mac80211/ti-utils/calibrator.c
deleted file mode 100644
index 7bcd6d3..0000000
--- a/mac80211/ti-utils/calibrator.c
+++ /dev/null
@@ -1,539 +0,0 @@
-/*
- * PLT utility for wireless chip supported by TI's driver wl12xx
- *
- * See README and COPYING for more details.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-#include <net/if.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdbool.h>
-
-#include <netlink/genl/genl.h>
-#include <netlink/genl/family.h>
-#include <netlink/genl/ctrl.h>
-#include <netlink/msg.h>
-#include <netlink/attr.h>
-
-#include "nl80211.h"
-#include "calibrator.h"
-#include "plt.h"
-#include "ini.h"
-
-char calibrator_version[] = "0.73";
-#ifndef CONFIG_LIBNL20
-/* libnl 2.0 compatibility code */
-
-static inline struct nl_handle *nl_socket_alloc(void)
-{
-	return nl_handle_alloc();
-}
-
-static inline void nl_socket_free(struct nl_sock *h)
-{
-	nl_handle_destroy(h);
-}
-
-static inline int __genl_ctrl_alloc_cache(struct nl_sock *h,
-	struct nl_cache **cache)
-{
-	struct nl_cache *tmp = genl_ctrl_alloc_cache(h);
-	if (!tmp)
-		return -ENOMEM;
-	*cache = tmp;
-	return 0;
-}
-#define genl_ctrl_alloc_cache __genl_ctrl_alloc_cache
-#endif /* CONFIG_LIBNL20 */
-
-int calibrator_debug;
-
-static int nl80211_init(struct nl80211_state *state)
-{
-	int err;
-
-	state->nl_sock = nl_socket_alloc();
-	if (!state->nl_sock) {
-		fprintf(stderr, "Failed to allocate netlink socket.\n");
-		return -ENOMEM;
-	}
-
-	if (genl_connect(state->nl_sock)) {
-		fprintf(stderr, "Failed to connect to generic netlink.\n");
-		err = -ENOLINK;
-		goto out_handle_destroy;
-	}
-
-	if (genl_ctrl_alloc_cache(state->nl_sock, &state->nl_cache)) {
-		fprintf(stderr, "Failed to allocate generic netlink cache.\n");
-		err = -ENOMEM;
-		goto out_handle_destroy;
-	}
-
-	state->nl80211 = genl_ctrl_search_by_name(state->nl_cache, "nl80211");
-	if (!state->nl80211) {
-		fprintf(stderr, "nl80211 not found.\n");
-		err = -ENOENT;
-		goto out_cache_free;
-	}
-
-	return 0;
-
- out_cache_free:
-	nl_cache_free(state->nl_cache);
- out_handle_destroy:
-	nl_socket_free(state->nl_sock);
-	return err;
-}
-
-static void nl80211_cleanup(struct nl80211_state *state)
-{
-	genl_family_put(state->nl80211);
-	nl_cache_free(state->nl_cache);
-	nl_socket_free(state->nl_sock);
-}
-
-static int cmd_size;
-
-extern struct cmd __start___cmd;
-extern struct cmd __stop___cmd;
-
-#define for_each_cmd(_cmd)					\
-	for (_cmd = &__start___cmd; _cmd < &__stop___cmd;		\
-	     _cmd = (const struct cmd *)((char *)_cmd + cmd_size))
-
-
-static void __usage_cmd(const struct cmd *cmd, char *indent, bool full)
-{
-	const char *start, *lend, *end;
-
-	printf("%s", indent);
-
-	switch (cmd->idby) {
-	case CIB_NONE:
-		break;
-	case CIB_PHY:
-		printf("phy <phyname> ");
-		break;
-	case CIB_NETDEV:
-		printf("dev <devname> ");
-		break;
-	}
-	if (cmd->parent && cmd->parent->name)
-		printf("%s ", cmd->parent->name);
-	printf("%s", cmd->name);
-	if (cmd->args)
-		printf(" %s", cmd->args);
-	printf("\n");
-
-	if (!full || !cmd->help)
-		return;
-
-	/* hack */
-	if (strlen(indent))
-		indent = "\t\t";
-	else
-		printf("\n");
-
-	/* print line by line */
-	start = cmd->help;
-	end = strchr(start, '\0');
-	do {
-		lend = strchr(start, '\n');
-		if (!lend)
-			lend = end;
-		printf("%s", indent);
-		printf("%.*s\n", (int)(lend - start), start);
-		start = lend + 1;
-	} while (end != lend);
-
-	printf("\n");
-}
-
-static void usage_options(void)
-{
-	printf("Options:\n");
-	printf("\t--debug\t\tenable netlink debugging\n");
-}
-
-static const char *argv0;
-
-static void usage(bool full)
-{
-	const struct cmd *section, *cmd;
-
-	printf("Usage:\t%s [options] command\n", argv0);
-	usage_options();
-	printf("\t--version\tshow version (%s)\n", calibrator_version);
-	printf("Commands:\n");
-	for_each_cmd(section) {
-		if (section->parent)
-			continue;
-
-		if (section->handler && !section->hidden)
-			__usage_cmd(section, "\t", full);
-
-		for_each_cmd(cmd) {
-			if (section != cmd->parent)
-				continue;
-			if (!cmd->handler || cmd->hidden)
-				continue;
-			__usage_cmd(cmd, "\t", full);
-		}
-	}
-#if 0
-	printf("\nYou can omit the 'phy' or 'dev' if "
-			"the identification is unique,\n"
-			"e.g. \"iw wlan0 info\" or \"iw phy0 info\". "
-			"(Don't when scripting.)\n\n"
-			"Do NOT screenscrape this tool, we don't "
-			"consider its output stable.\n\n");
-#endif
-}
-
-static int print_help(struct nl80211_state *state,
-		      struct nl_cb *cb,
-		      struct nl_msg *msg,
-		      int argc, char **argv)
-{
-	exit(3);
-}
-TOPLEVEL(help, NULL, 0, 0, CIB_NONE, print_help,
-	 "Print usage for each command.");
-
-static void usage_cmd(const struct cmd *cmd)
-{
-	printf("\nUsage:\t%s [options] ", argv0);
-	__usage_cmd(cmd, "", true);
-	usage_options();
-}
-
-static void version(void)
-{
-	printf("calibrator version %s\n", calibrator_version);
-}
-
-static int phy_lookup(char *name)
-{
-	char buf[200];
-	int fd, pos;
-
-	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
-
-	fd = open(buf, O_RDONLY);
-	if (fd < 0)
-		return -1;
-	pos = read(fd, buf, sizeof(buf) - 1);
-	if (pos < 0) {
-		close(fd);
-		return -1;
-	}
-	buf[pos] = '\0';
-	close(fd);
-	return atoi(buf);
-}
-
-static int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,
-			 void *arg)
-{
-	int *ret = arg;
-	*ret = err->error;
-
-	return NL_STOP;
-}
-
-static int finish_handler(struct nl_msg *msg, void *arg)
-{
-	int *ret = arg;
-	*ret = 0;
-
-	return NL_SKIP;
-}
-
-static int ack_handler(struct nl_msg *msg, void *arg)
-{
-	int *ret = arg;
-	*ret = 0;
-
-	return NL_STOP;
-}
-
-static int __handle_cmd(struct nl80211_state *state, enum id_input idby,
-			int argc, char **argv, const struct cmd **cmdout)
-{
-	const struct cmd *cmd, *match = NULL, *sectcmd;
-	struct nl_cb *cb;
-	struct nl_msg *msg;
-	int devidx = 0;
-	int err, o_argc;
-	const char *command, *section;
-	char *tmp, **o_argv;
-	enum command_identify_by command_idby = CIB_NONE;
-#if 0
-	if (file_exist(CURRENT_NVS_NAME) < 0) {
-		fprintf(stderr, "\n\tUnable to find NVS file (%s).\n\t"
-			"Make sure to use reference-nvs.bin instead.\n\n",
-			CURRENT_NVS_NAME);
-		return 2;
-	}
-#endif
-	if (argc <= 1)
-		return 1;
-
-	o_argc = argc;
-	o_argv = argv;
-
-	switch (idby) {
-	case II_PHY_IDX:
-		command_idby = CIB_PHY;
-		devidx = strtoul(*argv + 4, &tmp, 0);
-		if (*tmp != '\0')
-			return 1;
-		argc--;
-		argv++;
-		break;
-	case II_PHY_NAME:
-		command_idby = CIB_PHY;
-		devidx = phy_lookup(*argv);
-		argc--;
-		argv++;
-		break;
-	case II_NETDEV:
-		command_idby = CIB_NETDEV;
-		devidx = if_nametoindex(*argv);
-		if (devidx == 0)
-			devidx = -1;
-		argc--;
-		argv++;
-		break;
-	default:
-		break;
-	}
-
-	if (devidx < 0)
-		return -errno;
-
-	section = *argv;
-	argc--;
-	argv++;
-
-	for_each_cmd(sectcmd) {
-		if (sectcmd->parent)
-			continue;
-		/* ok ... bit of a hack for the dupe 'info' section */
-		if (match && sectcmd->idby != command_idby)
-			continue;
-
-		if (strcmp(sectcmd->name, section) == 0)
-			match = sectcmd;
-	}
-
-	sectcmd = match;
-	match = NULL;
-	if (!sectcmd)
-		return 1;
-
-	if (argc > 0) {
-		command = *argv;
-
-		for_each_cmd(cmd) {
-			if (!cmd->handler)
-				continue;
-			if (cmd->parent != sectcmd)
-				continue;
-			if (cmd->idby != command_idby)
-				continue;
-			if (strcmp(cmd->name, command))
-				continue;
-			if (argc > 1 && !cmd->args)
-				continue;
-			match = cmd;
-			break;
-		}
-
-		if (match) {
-			argc--;
-			argv++;
-		}
-	}
-
-
-	if (match)
-		cmd = match;
-	else {
-		/* Use the section itself, if possible. */
-		cmd = sectcmd;
-		if (argc && !cmd->args)
-			return 1;
-		if (cmd->idby != command_idby)
-			return 1;
-		if (!cmd->handler)
-			return 1;
-	}
-
-	if (cmdout)
-		*cmdout = cmd;
-
-	if (!cmd->cmd) {
-		argc = o_argc;
-		argv = o_argv;
-		return cmd->handler(state, NULL, NULL, argc, argv);
-	}
-
-	msg = nlmsg_alloc();
-	if (!msg) {
-		fprintf(stderr, "failed to allocate netlink message\n");
-		return 2;
-	}
-
-	cb = nl_cb_alloc(calibrator_debug ? NL_CB_DEBUG : NL_CB_DEFAULT);
-	if (!cb) {
-		fprintf(stderr, "failed to allocate netlink callbacks\n");
-		err = 2;
-		goto out_free_msg;
-	}
-
-	genlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,
-		    cmd->nl_msg_flags, cmd->cmd, 0);
-
-	switch (command_idby) {
-	case CIB_PHY:
-		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, devidx);
-		break;
-	case CIB_NETDEV:
-		NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, devidx);
-		break;
-	default:
-		break;
-	}
-
-	err = cmd->handler(state, cb, msg, argc, argv);
-	if (err) {
-		fprintf(stderr, "failed to handle\n");
-		goto out;
-	}
-
-	err = nl_send_auto_complete(state->nl_sock, msg);
-	if (err < 0) {
-		fprintf(stderr, "failed to autocomplete\n");
-		goto out;
-	}
-
-	err = 1;
-
-	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);
-	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err);
-	nl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &err);
-
-	while (err > 0)
-		nl_recvmsgs(state->nl_sock, cb);
-
- out:
-	nl_cb_put(cb);
- out_free_msg:
-	nlmsg_free(msg);
-	return err;
-
- nla_put_failure:
-	fprintf(stderr, "building message failed\n");
-	return 2;
-}
-
-int handle_cmd(struct nl80211_state *state, enum id_input idby,
-	       int argc, char **argv)
-{
-	return __handle_cmd(state, idby, argc, argv, NULL);
-}
-
-int main(int argc, char **argv)
-{
-	struct nl80211_state nlstate;
-	int err;
-	const struct cmd *cmd = NULL;
-
-	/* calculate command size including padding */
-	cmd_size = abs((long)&__section_set - (long)&__section_get);
-	/* strip off self */
-	argc--;
-	argv0 = *argv++;
-
-	if (argc > 0 && strcmp(*argv, "--debug") == 0) {
-		calibrator_debug = 1;
-		argc--;
-		argv++;
-	}
-
-	if (argc > 0 && strcmp(*argv, "--version") == 0) {
-		version();
-		return 0;
-	}
-
-	/* need to treat "help" command specially so it works w/o nl80211 */
-	if (argc == 0 || strcmp(*argv, "help") == 0) {
-		usage(argc != 0);
-		return 0;
-	}
-
-	err = nl80211_init(&nlstate);
-	if (err)
-		return 1;
-
-	if (strcmp(*argv, "dev") == 0 && argc > 1) {
-		argc--;
-		argv++;
-		err = __handle_cmd(&nlstate, II_NETDEV, argc, argv, &cmd);
-	} else if (strncmp(*argv, "phy", 3) == 0 && argc > 1) {
-		if (strlen(*argv) == 3) {
-			argc--;
-			argv++;
-			err = __handle_cmd(&nlstate, II_PHY_NAME,
-				argc, argv, &cmd);
-		} else if (*(*argv + 3) == '#')
-			err = __handle_cmd(&nlstate, II_PHY_IDX,
-				argc, argv, &cmd);
-		else
-			goto detect;
-	} else {
-		int idx;
-		enum id_input idby = II_NONE;
- detect:
-		idx = if_nametoindex(argv[0]);
-		if (idx != 0)
-			idby = II_NETDEV;
-		else {
-			idx = phy_lookup(argv[0]);
-			if (idx >= 0)
-				idby = II_PHY_NAME;
-		}
-
-		err = __handle_cmd(&nlstate, idby, argc, argv, &cmd);
-	}
-
-	if (err == 1) {
-		if (cmd)
-			usage_cmd(cmd);
-		else
-			usage(false);
-	} else if (err < 0)
-		fprintf(stderr, "command failed: %s (%d)\n",
-			strerror(-err), err);
-
-	nl80211_cleanup(&nlstate);
-
-	return err;
-}
-
-void str2mac(unsigned char *pmac, char *pch)
-{
-	int i;
-
-	for (i = 0; i < MAC_ADDR_LEN; i++) {
-		pmac[i] = (unsigned char)strtoul(pch, &pch, 16);
-		pch++;
-	}
-}
diff --git a/mac80211/ti-utils/calibrator.h b/mac80211/ti-utils/calibrator.h
deleted file mode 100644
index 2c91c84..0000000
--- a/mac80211/ti-utils/calibrator.h
+++ /dev/null
@@ -1,157 +0,0 @@
-#ifndef __CALIBRATOR_H
-#define __CALIBRATOR_H
-
-#include <stdbool.h>
-#include <netlink/netlink.h>
-#include <netlink/genl/genl.h>
-#include <netlink/genl/family.h>
-#include <netlink/genl/ctrl.h>
-
-#include "nl80211.h"
-
-#define ETH_ALEN 6
-
-#ifndef CONFIG_LIBNL20
-#  define nl_sock nl_handle
-#endif
-
-struct nl80211_state {
-	struct nl_sock *nl_sock;
-	struct nl_cache *nl_cache;
-	struct genl_family *nl80211;
-};
-
-enum command_identify_by {
-	CIB_NONE,
-	CIB_PHY,
-	CIB_NETDEV,
-};
-
-enum id_input {
-	II_NONE,
-	II_NETDEV,
-	II_PHY_NAME,
-	II_PHY_IDX,
-};
-
-struct cmd {
-	const char *name;
-	const char *args;
-	const char *help;
-	const enum nl80211_commands cmd;
-	int nl_msg_flags;
-	int hidden;
-	const enum command_identify_by idby;
-	/*
-	 * The handler should return a negative error code,
-	 * zero on success, 1 if the arguments were wrong
-	 * and the usage message should and 2 otherwise.
-	 */
-	int (*handler)(struct nl80211_state *state,
-		       struct nl_cb *cb,
-		       struct nl_msg *msg,
-		       int argc, char **argv);
-	const struct cmd *parent;
-};
-
-#define ARRAY_SIZE(ar) (sizeof(ar)/sizeof(ar[0]))
-
-#define __COMMAND(_section, _symname, _name, _args, _nlcmd, _flags, _hidden, _idby, _handler, _help)\
-	static struct cmd						\
-	__cmd ## _ ## _symname ## _ ## _handler ## _ ## _nlcmd ## _ ## _idby ## _ ## _hidden\
-	__attribute__((used)) __attribute__((section("__cmd")))	= {	\
-		.name = (_name),					\
-		.args = (_args),					\
-		.cmd = (_nlcmd),					\
-		.nl_msg_flags = (_flags),				\
-		.hidden = (_hidden),					\
-		.idby = (_idby),					\
-		.handler = (_handler),					\
-		.help = (_help),					\
-		.parent = _section,					\
-	 }
-#define COMMAND(section, name, args, cmd, flags, idby, handler, help)	\
-	__COMMAND(&(__section ## _ ## section), name, #name, args, cmd, flags, 0, idby, handler, help)
-#define HIDDEN(section, name, args, cmd, flags, idby, handler)		\
-	__COMMAND(&(__section ## _ ## section), name, #name, args, cmd, flags, 1, idby, handler, NULL)
-
-#define TOPLEVEL(_name, _args, _nlcmd, _flags, _idby, _handler, _help)	\
-	struct cmd							\
-	__section ## _ ## _name						\
-	__attribute__((used)) __attribute__((section("__cmd")))	= {	\
-		.name = (#_name),					\
-		.args = (_args),					\
-		.cmd = (_nlcmd),					\
-		.nl_msg_flags = (_flags),				\
-		.idby = (_idby),					\
-		.handler = (_handler),					\
-		.help = (_help),					\
-	 }
-#define SECTION(_name)							\
-	struct cmd __section ## _ ## _name				\
-	__attribute__((used)) __attribute__((section("__cmd"))) = {	\
-		.name = (#_name),					\
-		.hidden = 1,						\
-	}
-
-#define DECLARE_SECTION(_name)						\
-	extern struct cmd __section ## _ ## _name;
-
-extern int calibrator_debug;
-
-int handle_cmd(struct nl80211_state *state, enum id_input idby,
-	       int argc, char **argv);
-
-struct print_event_args {
-	bool frame, time;
-};
-
-__u32 listen_events(struct nl80211_state *state,
-		    const int n_waits, const __u32 *waits);
-__u32 __listen_events(struct nl80211_state *state,
-		      const int n_waits, const __u32 *waits,
-		      struct print_event_args *args);
-
-
-int mac_addr_a2n(unsigned char *mac_addr, char *arg);
-void mac_addr_n2a(char *mac_addr, unsigned char *arg);
-
-int parse_keys(struct nl_msg *msg, char **argv, int argc);
-
-void print_ht_mcs(const __u8 *mcs);
-void print_ampdu_length(__u8 exponent);
-void print_ampdu_spacing(__u8 spacing);
-void print_ht_capability(__u16 cap);
-
-const char *iftype_name(enum nl80211_iftype iftype);
-const char *command_name(enum nl80211_commands cmd);
-int ieee80211_channel_to_frequency(int chan);
-int ieee80211_frequency_to_channel(int freq);
-
-void print_ssid_escaped(const uint8_t len, const uint8_t *data);
-
-int nl_get_multicast_id(struct nl_sock *sock, const char *family,
-	const char *group);
-
-char *reg_initiator_to_string(__u8 initiator);
-
-const char *get_reason_str(uint16_t reason);
-const char *get_status_str(uint16_t status);
-
-enum print_ie_type {
-	PRINT_SCAN,
-	PRINT_LINK,
-};
-
-#define BIT(x) (1ULL<<(x))
-
-void print_ies(unsigned char *ie, int ielen, bool unknown,
-	       enum print_ie_type ptype);
-
-void str2mac(unsigned char *pmac, char *pch);
-
-DECLARE_SECTION(set);
-DECLARE_SECTION(get);
-DECLARE_SECTION(plt);
-
-#endif /* __CALIBRATOR_H */
diff --git a/mac80211/ti-utils/ini.c b/mac80211/ti-utils/ini.c
deleted file mode 100644
index e7caf8d..0000000
--- a/mac80211/ti-utils/ini.c
+++ /dev/null
@@ -1,1185 +0,0 @@
-/*
- * PLT utility for wireless chip supported by TI's driver wl12xx
- *
- * See README and COPYING for more details.
- */
-
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdbool.h>
-#include <limits.h>
-
-#include <netlink/genl/genl.h>
-#include <netlink/genl/family.h>
-#include <netlink/genl/ctrl.h>
-#include <netlink/msg.h>
-#include <netlink/attr.h>
-#include <linux/wireless.h>
-#include "nl80211.h"
-
-#include "calibrator.h"
-#include "plt.h"
-#include "ini.h"
-#include "nvs.h"
-
-static char *ini_get_line(char *s, int size, FILE *stream, int *line,
-				  char **_pos)
-{
-	char *pos, *end, *sstart;
-
-	while (fgets(s, size, stream)) {
-		s[size - 1] = '\0';
-		pos = s;
-
-		/* Skip white space from the beginning of line. */
-		while (*pos == ' ' || *pos == '\t' || *pos == '\r')
-			pos++;
-
-		/* Skip comment lines and empty lines */
-		if (*pos == '#' || *pos == '\n' || *pos == '\0')
-			continue;
-
-		/*
-		 * Remove # comments unless they are within a double quoted
-		 * string.
-		 */
-		sstart = strchr(pos, '"');
-		if (sstart)
-			sstart = strrchr(sstart + 1, '"');
-		if (!sstart)
-			sstart = pos;
-		end = strchr(sstart, '#');
-		if (end)
-			*end-- = '\0';
-		else
-			end = pos + strlen(pos) - 1;
-
-		/* Remove trailing white space. */
-		while (end > pos &&
-		       (*end == '\n' || *end == ' ' || *end == '\t' ||
-			*end == '\r'))
-			*end-- = '\0';
-
-		if (*pos == '\0')
-			continue;
-
-		(*line)++;
-
-		if (_pos)
-			*_pos = pos;
-		return pos;
-	}
-
-	if (_pos)
-		*_pos = NULL;
-
-	return NULL;
-}
-
-static int split_line(char *line, char **name, char **value)
-{
-	char *pos = line;
-
-	*value = strchr(pos, '=');
-	if (!*value) {
-		fprintf(stderr, "Wrong format of line\n");
-		return 1;
-	}
-
-	*name = *value;
-
-	(*name)--;
-	while (**name == ' ' || **name == '\t' || **name == '\r')
-		(*name)--;
-
-	*++(*name) = '\0';
-
-	(*value)++;
-	while (**value == ' ' || **value == '\t' || **value == '\r')
-		(*value)++;
-
-	return 0;
-}
-
-/* Parse array of unsigned chars */
-static int parse_uc_a(char* name, char *val, unsigned char *out, size_t exp_size)
-{
-	size_t i = 0;
-	long v;
-	char *endval;
-
-	while (*val) {
-		/* Advance to next token */
-		while (*val == ' ' || *val == ',')
-			val++;
-
-		if (i >= exp_size) {
-			fprintf(stderr, "Too many params for %s\n", name);
-			return 1;
-		}
-		v = strtol(val, &endval, 16);
-
-		if (endval == val) {
-			fprintf(stderr, "Syntax error parsing %s\n", name);
-			return 1;
-		}
-		if (v > (long) UCHAR_MAX) {
-			fprintf(stderr, "Overflow parsing %s\n", name);
-			return 1;
-		}
-		out[i++] = v;
-		val = endval;
-	}
-
-	if(exp_size != i) {
-		fprintf(stderr, "Too few parameters for %s\n", name);
-		return 1;
-	}
-
-	return 0;
-}
-
-/* Parse array of __le16 */
-static int parse_ui_a(char* name, char *val, __le16 *out, size_t exp_size)
-{
-	size_t i = 0;
-	long v;
-	char *endval;
-
-	while (*val) {
-		/* Advance to next token */
-		while (*val == ' ' || *val == ',')
-			val++;
-
-		if (i >= exp_size) {
-			fprintf(stderr, "Too many params for %s\n", name);
-			return 1;
-		}
-		v = strtol(val, &endval, 16);
-
-		if (endval == val) {
-			fprintf(stderr, "Syntax error parsing %s\n", name);
-			return 1;
-		}
-		if (v > (long) INT16_MAX) {
-			fprintf(stderr, "Overflow parsing %s\n", name);
-			return 1;
-		}
-		out[i++] = v;
-
-		val = endval;
-	}
-
-	if(exp_size != i) {
-		fprintf(stderr, "Too few parameters for %s\n", name);
-		return 1;
-	}
-
-	return 0;
-}
-
-#define COMPARE_N_ADD(temp, str, val, ptr)			\
-	if (strncmp(temp, str, sizeof(temp)) == 0) {		\
-		return parse_uc_a(temp, val, (unsigned char*) ptr, sizeof(*ptr)); \
-	}
-
-#define COMPARE_N_ADD2(temp, str, val, ptr)		\
-	if (strncmp(temp, str, sizeof(temp)) == 0) {		\
-		return parse_ui_a(temp, val, (__le16*) ptr, sizeof(*ptr)/2); \
-	}
-
-static int parse_general_prms(char *l, struct wl12xx_common *cmn,
-	struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_general_params *gp = &(p->ini1271.general_params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("TXBiPFEMAutoDetect", l, val,
-		&gp->tx_bip_fem_auto_detect);
-
-	cmn->auto_fem = gp->tx_bip_fem_auto_detect;
-
-	COMPARE_N_ADD("TXBiPFEMManufacturer", l, val,
-		&gp->tx_bip_fem_manufacturer);
-
-	COMPARE_N_ADD("RefClk", l, val, &gp->ref_clock);
-
-	COMPARE_N_ADD("SettlingTime", l, val, &gp->settling_time);
-
-	COMPARE_N_ADD("ClockValidOnWakeup", l, val,
-		&gp->clk_valid_on_wakeup);
-
-	COMPARE_N_ADD("DC2DCMode", l, val, &gp->dc2dc_mode);
-
-	COMPARE_N_ADD("Single_Dual_Band_Solution", l, val,
-		&gp->dual_mode_select);
-
-	COMPARE_N_ADD("Settings", l, val, &gp->general_settings);
-
-	COMPARE_N_ADD("SRState", l, val, &gp->sr_state);
-
-	COMPARE_N_ADD("SRF1", l, val, &gp->srf1);
-
-	COMPARE_N_ADD("SRF2", l, val, &gp->srf2);
-
-	COMPARE_N_ADD("SRF3", l, val, &gp->srf3);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_general_prms_128x(char *l, struct wl12xx_common *cmn,
-	struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_general_params *gp =
-		&(p->ini128x.general_params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-
-	COMPARE_N_ADD("TXBiPFEMAutoDetect", l, val,
-		&gp->tx_bip_fem_auto_detect);
-
-	COMPARE_N_ADD("TXBiPFEMManufacturer", l, val,
-		&gp->tx_bip_fem_manufacturer);
-
-	cmn->auto_fem = gp->tx_bip_fem_auto_detect;
-
-	COMPARE_N_ADD("RefClk", l, val, &gp->ref_clock);
-
-	COMPARE_N_ADD("SettlingTime", l, val, &gp->settling_time);
-
-	COMPARE_N_ADD("ClockValidOnWakeup", l, val, &gp->clk_valid_on_wakeup);
-
-	COMPARE_N_ADD("TCXO_Clk", l, val, &gp->tcxo_ref_clock);
-
-	COMPARE_N_ADD("TCXO_SettlingTime", l, val, &gp->tcxo_settling_time);
-
-	COMPARE_N_ADD("TCXO_ClockValidOnWakeup", l, val,
-		&gp->tcxo_valid_on_wakeup);
-
-	COMPARE_N_ADD("TCXO_LDO_Voltage", l, val, &gp->tcxo_ldo_voltage);
-
-	COMPARE_N_ADD("Platform_configuration", l, val, &gp->platform_conf);
-
-	COMPARE_N_ADD("Single_Dual_Band_Solution", l, val,
-		&gp->dual_mode_select);
-
-	COMPARE_N_ADD("Settings", l, val, &gp->general_settings);
-
-	COMPARE_N_ADD("XTALItrimVal", l, val, &gp->xtal_itrim_val);
-
-	COMPARE_N_ADD("SRState", l, val, &gp->sr_state);
-
-	COMPARE_N_ADD("SRF1", l, val, &gp->srf1);
-
-	COMPARE_N_ADD("SRF2", l, val, &gp->srf2);
-
-	COMPARE_N_ADD("SRF3", l, val, &gp->srf3);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_band2_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_band_params_2 *gp =
-		&(p->ini1271.stat_radio_params_2);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("RxTraceInsertionLoss_2_4G", l, val,
-		&gp->rx_trace_insertion_loss);
-
-	COMPARE_N_ADD("TXTraceLoss_2_4G", l, val,
-		&gp->tx_trace_loss);
-
-	COMPARE_N_ADD("RxRssiAndProcessCompensation_2_4G", l, val,
-		&gp->rx_rssi_process_compens);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_band2_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_band_params_2 *gp = &(p->ini128x.stat_radio_params_2);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("RxTraceInsertionLoss_2_4G", l, val,
-		&gp->rx_trace_insertion_loss);
-
-	COMPARE_N_ADD("TxTraceLoss_2_4G", l, val, &gp->tx_trace_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_band5_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_band_params_5 *gp =
-		&(p->ini1271.stat_radio_params_5);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("RxTraceInsertionLoss_5G", l, val,
-		&gp->rx_trace_insertion_loss);
-
-	COMPARE_N_ADD("TXTraceLoss_5G", l, val,
-		&gp->tx_trace_loss);
-
-	COMPARE_N_ADD("RxRssiAndProcessCompensation_5G", l, val,
-		&gp->rx_rssi_process_compens);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_band5_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_band_params_5 *gp = &(p->ini128x.stat_radio_params_5);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("RxTraceInsertionLoss_5G", l, val,
-		&gp->rx_trace_insertion_loss);
-
-	COMPARE_N_ADD("TxTraceLoss_5G", l, val,
-		&gp->tx_trace_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem0_band2_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_fem_params_2 *gp =
-		&(p->ini1271.dyn_radio_params_2[0].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM0_TXBiPReferencePDvoltage_2_4G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM0_TxBiPReferencePower_2_4G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM0_TxBiPOffsetdB_2_4G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM0_DegradedLowToNormalThr_2_4G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM0_NormalToDegradedHighThr_2_4G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_2_4G_11b", l, val,
-		&gp->tx_per_chan_pwr_limits_11b);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_2_4G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM0_TxPDVsRateOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM0_TxIbiasTable_2_4G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM0_RxFemInsertionLoss_2_4G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem0_band2_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_fem_params_2 *gp =
-		&(p->ini128x.dyn_radio_params_2[0].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM0_TxBiPReferencePDvoltage_2_4G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM0_TxBiPReferencePower_2_4G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM0_TxBiPOffsetdB_2_4G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_2_4G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM0_DegradedLowToNormalThr_2_4G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM0_NormalToDegradedHighThr_2_4G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_2_4G_11b", l, val,
-		&gp->tx_per_chan_pwr_limits_11b);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_2_4G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM0_TxPDVsRateOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM0_TxPDVsChannelOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_chan_offsets);
-
-	COMPARE_N_ADD("FEM0_TxPDVsTemperature_2_4G", l, val,
-		&gp->tx_pd_vs_temperature);
-
-	COMPARE_N_ADD("FEM0_TxIbiasTable_2_4G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM0_RxFemInsertionLoss_2_4G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem1_band2_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_fem_params_2 *gp =
-		&(p->ini1271.dyn_radio_params_2[1].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM1_TXBiPReferencePDvoltage_2_4G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM1_TxBiPReferencePower_2_4G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM1_TxBiPOffsetdB_2_4G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM1_DegradedLowToNormalThr_2_4G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM1_NormalToDegradedHighThr_2_4G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_2_4G_11b", l, val,
-		&gp->tx_per_chan_pwr_limits_11b);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_2_4G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM1_TxPDVsRateOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM1_TxIbiasTable_2_4G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM1_RxFemInsertionLoss_2_4G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem1_band2_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_fem_params_2 *gp =
-		&(p->ini128x.dyn_radio_params_2[1].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM1_TxBiPReferencePDvoltage_2_4G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM1_TxBiPReferencePower_2_4G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM1_TxBiPOffsetdB_2_4G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_2_4G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM1_DegradedLowToNormalThr_2_4G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM1_NormalToDegradedHighThr_2_4G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_2_4G_11b", l, val,
-		&gp->tx_per_chan_pwr_limits_11b);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_2_4G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM1_TxPDVsRateOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM1_TxPDVsChannelOffsets_2_4G", l, val,
-		&gp->tx_pd_vs_chan_offsets);
-
-	COMPARE_N_ADD("FEM1_TxPDVsTemperature_2_4G", l, val,
-		&gp->tx_pd_vs_temperature);
-
-	COMPARE_N_ADD("FEM1_TxIbiasTable_2_4G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM1_RxFemInsertionLoss_2_4G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem0_band5_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_fem_params_5 *gp =
-		&(p->ini1271.dyn_radio_params_5[0].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM0_TXBiPReferencePDvoltage_5G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM0_TxBiPReferencePower_5G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM0_TxBiPOffsetdB_5G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM0_DegradedLowToNormalThr_5G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM0_NormalToDegradedHighThr_5G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_5G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM0_TxPDVsRateOffsets_5G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM0_TxIbiasTable_5G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM0_RxFemInsertionLoss_5G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem1_band5_prms(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl1271_ini_fem_params_5 *gp =
-		&(p->ini1271.dyn_radio_params_5[1].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM1_TXBiPReferencePDvoltage_5G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM1_TxBiPReferencePower_5G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM1_TxBiPOffsetdB_5G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM1_DegradedLowToNormalThr_5G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM1_NormalToDegradedHighThr_5G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_5G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM1_TxPDVsRateOffsets_5G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM1_TxIbiasTable_5G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM1_RxFemInsertionLoss_5G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem1_band5_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_fem_params_5 *gp =
-		&(p->ini128x.dyn_radio_params_5[1].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM1_TxBiPReferencePDvoltage_5G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM1_TxBiPReferencePower_5G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM1_TxBiPOffsetdB_5G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM1_TxPerRatePowerLimits_5G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM1_DegradedLowToNormalThr_5G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM1_NormalToDegradedHighThr_5G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM1_TxPerChannelPowerLimits_5G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM1_TxPDVsRateOffsets_5G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM1_TxPDVsChannelOffsets_5G", l, val,
-		&gp->tx_pd_vs_chan_offsets);
-
-	COMPARE_N_ADD("FEM1_TxPDVsTemperature_5G", l, val,
-		&gp->tx_pd_vs_temperature);
-
-	COMPARE_N_ADD("FEM1_TxIbiasTable_5G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM1_RxFemInsertionLoss_5G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem0_band5_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini_fem_params_5 *gp =
-		&(p->ini128x.dyn_radio_params_5[0].params);
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD2("FEM0_TxBiPReferencePDvoltage_5G", l, val,
-		&gp->tx_bip_ref_pd_voltage);
-
-	COMPARE_N_ADD("FEM0_TxBiPReferencePower_5G", l, val,
-		&gp->tx_bip_ref_power);
-
-	COMPARE_N_ADD("FEM0_TxBiPOffsetdB_5G", l, val,
-		&gp->tx_bip_ref_offset);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Normal", l, val,
-		&gp->tx_per_rate_pwr_limits_normal);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Degraded", l, val,
-		&gp->tx_per_rate_pwr_limits_degraded);
-
-	COMPARE_N_ADD("FEM0_TxPerRatePowerLimits_5G_Extreme", l, val,
-		&gp->tx_per_rate_pwr_limits_extreme);
-
-	COMPARE_N_ADD("FEM0_DegradedLowToNormalThr_5G", l, val,
-		&gp->degraded_low_to_normal_thr);
-
-	COMPARE_N_ADD("FEM0_NormalToDegradedHighThr_5G", l, val,
-		&gp->normal_to_degraded_high_thr);
-
-	COMPARE_N_ADD("FEM0_TxPerChannelPowerLimits_5G_OFDM", l, val,
-		&gp->tx_per_chan_pwr_limits_ofdm);
-
-	COMPARE_N_ADD("FEM0_TxPDVsRateOffsets_5G", l, val,
-		&gp->tx_pd_vs_rate_offsets);
-
-	COMPARE_N_ADD("FEM0_TxPDVsChannelOffsets_5G", l, val,
-		&gp->tx_pd_vs_chan_offsets);
-
-	COMPARE_N_ADD("FEM0_TxPDVsTemperature_5G", l, val,
-		&gp->tx_pd_vs_temperature);
-
-	COMPARE_N_ADD("FEM0_TxIbiasTable_5G", l, val,
-		&gp->tx_ibias);
-
-	COMPARE_N_ADD("FEM0_RxFemInsertionLoss_5G", l, val,
-		&gp->rx_fem_insertion_loss);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int parse_fem_prms_128x(char *l, struct wl12xx_ini *p)
-{
-	char *name, *val;
-	struct wl128x_ini *gp = &p->ini128x;
-
-	if (split_line(l, &name, &val))
-		return 1;
-
-	COMPARE_N_ADD("FemVendorAndOptions", l, val,
-		&gp->fem_vendor_and_options);
-
-	fprintf(stderr, "Unable to parse: (%s)\n", l);
-
-	return 1;
-}
-
-static int find_section(const char *l, enum wl1271_ini_section *st, int *cntr,
-	struct wl12xx_common *cmn)
-{
-	enum wl12xx_arch arch = cmn->arch;
-	if (strncmp("TXBiPFEMAutoDetect", l, 18) == 0) {
-		*st = GENERAL_PRMS;
-		if (arch == WL128X_ARCH)
-			*cntr = 17;
-		else
-			*cntr = 12;
-
-		return 0;
-	}
-
-	if (strncmp("RxTraceInsertionLoss_2_4G", l, 25) == 0) {
-		*st = BAND2_PRMS;
-		if (arch == WL128X_ARCH)
-			*cntr = 2;
-		else
-			*cntr = 3;
-
-		return 0;
-	}
-
-	if (strncmp("FemVendorAndOptions", l, 19) == 0) {
-		*st = FEM_PRMS;
-		*cntr = 1;
-		return 0;
-	}
-
-	if (strncmp("RxTraceInsertionLoss_5G", l, 23) == 0) {
-		*st = BAND5_PRMS;
-		if (arch == WL128X_ARCH)
-			*cntr = 2;
-		else
-			*cntr = 3;
-
-		return 0;
-	}
-
-	if (strncmp("FEM0_TXBiPReferencePDvoltage_2_4G", l, 33) == 0 ||
-		strncmp("FEM0_TxBiPReferencePDvoltage_2_4G", l, 33) == 0) {
-		*st = FEM0_BAND2_PRMS;
-		cmn->fem0_bands++;
-		if (arch == WL128X_ARCH)
-			*cntr = 15;
-		else
-			*cntr = 13;
-
-		return 0;
-	}
-
-	if (strncmp("FEM1_TXBiPReferencePDvoltage_2_4G", l, 33) == 0 ||
-		strncmp("FEM1_TxBiPReferencePDvoltage_2_4G", l, 33) == 0) {
-		*st = FEM1_BAND2_PRMS;
-		cmn->fem1_bands++;
-		if (arch == WL128X_ARCH)
-			*cntr = 15;
-		else
-			*cntr = 13;
-
-		return 0;
-	}
-
-	if (strncmp("FEM1_TXBiPReferencePDvoltage_5G", l, 31) == 0 ||
-		strncmp("FEM1_TxBiPReferencePDvoltage_5G", l, 31) == 0) {
-		*st = FEM1_BAND5_PRMS;
-		cmn->fem1_bands++;
-		if (arch == WL128X_ARCH)
-			*cntr = 14;
-		else
-			*cntr = 12;
-
-		return 0;
-	}
-
-	if (strncmp("FEM0_TXBiPReferencePDvoltage_5G", l, 31) == 0 ||
-		strncmp("FEM0_TxBiPReferencePDvoltage_5G", l, 31) == 0) {
-		*st = FEM0_BAND5_PRMS;
-		cmn->fem0_bands++;
-		if (arch == WL128X_ARCH)
-			*cntr = 14;
-		else
-			*cntr = 12;
-
-		return 0;
-	}
-
-	return 1;
-}
-
-static int ini_parse_line(char *l, struct wl12xx_common *cmn)
-{
-	static enum wl1271_ini_section status;
-	static int cntr;
-
-	if (!cntr && find_section(l, &status, &cntr, cmn)) {
-		fprintf(stderr, "Uknown ini section %s\n", l);
-		return 1;
-	}
-
-	switch (status) {
-	case GENERAL_PRMS:	/* general parameters */
-		cntr--;
-		return cmn->parse_ops->prs_general_prms(l, cmn, &cmn->ini);
-	case FEM_PRMS:	/* FEM parameters */
-		if (cmn->arch == WL1271_ARCH) {
-			fprintf(stderr, "The parameter not from 127x architecture\n");
-			return 1;
-		}
-		cntr--;
-		return parse_fem_prms_128x(l, &cmn->ini);
-	case BAND2_PRMS:	/* band 2.4GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_band2_prms(l, &cmn->ini);
-	case BAND5_PRMS:	/* band 5GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_band5_prms(l, &cmn->ini);
-	case FEM0_BAND2_PRMS:	/* FEM0 band 2.4GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_fem0_band2_prms(l, &cmn->ini);
-	case FEM1_BAND2_PRMS:	/* FEM1 band 2.4GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_fem1_band2_prms(l, &cmn->ini);
-	case FEM0_BAND5_PRMS:	/* FEM0 band 5GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_fem0_band5_prms(l, &cmn->ini);
-	case FEM1_BAND5_PRMS:	/* FEM1 band 5GHz parameters */
-		cntr--;
-		return cmn->parse_ops->prs_fem1_band5_prms(l, &cmn->ini);
-	case UKNOWN_SECTION:
-		/* added because of compilation warning. handeled in find_section() */
-		break;
-	}
-
-	return 1;
-}
-
-#if 0
-static void ini_dump(struct wl1271_ini *ini)
-{
-	int i;
-
-	printf("\n");
-	printf("General params:\n");
-	printf("ref clock:                 %02X\n",
-		ini->general_params.ref_clock);
-	printf("settling time:             %02X\n",
-		ini->general_params.settling_time);
-	printf("clk valid on wakeup:       %02X\n",
-		ini->general_params.clk_valid_on_wakeup);
-	printf("dc2dc mode:                %02X\n",
-		ini->general_params.dc2dc_mode);
-	printf("dual band mode:            %02X\n",
-		ini->general_params.dual_mode_select);
-	printf("tx bip fem auto detect:    %02X\n",
-		ini->general_params.tx_bip_fem_auto_detect);
-	printf("tx bip fem manufacturer:   %02X\n",
-		ini->general_params.tx_bip_fem_manufacturer);
-	printf("general settings:          %02X\n",
-		ini->general_params.general_settings);
-	printf("sr state:                  %02X\n",
-		ini->general_params.sr_state);
-
-	printf("srf1:");
-	for (i = 0; i < WL1271_INI_MAX_SMART_REFLEX_PARAM; i++)
-		printf(" %02X", ini->general_params.srf1[i]);
-	printf("\n");
-
-	printf("srf2:");
-	for (i = 0; i < WL1271_INI_MAX_SMART_REFLEX_PARAM; i++)
-		printf(" %02X", ini->general_params.srf2[i]);
-	printf("\n");
-
-	printf("srf3:");
-	for (i = 0; i < WL1271_INI_MAX_SMART_REFLEX_PARAM; i++)
-		printf(" %02X", ini->general_params.srf3[i]);
-	printf("\n");
-
-	printf("Static 2.4 band params:\n");
-
-	printf("rx trace insertion loss: %02X\n",
-		ini->stat_radio_params_2.rx_trace_insertion_loss);
-
-	printf("rx rssi n process compensation:");
-	for (i = 0; i < WL1271_INI_RSSI_PROCESS_COMPENS_SIZE; i++)
-		printf(" %02X",
-			ini->stat_radio_params_2.rx_rssi_process_compens[i]);
-	printf("\n");
-
-	printf("tx trace: %02X\n",
-		ini->stat_radio_params_2.tx_trace_loss);
-
-	printf("Dynamic 2.4 band params for FEM\n");
-
-	printf("Static 5 band params:\n");
-
-	printf("rx trace insertion loss:");
-	for (i = 0; i < WL1271_INI_SUB_BAND_COUNT_5; i++)
-		printf(" %02X",
-			ini->stat_radio_params_5.rx_rssi_process_compens[i]);
-	printf("\n");
-
-	printf("rx rssi n process compensation:");
-	for (i = 0; i < WL1271_INI_RSSI_PROCESS_COMPENS_SIZE; i++)
-		printf(" %02X",
-			ini->stat_radio_params_5.rx_rssi_process_compens[i]);
-	printf("\n");
-
-	printf("tx trace:");
-	for (i = 0; i < WL1271_INI_SUB_BAND_COUNT_5; i++)
-		printf(" %02X",
-			ini->stat_radio_params_5.tx_trace_loss[i]);
-	printf("\n");
-
-	printf("Dynamic 5 band params for FEM\n");
-
-}
-#endif
-
-
-static int is_dual_mode(struct wl12xx_ini *p)
-{
-	struct wl1271_ini_general_params *gp = &(p->ini1271.general_params);
-	return gp->dual_mode_select;
-}
-
-static int is_dual_mode_128x(struct wl12xx_ini *p)
-{
-	struct wl128x_ini_general_params *gp = &(p->ini128x.general_params);
-	return gp->dual_mode_select;
-}
-
-
-static struct wl12xx_parse_ops wl1271_parse_ops = {
-	.prs_general_prms       = parse_general_prms,
-	.prs_band2_prms         = parse_band2_prms,
-	.prs_band5_prms         = parse_band5_prms,
-	.prs_fem0_band2_prms    = parse_fem0_band2_prms,
-	.prs_fem1_band2_prms    = parse_fem1_band2_prms,
-	.prs_fem0_band5_prms    = parse_fem0_band5_prms,
-	.prs_fem1_band5_prms    = parse_fem1_band5_prms,
-	.is_dual_mode		= is_dual_mode,
-};
-
-static struct wl12xx_parse_ops wl128x_parse_ops = {
-	.prs_general_prms       = parse_general_prms_128x,
-	.prs_band2_prms         = parse_band2_prms_128x,
-	.prs_band5_prms         = parse_band5_prms_128x,
-	.prs_fem0_band2_prms    = parse_fem0_band2_prms_128x,
-	.prs_fem1_band2_prms    = parse_fem1_band2_prms_128x,
-	.prs_fem0_band5_prms    = parse_fem0_band5_prms_128x,
-	.prs_fem1_band5_prms    = parse_fem1_band5_prms_128x,
-	.is_dual_mode		= is_dual_mode_128x,
-};
-
-int ini_get_dual_mode(struct wl12xx_common *cmn)
-{
-	return cmn->parse_ops->is_dual_mode(&cmn->ini);
-}
-
-int nvs_get_arch(int file_size, struct wl12xx_common *cmn)
-{
-	enum wl12xx_arch arch = UNKNOWN_ARCH;
-
-	switch (file_size) {
-		case WL127X_NVS_FILE_SZ:
-			arch = WL1271_ARCH;
-			cmn->parse_ops = &wl1271_parse_ops;
-			break;
-		case WL128X_NVS_FILE_SZ:
-			arch = WL128X_ARCH;
-			cmn->parse_ops = &wl128x_parse_ops;
-			break;
-	}
-
-	if (cmn->arch != UNKNOWN_ARCH && cmn->arch != arch) {
-		cmn->parse_ops = NULL;
-		return 1;
-	}
-
-	cmn->arch = arch;
-
-	return 0;
-}
-
-static int ini_get_arch(FILE *f, struct wl12xx_common *cmn)
-{
-	char buf[1024], *pos;
-	int line = 0;
-	enum wl12xx_arch arch = UNKNOWN_ARCH;
-
-	while (ini_get_line(buf, sizeof(buf), f, &line, &pos)) {
-		if (strncmp("TCXO_Clk", pos, 8) == 0) {
-			arch = WL128X_ARCH;
-			break;
-		}
-	}
-
-	if (arch == UNKNOWN_ARCH)
-		arch = WL1271_ARCH;
-
-	if (cmn->arch != UNKNOWN_ARCH && cmn->arch != arch)
-		return 1;
-
-	cmn->arch = arch;
-
-	if (cmn->arch == WL1271_ARCH)
-		cmn->parse_ops = &wl1271_parse_ops;
-	else
-		cmn->parse_ops = &wl128x_parse_ops;
-
-	fseek(f, 0L, SEEK_SET);
-
-	return 0;
-}
-
-int read_ini(const char *filename, struct wl12xx_common *cmn)
-{
-	FILE *f;
-	char buf[1024], *pos;
-	int ret = 0, line = 0;
-
-	cmn->auto_fem = 0;
-	cmn->fem0_bands = 0;
-	cmn->fem1_bands = 0;
-
-	f = fopen(filename, "r");
-	if (f == NULL) {
-		fprintf(stderr, "Unable to open file %s (%s)\n",
-			filename, strerror(errno));
-		return 1;
-	}
-
-	/* check if it 127x or 128x */
-	if (ini_get_arch(f, cmn)) {
-		fprintf(stderr, "Unable to define wireless architecture\n");
-		ret = 1;
-		goto out;
-	}
-
-	/* start parsing */
-	while (ini_get_line(buf, sizeof(buf), f, &line, &pos)) {
-		ret = ini_parse_line(pos, cmn);
-		if (ret) break;
-	}
-
-out:
-	fclose(f);
-#if 0
-	ini_dump(ini);
-#endif
-	return ret;
-}
diff --git a/mac80211/ti-utils/ini.h b/mac80211/ti-utils/ini.h
deleted file mode 100644
index 9017c90..0000000
--- a/mac80211/ti-utils/ini.h
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * This file is part of wl1271
- *
- * Copyright (C) 2010 Nokia Corporation
- *
- * Contact: Luciano Coelho <luciano.coelho@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __INI_H__
-#define __INI_H__
-
-#include <linux/limits.h>
-
-#define WL1271_INI_MAX_SMART_REFLEX_PARAM 16
-
-struct wl1271_ini_general_params {
-	unsigned char ref_clock;
-	unsigned char settling_time;
-	unsigned char clk_valid_on_wakeup;
-	unsigned char dc2dc_mode;
-	unsigned char dual_mode_select;
-	unsigned char tx_bip_fem_auto_detect;
-	unsigned char tx_bip_fem_manufacturer;
-	unsigned char general_settings;
-	unsigned char sr_state;
-	unsigned char srf1[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	unsigned char srf2[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	unsigned char srf3[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-} __attribute__((packed));
-
-#define WL128X_INI_MAX_SETTINGS_PARAM 4
-
-struct wl128x_ini_general_params {
-	unsigned char ref_clock;
-	unsigned char settling_time;
-	unsigned char clk_valid_on_wakeup;
-	unsigned char tcxo_ref_clock;
-	unsigned char tcxo_settling_time;
-	unsigned char tcxo_valid_on_wakeup;
-	unsigned char tcxo_ldo_voltage;
-	unsigned char xtal_itrim_val;
-	unsigned char platform_conf;
-	unsigned char dual_mode_select;
-	unsigned char tx_bip_fem_auto_detect;
-	unsigned char tx_bip_fem_manufacturer;
-	unsigned char general_settings[WL128X_INI_MAX_SETTINGS_PARAM];
-	unsigned char sr_state;
-	unsigned char srf1[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	unsigned char srf2[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-	unsigned char srf3[WL1271_INI_MAX_SMART_REFLEX_PARAM];
-} __attribute__((packed));
-
-#define WL1271_INI_RSSI_PROCESS_COMPENS_SIZE 15
-
-struct wl1271_ini_band_params_2 {
-	unsigned char rx_trace_insertion_loss;
-	unsigned char tx_trace_loss;
-	unsigned char
-		rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __attribute__((packed));
-
-#define WL1271_INI_CHANNEL_COUNT_2 14
-
-struct wl128x_ini_band_params_2 {
-	unsigned char rx_trace_insertion_loss;
-	unsigned char tx_trace_loss[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char
-		rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __attribute__((packed));
-
-#define WL1271_INI_RATE_GROUP_COUNT 6
-
-struct wl1271_ini_fem_params_2 {
-	__le16 tx_bip_ref_pd_voltage;
-	unsigned char tx_bip_ref_power;
-	unsigned char tx_bip_ref_offset;
-	unsigned char
-		tx_per_rate_pwr_limits_normal[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_degraded[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_extreme[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char tx_per_chan_pwr_limits_11b[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char tx_pd_vs_rate_offsets[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char tx_ibias[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char rx_fem_insertion_loss;
-	unsigned char degraded_low_to_normal_thr;
-	unsigned char normal_to_degraded_high_thr;
-} __attribute__((packed));
-
-#define WL128X_INI_RATE_GROUP_COUNT 7
-/* low and high temperatures*/
-#define WL128X_INI_PD_VS_TEMPERATURE_RANGES 2
-
-struct wl128x_ini_fem_params_2 {
-	__le16 tx_bip_ref_pd_voltage;
-	unsigned char tx_bip_ref_power;
-	unsigned char tx_bip_ref_offset;
-	unsigned char
-		tx_per_rate_pwr_limits_normal [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_degraded [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_extreme [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char tx_per_chan_pwr_limits_11b[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char tx_pd_vs_rate_offsets[WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char tx_ibias[WL128X_INI_RATE_GROUP_COUNT + 1];
-	unsigned char tx_pd_vs_chan_offsets[WL1271_INI_CHANNEL_COUNT_2];
-	unsigned char tx_pd_vs_temperature[WL128X_INI_PD_VS_TEMPERATURE_RANGES];
-	unsigned char rx_fem_insertion_loss;
-	unsigned char degraded_low_to_normal_thr;
-	unsigned char normal_to_degraded_high_thr;
-} __attribute__((packed));
-
-#define WL1271_INI_CHANNEL_COUNT_5 35
-#define WL1271_INI_SUB_BAND_COUNT_5 7
-
-struct wl1271_ini_band_params_5 {
-	unsigned char rx_trace_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_trace_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char
-		rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __attribute__((packed));
-
-struct wl128x_ini_band_params_5 {
-	unsigned char rx_trace_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_trace_loss[WL1271_INI_CHANNEL_COUNT_5];
-	unsigned char
-		rx_rssi_process_compens[WL1271_INI_RSSI_PROCESS_COMPENS_SIZE];
-} __attribute__((packed));
-
-struct wl1271_ini_fem_params_5 {
-	__le16 tx_bip_ref_pd_voltage[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_bip_ref_power[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_bip_ref_offset[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char
-		tx_per_rate_pwr_limits_normal[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_degraded[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_extreme[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_5];
-	unsigned char tx_pd_vs_rate_offsets[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char tx_ibias[WL1271_INI_RATE_GROUP_COUNT];
-	unsigned char rx_fem_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char degraded_low_to_normal_thr;
-	unsigned char normal_to_degraded_high_thr;
-} __attribute__((packed));
-
-struct wl128x_ini_fem_params_5 {
-	__le16 tx_bip_ref_pd_voltage[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_bip_ref_power[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char tx_bip_ref_offset[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char
-		tx_per_rate_pwr_limits_normal [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_degraded [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char
-		tx_per_rate_pwr_limits_extreme [WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char tx_per_chan_pwr_limits_ofdm[WL1271_INI_CHANNEL_COUNT_5];
-	unsigned char tx_pd_vs_rate_offsets[WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char tx_ibias[WL128X_INI_RATE_GROUP_COUNT];
-	unsigned char tx_pd_vs_chan_offsets[WL1271_INI_CHANNEL_COUNT_5];
-	unsigned char tx_pd_vs_temperature[WL1271_INI_SUB_BAND_COUNT_5 *
-		WL128X_INI_PD_VS_TEMPERATURE_RANGES];
-	unsigned char rx_fem_insertion_loss[WL1271_INI_SUB_BAND_COUNT_5];
-	unsigned char degraded_low_to_normal_thr;
-	unsigned char normal_to_degraded_high_thr;
-} __attribute__((packed));
-
-/* NVS data structure */
-#define WL1271_INI_NVS_SECTION_SIZE		     468
-#define WL1271_INI_FEM_MODULE_COUNT                  2
-
-#define WL1271_INI_LEGACY_NVS_FILE_SIZE              800
-
-struct wl1271_nvs_file {
-	/* NVS section */
-	unsigned char nvs[WL1271_INI_NVS_SECTION_SIZE];
-
-	/* INI section */
-	struct wl1271_ini_general_params general_params;
-	unsigned char padding1;
-	struct wl1271_ini_band_params_2 stat_radio_params_2;
-	unsigned char padding2;
-	struct {
-		struct wl1271_ini_fem_params_2 params;
-		unsigned char padding;
-	} dyn_radio_params_2[WL1271_INI_FEM_MODULE_COUNT];
-	struct wl1271_ini_band_params_5 stat_radio_params_5;
-	unsigned char padding3;
-	struct {
-		struct wl1271_ini_fem_params_5 params;
-		unsigned char padding;
-	} dyn_radio_params_5[WL1271_INI_FEM_MODULE_COUNT];
-} __attribute__((packed));
-
-struct wl128x_nvs_file {
-	/* NVS section */
-	unsigned char nvs[WL1271_INI_NVS_SECTION_SIZE];
-
-	/* INI section */
-	struct wl128x_ini_general_params general_params;
-	unsigned char fem_vendor_and_options;
-	struct wl128x_ini_band_params_2 stat_radio_params_2;
-	unsigned char padding2;
-	struct {
-		struct wl128x_ini_fem_params_2 params;
-		unsigned char padding;
-	} dyn_radio_params_2[WL1271_INI_FEM_MODULE_COUNT];
-	struct wl128x_ini_band_params_5 stat_radio_params_5;
-	unsigned char padding3;
-	struct {
-		struct wl128x_ini_fem_params_5 params;
-		unsigned char padding;
-	} dyn_radio_params_5[WL1271_INI_FEM_MODULE_COUNT];
-} __attribute__((packed));
-
-struct wl1271_ini {
-	struct wl1271_ini_general_params general_params;
-	unsigned char padding1;
-	struct wl1271_ini_band_params_2 stat_radio_params_2;
-	unsigned char padding2;
-	struct {
-		struct wl1271_ini_fem_params_2 params;
-		unsigned char padding;
-	} dyn_radio_params_2[WL1271_INI_FEM_MODULE_COUNT];
-	struct wl1271_ini_band_params_5 stat_radio_params_5;
-	unsigned char padding3;
-	struct {
-		struct wl1271_ini_fem_params_5 params;
-		unsigned char padding;
-	} dyn_radio_params_5[WL1271_INI_FEM_MODULE_COUNT];
-} __attribute__((packed));
-
-struct wl128x_ini {
-	struct wl128x_ini_general_params general_params;
-	unsigned char fem_vendor_and_options;
-	struct wl128x_ini_band_params_2 stat_radio_params_2;
-	unsigned char padding2;
-	struct {
-		struct wl128x_ini_fem_params_2 params;
-		unsigned char padding;
-	} dyn_radio_params_2[WL1271_INI_FEM_MODULE_COUNT];
-	struct wl128x_ini_band_params_5 stat_radio_params_5;
-	unsigned char padding3;
-	struct {
-		struct wl128x_ini_fem_params_5 params;
-		unsigned char padding;
-	} dyn_radio_params_5[WL1271_INI_FEM_MODULE_COUNT];
-} __attribute__((packed));
-
-enum wl1271_ini_section {
-	UKNOWN_SECTION,
-	GENERAL_PRMS,
-	FEM_PRMS,
-	BAND2_PRMS,
-	BAND5_PRMS,
-	FEM0_BAND2_PRMS,
-	FEM1_BAND2_PRMS,
-	FEM0_BAND5_PRMS,
-	FEM1_BAND5_PRMS
-};
-
-enum wl12xx_arch {
-	UNKNOWN_ARCH,
-	WL1271_ARCH = 0x0403,
-	WL128X_ARCH = 0x0503
-};
-
-struct wl12xx_ini {
-	union {
-		struct wl1271_ini ini1271;
-		struct wl128x_ini ini128x;
-	};
-};
-
-#define DUAL_MODE_UNSET		0xff
-
-struct wl12xx_common {
-	enum wl12xx_arch arch;
-	unsigned char auto_fem;
-	unsigned int fem0_bands;
-	unsigned int fem1_bands;
-	struct wl12xx_parse_ops *parse_ops;
-	struct wl12xx_nvs_ops   *nvs_ops;
-	struct wl12xx_ini ini;
-	char *nvs_name;
-};
-
-struct wl12xx_parse_ops {
-	int (*prs_general_prms)(char *l, struct wl12xx_common *cmn,
-		struct wl12xx_ini *p);
-	/* int (*prs_fem_prms)(char *l, void *gp); */
-	int (*prs_band2_prms)(char *l, struct wl12xx_ini *p);
-	int (*prs_band5_prms)(char *l, struct wl12xx_ini *p);
-	int (*prs_fem0_band2_prms)(char *l, struct wl12xx_ini *p);
-	int (*prs_fem1_band2_prms)(char *l, struct wl12xx_ini *p);
-	int (*prs_fem0_band5_prms)(char *l, struct wl12xx_ini *p);
-	int (*prs_fem1_band5_prms)(char *l, struct wl12xx_ini *p);
-	int (*is_dual_mode)(struct wl12xx_ini *p);
-};
-
-struct wl12xx_nvs_ops {
-	int (*nvs_fill_radio_prms)(int fd, struct wl12xx_ini *p, char *buf);
-	int (*nvs_set_autofem)(int fd, char *buf, unsigned char val);
-	int (*nvs_set_fem_manuf)(int fd, char *buf, unsigned char val);
-};
-
-int nvs_get_arch(int file_size, struct wl12xx_common *cmn);
-
-int read_ini(const char *filename, struct wl12xx_common *cmn);
-
-int ini_get_dual_mode(struct wl12xx_common *cmn);
-#endif
diff --git a/mac80211/ti-utils/ini_files/127x/RFMD_D_E5.ini b/mac80211/ti-utils/ini_files/127x/RFMD_D_E5.ini
deleted file mode 100755
index 6fbca03..0000000
--- a/mac80211/ti-utils/ini_files/127x/RFMD_D_E5.ini
+++ /dev/null
@@ -1,77 +0,0 @@
-# INI Generator version 1.42; Aligned to TS version 6.1.2.0.63
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 01 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_5G  = EE F4 F8 FE 05 EA F3 FA 01 06 E5 F1 FA 02 07  # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM0_TXBiPReferencePDvoltage_2_4G = 0163 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM0_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM0_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM0_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Degraded = 1D 1F 22 26 27 27 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM0_TxIbiasTable_2_4G  = 22 22 24 31 31 31 # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM0_RxFemInsertionLoss_2_4G  = 10 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM0_TXBiPReferencePDvoltage_5G  = 0154 0154 0154 012C 012C 013B 013B # Length: 7; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM0_TxBiPReferencePower_5G = 80 80 80 80 80 80 80 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM0_TxBiPOffsetdB_5G = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM0_TxPerRatePowerLimits_5G_Normal  = 1C 1E 21 23 25 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_5G_Degraded  = 18 1E 21 23 25 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_5G_Extreme = 16 1C 1E 20 20 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_DegradedLowToNormalThr_5G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_NormalToDegradedHighThr_5G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerChannelPowerLimits_5G_OFDM  = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 35; Unit: 1/2dB; Format: Signed; Source: Customer;
-FEM0_TxPDVsRateOffsets_5G  = 01 02 02 02 02 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM0_TxIbiasTable_5G  = 27 27 29 34 34 34 # Length: 6; Unit: Codeword; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM
-FEM0_RxFemInsertionLoss_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
diff --git a/mac80211/ti-utils/ini_files/127x/RFMD_S_3.5.ini b/mac80211/ti-utils/ini_files/127x/RFMD_S_3.5.ini
deleted file mode 100755
index 4587369..0000000
--- a/mac80211/ti-utils/ini_files/127x/RFMD_S_3.5.ini
+++ /dev/null
@@ -1,63 +0,0 @@
-# INI Generator version 1.4; Aligned to TS version 6.1.2.0.27
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 00 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM0_TXBiPReferencePDvoltage_2_4G = 0136 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM0_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM0_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM0_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Degraded = 19 1F 22 25 25 27 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM0_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM0_TxIbiasTable_2_4G  = 31 31 36 36 3b 3b # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM0_RxFemInsertionLoss_2_4G  = 0E # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-
diff --git a/mac80211/ti-utils/ini_files/127x/TQS_D_1.0.ini b/mac80211/ti-utils/ini_files/127x/TQS_D_1.0.ini
deleted file mode 100755
index a908c6d..0000000
--- a/mac80211/ti-utils/ini_files/127x/TQS_D_1.0.ini
+++ /dev/null
@@ -1,78 +0,0 @@
-# INI Generator version 1.4; Aligned to TS version 6.1.2.0.27
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 01 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_5G  = EE F4 F8 FE 05 EA F3 FA 01 06 E5 F1 FA 02 07  # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_2_4G = 01E0 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 28 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1A 1F 22 24 26 28 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_2_4G  = 15 15 15 19 19 15 # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM1_RxFemInsertionLoss_2_4G  = 10 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_5G  = 0173 0188 0187 018B 018A 0186 018C # Length: 7; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_5G = 80 80 80 80 80 80 80 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_5G = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_5G_Normal  = 1C 1F 22 24 24 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Degraded  = 18 1F 22 22 22 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Extreme = 16 1C 1E 20 20 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_5G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_5G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_5G_OFDM  = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 35; Unit: 1/2dB; Format: Signed; Source: Customer;
-FEM1_TxPDVsRateOffsets_5G  = 01 02 02 02 02 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_5G  = 10 10 10 10 10 10 # Length: 6; Unit: Codeword; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM
-FEM1_RxFemInsertionLoss_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-
diff --git a/mac80211/ti-utils/ini_files/127x/TQS_D_1.7.ini b/mac80211/ti-utils/ini_files/127x/TQS_D_1.7.ini
deleted file mode 100755
index ea986f9..0000000
--- a/mac80211/ti-utils/ini_files/127x/TQS_D_1.7.ini
+++ /dev/null
@@ -1,78 +0,0 @@
-# INI Generator version 1.4; Aligned to TS version 6.1.2.0.27
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 01 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_5G  = EE F4 F8 FE 05 EA F3 FA 01 06 E5 F1 FA 02 07  # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_2_4G = 01D9 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1D 1F 22 26 27 27 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_2_4G  = 15 15 15 19 19 15 # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM1_RxFemInsertionLoss_2_4G  = 10 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_5G  = 019A 01AE 01C2 01CC 01DB 01DB 01D1 # Length: 7; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_5G = 80 80 80 80 80 80 80 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_5G = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_5G_Normal  = 1C 1E 21 23 25 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Degraded  = 18 1E 21 23 25 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Extreme = 16 1C 1E 20 20 50 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_5G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_5G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_5G_OFDM  = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 35; Unit: 1/2dB; Format: Signed; Source: Customer;
-FEM1_TxPDVsRateOffsets_5G  = 01 02 02 02 02 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_5G  = 10 10 10 10 10 10 # Length: 6; Unit: Codeword; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM
-FEM1_RxFemInsertionLoss_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-
diff --git a/mac80211/ti-utils/ini_files/127x/TQS_S_2.5.ini b/mac80211/ti-utils/ini_files/127x/TQS_S_2.5.ini
deleted file mode 100755
index f1813cf..0000000
--- a/mac80211/ti-utils/ini_files/127x/TQS_S_2.5.ini
+++ /dev/null
@@ -1,63 +0,0 @@
-# INI Generator version 1.4; Aligned to TS version 6.1.2.0.27
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 00 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_2_4G = 0177 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 28 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1A 1F 22 24 26 28 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_2_4G  = 11 11 15 11 15 0F # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM1_RxFemInsertionLoss_2_4G  = 0E # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-
diff --git a/mac80211/ti-utils/ini_files/127x/TQS_S_2.6.ini b/mac80211/ti-utils/ini_files/127x/TQS_S_2.6.ini
deleted file mode 100755
index d5b0877..0000000
--- a/mac80211/ti-utils/ini_files/127x/TQS_S_2.6.ini
+++ /dev/null
@@ -1,63 +0,0 @@
-# INI Generator version 1.4; Aligned to TS version 6.1.2.0.27
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0,1,2-0:19.2MHz,1:26MHz,2:38.4MHz[Default],3:52MHz,4:38.4MHz XTAL,5:26MHz XTAL, Bit 3-CLK_REQ type, 0=wired-OR, 1=push-pull, Bit 4-CLK_REQ polarity
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-DC2DCMode  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned, Source: Customer; Comment: Bit0 - DC2DC mode (0: btSPI is not used;1: btSPI used mux DC2DC to BT_FUNC2), Bit1- Level shifter support (0: No LS, 1: With LS)
-Single_Dual_Band_Solution  = 00 # Length: 1; Unit: Options (0: Single band, 1: Dual band); Format: Unsigned; Source: Customer; Comment: This parameter indicates if the solution is single band (2.4GHz only) or dual band (2.4GHz & 5GHz)
-Settings  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0-NBI(0:Off,1:On),Bit1-Telec ch14(0:Off,1:On),Bit2-FEM0-LB,Bit3-FEM0-HB,Bit4-FEM1-LB,Bit5-FEM1-HB-TX BiP load(0:Int.,1:Ext.),Bit6-LPD LB,Bit7-LPD HB
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 18 10 08 00 F7 EF E7 DF 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 22 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = a9 # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = c1 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = 8d # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TXTraceLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-RxRssiAndProcessCompensation_2_4G  = EC F6 00 0C 18 F8 FC 00 08 10 F0 F8 00 0A 14 # Length: 15; Unit: 1/8dB; Format: Signed; Source: TI; Comment: The RSSI corner points are determined during RSSI temperature and process characterization
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TXBiPReferencePDvoltage_2_4G = 0177 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage .
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1A 1F 22 25 25 27 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 # Length: 6; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temp range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 # Length: 6; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxIbiasTable_2_4G  = 15 15 15 11 15 15 # Length: 6; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b)
-FEM1_RxFemInsertionLoss_2_4G  = 0E # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL127x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-
diff --git a/mac80211/ti-utils/ini_files/128x/RFMD_S_3.5.ini b/mac80211/ti-utils/ini_files/128x/RFMD_S_3.5.ini
deleted file mode 100755
index f220b17..0000000
--- a/mac80211/ti-utils/ini_files/128x/RFMD_S_3.5.ini
+++ /dev/null
@@ -1,69 +0,0 @@
-# INI Generator version 0.5; Aligned to TS version 7.1.2.0.26
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz,  4: 38.4MHz XTAL, 5: 26MHz XTAL ,  5'bX0XXX : Bit 3 - CLK_REQ type,  0 = wired-OR [Default], 1= push-pull ,  5'b0XXXX : Bit 4 - CLK_REQ polarity, 0 = Normal [Default], 1=Inverted
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-TCXO_Clk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz, 4: 16.368Mhz, 5: 32.736 Mhz 
-TCXO_SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid TCXO clock on the device inputs
-TCXO_ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the TCXO clock is valid on wakeup 
-TCXO_LDO_Voltage = 00 # Length: 1; Unit: Options (0:2.5v, 1:2.55v, 2:2.6v); Format: Unsigned; Source: Customer; Comment: TCXO LDO Voltage 
-Platform_configuration = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer ; Comment: Bit 0: Levelshifter support (0: No LS, 1: With LS), Bit 1,2:Configure IO's [SDIO/wspi] (00- 8mA, 01- 4mA (default), 10- 6mA, 11 - 2mA), Bit 3:Eeprom (0-No Eeprom), Bit 4: SDIO IB Enable sync, Bit 5: SDIO IB Enable async, Bit 6: SDIO IB Enable BlockMode, Bit 7: SDIO High-Speed support
-Single_Dual_Band_Solution  = 00 # Length: 1; Unit: Options (0: 2.5v, 1: 2.55v, 2: 2.6v); Format: Unsigned; Source: Customer; Comment: This field notifies the FW whether the solution is a single-band or dual-band
-Settings  = 00 00 00 00 # Length: 4; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0: NBI (0: Off, 1: On), Bit1: Telec channel 14 (0: Off, 1: On), Bit2: FEM0-LB, Bit3: FEM0-HB, Bit4: FEM1-LB, Bit5: FEM1-HB - TX BiP load (0: Internal, 1: External), Bit6: LPD Low band, Bit7: LPD High band 
-XTALItrimVal = 04 # Length: 1; Unit: Current trimming for XTAL; Format: Unsigned; Source: TI; Comment: Current trimming for XTAL
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 19 10 00 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 11 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = AA # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = B6 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = F0 # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FemVendorAndOptions  = 00 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0..1 - 0: RFMD, 1: TQS, 2: SKWS,  Bit 4..7 [Version control] -  0: TQS-S1.0, 1: TQS-S2.0, 2: TQS-S2.5, 3: TQS-D1.0, 4: TQS-D1.5, 5: RFMD-S1.5, 6: RFMD-S2.9, 7: RFMD-S3.0, 8: RFMD-D1.5, 9: RFMD-S2.9.5, 10: RFMD-D3.0.1, 11: TQS-S2.6, 12: TQS-D1.7
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM0_TxBiPReferencePDvoltage_2_4G = 0136 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM0_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM0_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM0_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Degraded = 19 1F 22 25 25 27 23 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM0_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 22 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM0_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM0_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM0_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM0_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM0_TxPDVsChannelOffsets_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM0_TxPDVsTemperature_2_4G = 00 00 # Length: 2; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM0_TxIbiasTable_2_4G  = 33 33 38 38 3d 3d 3d 3d # Length: 8; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b, MCS0, 11bCh14)
-FEM0_RxFemInsertionLoss_2_4G  = 0E # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-
diff --git a/mac80211/ti-utils/ini_files/128x/TQS_D_1.0.ini b/mac80211/ti-utils/ini_files/128x/TQS_D_1.0.ini
deleted file mode 100755
index 3db403e..0000000
--- a/mac80211/ti-utils/ini_files/128x/TQS_D_1.0.ini
+++ /dev/null
@@ -1,85 +0,0 @@
-# INI Generator version 0.5; Aligned to TS version 7.1.2.0.26
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz,  4: 38.4MHz XTAL, 5: 26MHz XTAL ,  5'bX0XXX : Bit 3 - CLK_REQ type,  0 = wired-OR [Default], 1= push-pull ,  5'b0XXXX : Bit 4 - CLK_REQ polarity, 0 = Normal [Default], 1=Inverted
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-TCXO_Clk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz, 4: 16.368Mhz, 5: 32.736 Mhz 
-TCXO_SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid TCXO clock on the device inputs
-TCXO_ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the TCXO clock is valid on wakeup 
-TCXO_LDO_Voltage = 00 # Length: 1; Unit: Options (0:2.5v, 1:2.55v, 2:2.6v); Format: Unsigned; Source: Customer; Comment: TCXO LDO Voltage 
-Platform_configuration = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer ; Comment: Bit 0: Levelshifter support (0: No LS, 1: With LS), Bit 1,2:Configure IO's [SDIO/wspi] (00- 8mA, 01- 4mA (default), 10- 6mA, 11 - 2mA), Bit 3:Eeprom (0-No Eeprom), Bit 4: SDIO IB Enable sync, Bit 5: SDIO IB Enable async, Bit 6: SDIO IB Enable BlockMode, Bit 7: SDIO High-Speed support
-Single_Dual_Band_Solution  = 01 # Length: 1; Unit: Options (0: 2.5v, 1: 2.55v, 2: 2.6v); Format: Unsigned; Source: Customer; Comment: This field notifies the FW whether the solution is a single-band or dual-band
-Settings  = 00 00 00 00 # Length: 4; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0: NBI (0: Off, 1: On), Bit1: Telec channel 14 (0: Off, 1: On), Bit2: FEM0-LB, Bit3: FEM0-HB, Bit4: FEM1-LB, Bit5: FEM1-HB - TX BiP load (0: Internal, 1: External), Bit6: LPD Low band, Bit7: LPD High band 
-XTALItrimVal = 04 # Length: 1; Unit: Current trimming for XTAL; Format: Unsigned; Source: TI; Comment: Current trimming for XTAL
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 19 10 01 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 11 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = AA # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = B6 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = F0 # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_5G  = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 35; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FemVendorAndOptions  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0..1 - 0: RFMD, 1: TQS, 2: SKWS,  Bit 4..7 [Version control] -  0: TQS-S1.0, 1: TQS-S2.0, 2: TQS-S2.5, 3: TQS-D1.0, 4: TQS-D1.5, 5: RFMD-S1.5, 6: RFMD-S2.9, 7: RFMD-S3.0, 8: RFMD-D1.5, 9: RFMD-S2.9.5, 10: RFMD-D3.0.1, 11: TQS-S2.6, 12: TQS-D1.7
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TxBiPReferencePDvoltage_2_4G = 01A7 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1D 1F 22 26 27 27 24 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 22 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxPDVsChannelOffsets_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM1_TxPDVsTemperature_2_4G = 00 00 # Length: 2; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM1_TxIbiasTable_2_4G  = 15 15 15 19 19 15 19 15 # Length: 8; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b, MCS0, 11bCh14)
-FEM1_RxFemInsertionLoss_2_4G  = 10 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TxBiPReferencePDvoltage_5G  = 0173 0188 0187 018B 018A 0186 018C # Length: 7; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_5G = 80 80 80 80 80 80 80 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM1_TxBiPOffsetdB_5G = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_5G_Normal  = 1C 1E 21 23 25 50 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Degraded  = 18 1E 21 23 25 50 24 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Extreme = 16 1C 1E 20 20 50 1E # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_5G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_5G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_5G_OFDM  = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 35; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_5G  = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxPDVsChannelOffsets_5G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 35; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM1_TxPDVsTemperature_5G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM1_TxIbiasTable_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: Codeword; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM
-FEM1_RxFemInsertionLoss_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-
diff --git a/mac80211/ti-utils/ini_files/128x/TQS_D_1.7.ini b/mac80211/ti-utils/ini_files/128x/TQS_D_1.7.ini
deleted file mode 100755
index fb5903c..0000000
--- a/mac80211/ti-utils/ini_files/128x/TQS_D_1.7.ini
+++ /dev/null
@@ -1,85 +0,0 @@
-# INI Generator version 0.5; Aligned to TS version 7.1.2.0.26
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz,  4: 38.4MHz XTAL, 5: 26MHz XTAL ,  5'bX0XXX : Bit 3 - CLK_REQ type,  0 = wired-OR [Default], 1= push-pull ,  5'b0XXXX : Bit 4 - CLK_REQ polarity, 0 = Normal [Default], 1=Inverted
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-TCXO_Clk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz, 4: 16.368Mhz, 5: 32.736 Mhz 
-TCXO_SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid TCXO clock on the device inputs
-TCXO_ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the TCXO clock is valid on wakeup 
-TCXO_LDO_Voltage = 00 # Length: 1; Unit: Options (0:2.5v, 1:2.55v, 2:2.6v); Format: Unsigned; Source: Customer; Comment: TCXO LDO Voltage 
-Platform_configuration = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer ; Comment: Bit 0: Levelshifter support (0: No LS, 1: With LS), Bit 1,2:Configure IO's [SDIO/wspi] (00- 8mA, 01- 4mA (default), 10- 6mA, 11 - 2mA), Bit 3:Eeprom (0-No Eeprom), Bit 4: SDIO IB Enable sync, Bit 5: SDIO IB Enable async, Bit 6: SDIO IB Enable BlockMode, Bit 7: SDIO High-Speed support
-Single_Dual_Band_Solution  = 01 # Length: 1; Unit: Options (0: 2.5v, 1: 2.55v, 2: 2.6v); Format: Unsigned; Source: Customer; Comment: This field notifies the FW whether the solution is a single-band or dual-band
-Settings  = 00 00 00 00 # Length: 4; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0: NBI (0: Off, 1: On), Bit1: Telec channel 14 (0: Off, 1: On), Bit2: FEM0-LB, Bit3: FEM0-HB, Bit4: FEM1-LB, Bit5: FEM1-HB - TX BiP load (0: Internal, 1: External), Bit6: LPD Low band, Bit7: LPD High band 
-XTALItrimVal = 04 # Length: 1; Unit: Current trimming for XTAL; Format: Unsigned; Source: TI; Comment: Current trimming for XTAL
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 19 10 01 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 11 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = AA # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = B6 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = F0 # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_5G  = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_5G  = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 35; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FemVendorAndOptions  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0..1 - 0: RFMD, 1: TQS, 2: SKWS,  Bit 4..7 [Version control] -  0: TQS-S1.0, 1: TQS-S2.0, 2: TQS-S2.5, 3: TQS-D1.0, 4: TQS-D1.5, 5: RFMD-S1.5, 6: RFMD-S2.9, 7: RFMD-S3.0, 8: RFMD-D1.5, 9: RFMD-S2.9.5, 10: RFMD-D3.0.1, 11: TQS-S2.6, 12: TQS-D1.7
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TxBiPReferencePDvoltage_2_4G = 01D9 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1D 1F 22 26 27 27 24 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 22 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxPDVsChannelOffsets_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM1_TxPDVsTemperature_2_4G = 00 00 # Length: 2; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM1_TxIbiasTable_2_4G  = 17 17 17 1a 16 17 1a 17 # Length: 8; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b, MCS0, 11bCh14)
-FEM1_RxFemInsertionLoss_2_4G  = 10 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TxBiPReferencePDvoltage_5G  = 019A 01AE 01C2 01CC 01DB 01DB 01D1 # Length: 7; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_5G = 80 80 80 80 80 80 80 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM1_TxBiPOffsetdB_5G = 00 00 00 00 00 00 00 # Length: 7; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_5G_Normal  = 1C 1E 21 23 25 50 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Degraded  = 18 1E 21 23 25 50 24 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_5G_Extreme = 16 1C 1E 20 20 50 1E # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_5G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_5G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_5G_OFDM  = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 35; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_5G  = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxPDVsChannelOffsets_5G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 35; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM1_TxPDVsTemperature_5G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM1_TxIbiasTable_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: Codeword; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM
-FEM1_RxFemInsertionLoss_5G  = 10 10 10 10 10 10 10 # Length: 7; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-
diff --git a/mac80211/ti-utils/ini_files/128x/TQS_S_2.6.ini b/mac80211/ti-utils/ini_files/128x/TQS_S_2.6.ini
deleted file mode 100755
index a3d0f24..0000000
--- a/mac80211/ti-utils/ini_files/128x/TQS_S_2.6.ini
+++ /dev/null
@@ -1,69 +0,0 @@
-# INI Generator version 0.5; Aligned to TS version 7.1.2.0.26
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1:   Non FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.1: General parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-TXBiPFEMAutoDetect  = 00 # Length: 1; Unit: Options (0: Manual Mode, 1: Automatic mode); Format: Unsigned; Source: Customer; Comment: This parameter is used by the FW to decide if the front-end is determined automatically or manually
-TXBiPFEMManufacturer  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit1,0: used to determine which FEM vendor type is used on the platform (0: RFMD, 1: TQS, 2:SKW, 3:HP), Bit3,2: unused, Bit7-4:External/internal load (4-SKW SB, 5-SKW HB, 6-HP SB, 7-HP HB)
-RefClk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz,  4: 38.4MHz XTAL, 5: 26MHz XTAL ,  5'bX0XXX : Bit 3 - CLK_REQ type,  0 = wired-OR [Default], 1= push-pull ,  5'b0XXXX : Bit 4 - CLK_REQ polarity, 0 = Normal [Default], 1=Inverted
-SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid FREF clock on the device inputs
-ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the FREF clock is valid on wakeup
-TCXO_Clk  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: 5'bXX000 : Bit 0,1,2 - 0: 19.2MHz, 1: 26MHz, 2: 38.4MHz  [Default], 3: 52MHz, 4: 16.368Mhz, 5: 32.736 Mhz 
-TCXO_SettlingTime  = 05 # Length: 1; Unit: ms (0-15); Format: Unsigned; Source: Customer; Comment: The time from asserting CLK_REQ (low to high) to valid TCXO clock on the device inputs
-TCXO_ClockValidOnWakeup  = 00 # Length: 1; Unit: Options (0: Reference clock not valid, 1: Reference clock is valid and stable); Format: Unsigned; Source: Customer; Comment: This parameter indicates whether the TCXO clock is valid on wakeup 
-TCXO_LDO_Voltage = 00 # Length: 1; Unit: Options (0:2.5v, 1:2.55v, 2:2.6v); Format: Unsigned; Source: Customer; Comment: TCXO LDO Voltage 
-Platform_configuration = 02 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer ; Comment: Bit 0: Levelshifter support (0: No LS, 1: With LS), Bit 1,2:Configure IO's [SDIO/wspi] (00- 8mA, 01- 4mA (default), 10- 6mA, 11 - 2mA), Bit 3:Eeprom (0-No Eeprom), Bit 4: SDIO IB Enable sync, Bit 5: SDIO IB Enable async, Bit 6: SDIO IB Enable BlockMode, Bit 7: SDIO High-Speed support
-Single_Dual_Band_Solution  = 00 # Length: 1; Unit: Options (0: 2.5v, 1: 2.55v, 2: 2.6v); Format: Unsigned; Source: Customer; Comment: This field notifies the FW whether the solution is a single-band or dual-band
-Settings  = 00 00 00 00 # Length: 4; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit0: NBI (0: Off, 1: On), Bit1: Telec channel 14 (0: Off, 1: On), Bit2: FEM0-LB, Bit3: FEM0-HB, Bit4: FEM1-LB, Bit5: FEM1-HB - TX BiP load (0: Internal, 1: External), Bit6: LPD Low band, Bit7: LPD High band 
-XTALItrimVal = 04 # Length: 1; Unit: Current trimming for XTAL; Format: Unsigned; Source: TI; Comment: Current trimming for XTAL
-SRState = 00 # Length: 1; Unit: Options (0: Disabled, 1: Enabled); Format: Decimal; Source: TI; Comment: Smart Reflax (proprietary mechanism of TI that identify the silicon process specific params) state
-SRF1 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 0F 3F  # Length: 16; Unit: SRF1 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF2 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF2 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-SRF3 = 09 04 19 10 08 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SRF3 values; Format: Signed; Source: TI; Comment: The table holds the specific parameters for using the SmartReflex mechanism
-#SR_Debug_Table = 09 04 19 10 01 00 F7 EF E6 DE 00 00 00 00 00 00  # Length: 16; Unit: SR_Debug_Table values; Format: Signed; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P = 11 # Length: 1; Unit: SR_SEN_N_P values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_N_P_Gain = AA # Length: 1; Unit: SR_SEN_N_P_GAIN values; Format: Unsigned; Source: TI; Comment: SR Debug values  for TI internal use only
-#SR_SEN_NRN = B6 # Length: 1; Unit: SR_SEN_NRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#SR_SEN_PRN = F0 # Length: 1; Unit: SR_SEN_PRN values; Format: Unsigned; Source: TI ; Comment: SR Debug values  for TI internal use only
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2: Band-dependant parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-RxTraceInsertionLoss_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter indicates the printed circuit board (PCB) trace insertion loss
-TxTraceLoss_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Unsigned; Source: Customer; Comment: This parameter is used to align the output power to a different location on the board
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 1.2.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2:     FEM-dependant section
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1:   FEM parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FemVendorAndOptions  = 01 # Length: 1; Unit: Bit_Options; Format: Unsigned; Source: Customer; Comment: Bit 0..1 - 0: RFMD, 1: TQS, 2: SKWS,  Bit 4..7 [Version control] -  0: TQS-S1.0, 1: TQS-S2.0, 2: TQS-S2.5, 3: TQS-D1.0, 4: TQS-D1.5, 5: RFMD-S1.5, 6: RFMD-S2.9, 7: RFMD-S3.0, 8: RFMD-D1.5, 9: RFMD-S2.9.5, 10: RFMD-D3.0.1, 11: TQS-S2.6, 12: TQS-D1.7
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.1: 2.4G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-FEM1_TxBiPReferencePDvoltage_2_4G = 0177 # Length: 1; Unit: 1mV; Format: Unsigned; Source: TI; Comment: This parameter define the reference point of the FEM power detector
-FEM1_TxBiPReferencePower_2_4G  = 80 # Length: 1; Unit: 1/8dB; Format: Signed; Source: TI; Comment: Reference output power that produces given reference power detector output voltage . The TX BiP reference power is linked to the TX BiP reference PD voltage
-FEM1_TxBiPOffsetdB_2_4G = 00 # Length: 1; Unit: 1/8dB; Format: Signed; Source: Customer; Comment: This field is used to fine-tune the TX BiP by the customer
-FEM1_TxPerRatePowerLimits_2_4G_Normal = 1D 1F 22 26 27 29 25 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Degraded = 1A 1F 22 25 25 27 23 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerRatePowerLimits_2_4G_Extreme = 16 1D 1E 20 24 25 22 # Length: 7; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_DegradedLowToNormalThr_2_4G = 1E # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_NormalToDegradedHighThr_2_4G = 2D # Length: 1; Unit: 1/10 volts; Format: Unsigned; Source: TI; Comment: The limits are applied to the power control process according to the VBAT and temperature range in which the FEM is operating
-FEM1_TxPerChannelPowerLimits_2_4G_11b = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPerChannelPowerLimits_2_4G_OFDM = 50 50 50 50 50 50 50 50 50 50 50 50 50 50 # Length: 14; Unit: 1/2dB; Format: Signed; Source: Customer; Comment: The purpose of this table is to allow clipping of the maximum output power on certain channels
-FEM1_TxPDVsRateOffsets_2_4G = 01 02 02 02 02 00 02 # Length: 7; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each rate group
-FEM1_TxPDVsChannelOffsets_2_4G = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # Length: 14; Unit: 1/8dB; Format: Signed; Source: TI/Customer; Comment: This parameter is a power detector offset value used to correct the power detector curve for each channel
-FEM1_TxPDVsTemperature_2_4G = 00 00 # Length: 2; Unit: 1/8dB; Format: Signed; Source: TI; Comment: This parameter is a power detector offset value used to correct the power detector curve for each temperture
-FEM1_TxIbiasTable_2_4G  = 17 17 17 13 17 17 17 17 # Length: 8; Unit: Codeword ; Format: Unsigned; Source: TI; Comment: This parameter sets the bias current provided by the SoC to the PA in the FEM. Options (MCS7, 54/48, 36/24, 18/12, 9/6, 11b, MCS0, 11bCh14)
-FEM1_RxFemInsertionLoss_2_4G  = 0E # Length: 1; Unit: 1/8dB; Format: Unsigned; Source: TI; Comment: This parameter specifies the received insertion loss of the WL128x
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-# SECTION 2.1.2: 5G parameters
-#------------------------------------------------------------------------------------------------------------------------------------------------------------
-
diff --git a/mac80211/ti-utils/misc_cmds.c b/mac80211/ti-utils/misc_cmds.c
deleted file mode 100644
index a650eaf..0000000
--- a/mac80211/ti-utils/misc_cmds.c
+++ /dev/null
@@ -1,323 +0,0 @@
-#include <stdbool.h>
-#include <errno.h>
-#include <net/if.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include "calibrator.h"
-#include "plt.h"
-#include "ini.h"
-#include "nvs.h"
-
-SECTION(get);
-SECTION(set);
-
-static int get_nvs_mac(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	unsigned char mac_buff[12];
-	char *fname;
-	int fd;
-
-	argc -= 2;
-	argv += 2;
-
-	fname = get_opt_nvsinfile(argc, argv);
-	if (!fname)
-		return 1;
-
-	fd = open(fname, O_RDONLY);
-	if (fd < 0) {
-		perror("Error opening file for reading");
-		return 1;
-	}
-
-	read(fd, mac_buff, 12);
-
-	printf("MAC addr from NVS: %02x:%02x:%02x:%02x:%02x:%02x\n",
-		mac_buff[11], mac_buff[10], mac_buff[6],
-		mac_buff[5], mac_buff[4], mac_buff[3]);
-
-	close(fd);
-
-	return 0;
-}
-
-COMMAND(get, nvs_mac, "[<nvs filename>]", 0, 0, CIB_NONE, get_nvs_mac,
-	"Get MAC addr from NVS file (offline)");
-
-/*
- * Sets MAC address in NVS.
- * The default value for MAC is random where 1 byte zero.
- */
-static int set_nvs_mac(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	argc -= 2;
-	argv += 2;
-
-	if ((argc != 2) || (strlen(argv[1]) != 17))
-		return 1;
-
-	nvs_set_mac(argv[0], argv[1]);
-	return 0;
-}
-
-COMMAND(set, nvs_mac, "<nvs file> <mac addr>", 0, 0, CIB_NONE, set_nvs_mac,
-	"Set MAC addr in NVS file (offline), like XX:XX:XX:XX:XX:XX");
-
-static int set_ref_nvs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct wl12xx_common cmn = {
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL
-	};
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1 || argc > 2)
-		return 1;
-
-	if (read_ini(*argv, &cmn)) {
-		fprintf(stderr, "Fail to read ini file\n");
-		return 1;
-	}
-	argv++;
-	argc--;
-
-	cfg_nvs_ops(&cmn);
-
-	cmn.nvs_name = get_opt_nvsoutfile(argc, argv);
-	if (create_nvs_file(&cmn)) {
-		fprintf(stderr, "Fail to create reference NVS file\n");
-		return 1;
-	}
-
-	printf("%04X", cmn.arch);
-
-	return 0;
-}
-
-COMMAND(set, ref_nvs, "<ini file> [<nvs file>]", 0, 0, CIB_NONE, set_ref_nvs,
-	"Create reference NVS file");
-
-static int set_upd_nvs(struct nl80211_state *state, struct nl_cb *cb,
-	struct nl_msg *msg, int argc, char **argv)
-{
-	char *infname = NULL, *outfname = NULL;
-	struct wl12xx_common cmn = {
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL
-	};
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1)
-		return 1;
-
-	if (read_ini(*argv, &cmn)) {
-		fprintf(stderr, "Fail to read ini file\n");
-		return 1;
-	}
-	argc--;
-	argv++;
-
-	infname = get_opt_nvsinfile(argc, argv);
-	if (!infname)
-		return 1;
-
-	if (argc) {
-		argc--;
-		argv++;
-	}
-	outfname = get_opt_nvsoutfile(argc, argv);
-	if (!outfname)
-		return 1;
-
-	cfg_nvs_ops(&cmn);
-
-	if (update_nvs_file(infname, outfname, &cmn)) {
-		fprintf(stderr, "Fail to update NVS file\n");
-		return 1;
-	}
-#if 0
-	printf("\n\tThe updated NVS file (%s) is ready\n\tCopy it to %s and "
-		"reboot the system\n\n", NEW_NVS_NAME, CURRENT_NVS_NAME);
-#endif
-	return 0;
-}
-
-COMMAND(set, upd_nvs, "<ini file> [<nvs infile>] [<nvs_outfile>]", 0, 0, CIB_NONE, set_upd_nvs,
-	"Update values of a NVS from INI file");
-
-static int get_dump_nvs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	char *fname = NULL;
-
-	argc -= 2;
-	argv += 2;
-
-	fname = get_opt_nvsinfile(argc, argv);
-	if (!fname)
-		return 1;
-
-	if (dump_nvs_file(fname)) {
-		fprintf(stderr, "Fail to dump NVS file\n");
-		return 1;
-	}
-
-	return 0;
-}
-
-COMMAND(get, dump_nvs, "[<nvs file>]", 0, 0, CIB_NONE, get_dump_nvs,
-	"Dump NVS file, specified by option or current");
-
-static int get_info_nvs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	char *fname;
-
-	argc -= 2;
-	argv += 2;
-
-	fname = get_opt_nvsinfile(argc, argv);
-	if(!fname)
-		return 1;
-
-	if (info_nvs_file(fname)) {
-		fprintf(stderr, "Fail to read info from NVS file\n");
-		return 1;
-	}
-
-	return 0;
-}
-
-COMMAND(get, info_nvs, "[<nvs file>]", 0, 0, CIB_NONE, get_info_nvs,
-	"Print information from nvs file");
-
-static int set_autofem(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	char *fname = NULL;
-	int res;
-	unsigned int val;
-	struct wl12xx_common cmn = {
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL
-	};
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing argument\n");
-		return 2;
-	}
-
-	res = sscanf(argv[0], "%x", &val);
-	if (res != 1 || val > 1) {
-		fprintf(stderr, "Invalid argument\n");
-		return 1;
-	}
-	argv++;
-	argc--;
-
-	fname = get_opt_nvsinfile(argc, argv);
-
-	if (set_nvs_file_autofem(fname, val, &cmn)) {
-		fprintf(stderr, "Fail to set AutoFEM\n");
-		return 1;
-	}
-
-	return 0;
-}
-
-COMMAND(set, autofem, "<0-manual|1-auto> [<nvs file>]", 0, 0, CIB_NONE, set_autofem,
-	"Set Auto FEM detection, where 0 - manual, 1 - auto detection");
-
-static int set_fem_manuf(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	char *fname = NULL;
-	int res;
-	unsigned int val;
-	struct wl12xx_common cmn = {
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL
-	};
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing argument\n");
-		return 2;
-	}
-	res = sscanf(argv[0], "%x", &val);
-	if(res != 1 || val >= WL1271_INI_FEM_MODULE_COUNT) {
-		fprintf(stderr, "Invalid argument\n");
-		return 1;
-	}
-	argv++;
-	argc--;
-
-	fname = get_opt_nvsinfile(argc, argv);
-
-	if (set_nvs_file_fem_manuf(fname, val, &cmn)) {
-		fprintf(stderr, "Fail to set AutoFEM\n");
-		return 1;
-	}
-
-	return 0;
-}
-
-COMMAND(set, fem_manuf, "<0|1> [<nvs file>]", 0, 0, CIB_NONE, set_fem_manuf,
-	"Set FEM manufacturer");
-
-static int get_drv_info(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing argument (device name)\n");
-		return 2;
-	}
-
-	return do_get_drv_info(argv[0], NULL);
-}
-
-COMMAND(get, drv_info, "<device name>", 0, 0, CIB_NONE, get_drv_info,
-	"Get driver information: PG version");
-
-static int get_hw_version(struct nl80211_state *state, struct nl_cb *cb,
-			  struct nl_msg *msg, int argc, char **argv)
-{
-	int ret, chip_id = 0;
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing argument (device name)\n");
-		return 2;
-	}
-
-	ret = do_get_drv_info(argv[0], &chip_id);
-	if (!ret)
-		printf("%08X\n", chip_id);
-
-	return ret;
-}
-
-COMMAND(get, hw_version, "<device name>", 0, 0, CIB_NONE, get_hw_version,
-	"Get HW version (chip id)");
-
diff --git a/mac80211/ti-utils/nl80211.h b/mac80211/ti-utils/nl80211.h
deleted file mode 100644
index 1db3b7d..0000000
--- a/mac80211/ti-utils/nl80211.h
+++ /dev/null
@@ -1,1434 +0,0 @@
-#ifndef __LINUX_NL80211_H
-#define __LINUX_NL80211_H
-/*
- * 802.11 netlink interface public header
- *
- * Copyright 2006, 2007, 2008 Johannes Berg <johannes@sipsolutions.net>
- * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
- * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
- * Copyright 2008 Michael Buesch <mb@bu3sch.de>
- * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
- * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
- * Copyright 2008 Colin McCabe <colin@cozybit.com>
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- */
-
-#include <linux/types.h>
-
-/**
- * DOC: Station handling
- *
- * Stations are added per interface, but a special case exists with VLAN
- * interfaces. When a station is bound to an AP interface, it may be moved
- * into a VLAN identified by a VLAN interface index (%NL80211_ATTR_STA_VLAN).
- * The station is still assumed to belong to the AP interface it was added
- * to.
- *
- * TODO: need more info?
- */
-
-/**
- * enum nl80211_commands - supported nl80211 commands
- *
- * @NL80211_CMD_UNSPEC: unspecified command to catch errors
- *
- * @NL80211_CMD_GET_WIPHY: request information about a wiphy or dump request
- *   to get a list of all present wiphys.
- * @NL80211_CMD_SET_WIPHY: set wiphy parameters, needs %NL80211_ATTR_WIPHY or
- *   %NL80211_ATTR_IFINDEX; can be used to set %NL80211_ATTR_WIPHY_NAME,
- *   %NL80211_ATTR_WIPHY_TXQ_PARAMS, %NL80211_ATTR_WIPHY_FREQ,
- *   %NL80211_ATTR_WIPHY_CHANNEL_TYPE, %NL80211_ATTR_WIPHY_RETRY_SHORT,
- *   %NL80211_ATTR_WIPHY_RETRY_LONG, %NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
- *   and/or %NL80211_ATTR_WIPHY_RTS_THRESHOLD.
- * @NL80211_CMD_NEW_WIPHY: Newly created wiphy, response to get request
- *   or rename notification. Has attributes %NL80211_ATTR_WIPHY and
- *   %NL80211_ATTR_WIPHY_NAME.
- * @NL80211_CMD_DEL_WIPHY: Wiphy deleted. Has attributes
- *   %NL80211_ATTR_WIPHY and %NL80211_ATTR_WIPHY_NAME.
- *
- * @NL80211_CMD_GET_INTERFACE: Request an interface's configuration;
- *   either a dump request on a %NL80211_ATTR_WIPHY or a specific get
- *   on an %NL80211_ATTR_IFINDEX is supported.
- * @NL80211_CMD_SET_INTERFACE: Set type of a virtual interface, requires
- *   %NL80211_ATTR_IFINDEX and %NL80211_ATTR_IFTYPE.
- * @NL80211_CMD_NEW_INTERFACE: Newly created virtual interface or response
- *   to %NL80211_CMD_GET_INTERFACE. Has %NL80211_ATTR_IFINDEX,
- *   %NL80211_ATTR_WIPHY and %NL80211_ATTR_IFTYPE attributes. Can also
- *   be sent from userspace to request creation of a new virtual interface,
- *   then requires attributes %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFTYPE and
- *   %NL80211_ATTR_IFNAME.
- * @NL80211_CMD_DEL_INTERFACE: Virtual interface was deleted, has attributes
- *   %NL80211_ATTR_IFINDEX and %NL80211_ATTR_WIPHY. Can also be sent from
- *   userspace to request deletion of a virtual interface, then requires
- *   attribute %NL80211_ATTR_IFINDEX.
- *
- * @NL80211_CMD_GET_KEY: Get sequence counter information for a key specified
- *   by %NL80211_ATTR_KEY_IDX and/or %NL80211_ATTR_MAC.
- * @NL80211_CMD_SET_KEY: Set key attributes %NL80211_ATTR_KEY_DEFAULT,
- *   %NL80211_ATTR_KEY_DEFAULT_MGMT, or %NL80211_ATTR_KEY_THRESHOLD.
- * @NL80211_CMD_NEW_KEY: add a key with given %NL80211_ATTR_KEY_DATA,
- *   %NL80211_ATTR_KEY_IDX, %NL80211_ATTR_MAC, %NL80211_ATTR_KEY_CIPHER,
- *   and %NL80211_ATTR_KEY_SEQ attributes.
- * @NL80211_CMD_DEL_KEY: delete a key identified by %NL80211_ATTR_KEY_IDX
- *   or %NL80211_ATTR_MAC.
- *
- * @NL80211_CMD_GET_BEACON: retrieve beacon information (returned in a
- *   %NL80222_CMD_NEW_BEACON message)
- * @NL80211_CMD_SET_BEACON: set the beacon on an access point interface
- *   using the %NL80211_ATTR_BEACON_INTERVAL, %NL80211_ATTR_DTIM_PERIOD,
- *   %NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL attributes.
- * @NL80211_CMD_NEW_BEACON: add a new beacon to an access point interface,
- *   parameters are like for %NL80211_CMD_SET_BEACON.
- * @NL80211_CMD_DEL_BEACON: remove the beacon, stop sending it
- *
- * @NL80211_CMD_GET_STATION: Get station attributes for station identified by
- *   %NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_SET_STATION: Set station attributes for station identified by
- *   %NL80211_ATTR_MAC on the interface identified by %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_NEW_STATION: Add a station with given attributes to the
- *   the interface identified by %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_DEL_STATION: Remove a station identified by %NL80211_ATTR_MAC
- *   or, if no MAC address given, all stations, on the interface identified
- *   by %NL80211_ATTR_IFINDEX.
- *
- * @NL80211_CMD_GET_MPATH: Get mesh path attributes for mesh path to
- *   destination %NL80211_ATTR_MAC on the interface identified by
- *   %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
- *   destination %NL80211_ATTR_MAC on the interface identified by
- *   %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
- *   the interface identified by %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
- *   or, if no MAC address given, all mesh paths, on the interface identified
- *   by %NL80211_ATTR_IFINDEX.
- * @NL80211_CMD_SET_BSS: Set BSS attributes for BSS identified by
- *   %NL80211_ATTR_IFINDEX.
- *
- * @NL80211_CMD_GET_REG: ask the wireless core to send us its currently set
- *   regulatory domain.
- * @NL80211_CMD_SET_REG: Set current regulatory domain. CRDA sends this command
- *   after being queried by the kernel. CRDA replies by sending a regulatory
- *   domain structure which consists of %NL80211_ATTR_REG_ALPHA set to our
- *   current alpha2 if it found a match. It also provides
- *   NL80211_ATTR_REG_RULE_FLAGS, and a set of regulatory rules. Each
- *   regulatory rule is a nested set of attributes  given by
- *   %NL80211_ATTR_REG_RULE_FREQ_[START|END] and
- *   %NL80211_ATTR_FREQ_RANGE_MAX_BW with an attached power rule given by
- *   %NL80211_ATTR_REG_RULE_POWER_MAX_ANT_GAIN and
- *   %NL80211_ATTR_REG_RULE_POWER_MAX_EIRP.
- * @NL80211_CMD_REQ_SET_REG: ask the wireless core to set the regulatory domain
- *   to the the specified ISO/IEC 3166-1 alpha2 country code. The core will
- *   store this as a valid request and then query userspace for it.
- *
- * @NL80211_CMD_GET_MESH_PARAMS: Get mesh networking properties for the
- *   interface identified by %NL80211_ATTR_IFINDEX
- *
- * @NL80211_CMD_SET_MESH_PARAMS: Set mesh networking properties for the
- *      interface identified by %NL80211_ATTR_IFINDEX
- *
- * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
- *   interface is identified with %NL80211_ATTR_IFINDEX and the management
- *   frame subtype with %NL80211_ATTR_MGMT_SUBTYPE. The extra IE data to be
- *   added to the end of the specified management frame is specified with
- *   %NL80211_ATTR_IE. If the command succeeds, the requested data will be
- *   added to all specified management frames generated by
- *   kernel/firmware/driver.
- *   Note: This command has been removed and it is only reserved at this
- *   point to avoid re-using existing command number. The functionality this
- *   command was planned for has been provided with cleaner design with the
- *   option to specify additional IEs in NL80211_CMD_TRIGGER_SCAN,
- *   NL80211_CMD_AUTHENTICATE, NL80211_CMD_ASSOCIATE,
- *   NL80211_CMD_DEAUTHENTICATE, and NL80211_CMD_DISASSOCIATE.
- *
- * @NL80211_CMD_GET_SCAN: get scan results
- * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
- * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
- *   NL80211_CMD_GET_SCAN and on the "scan" multicast group)
- * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
- *   partial scan results may be available
- *
- * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
- *      or noise level
- * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
- *   NL80211_CMD_GET_SURVEY and on the "scan" multicast group)
- *
- * @NL80211_CMD_REG_CHANGE: indicates to userspace the regulatory domain
- *   has been changed and provides details of the request information
- *   that caused the change such as who initiated the regulatory request
- *   (%NL80211_ATTR_REG_INITIATOR), the wiphy_idx
- *   (%NL80211_ATTR_REG_ALPHA2) on which the request was made from if
- *   the initiator was %NL80211_REGDOM_SET_BY_COUNTRY_IE or
- *   %NL80211_REGDOM_SET_BY_DRIVER, the type of regulatory domain
- *   set (%NL80211_ATTR_REG_TYPE), if the type of regulatory domain is
- *   %NL80211_REG_TYPE_COUNTRY the alpha2 to which we have moved on
- *   to (%NL80211_ATTR_REG_ALPHA2).
- * @NL80211_CMD_REG_BEACON_HINT: indicates to userspace that an AP beacon
- *   has been found while world roaming thus enabling active scan or
- *   any mode of operation that initiates TX (beacons) on a channel
- *   where we would not have been able to do either before. As an example
- *   if you are world roaming (regulatory domain set to world or if your
- *   driver is using a custom world roaming regulatory domain) and while
- *   doing a passive scan on the 5 GHz band you find an AP there (if not
- *   on a DFS channel) you will now be able to actively scan for that AP
- *   or use AP mode on your card on that same channel. Note that this will
- *   never be used for channels 1-11 on the 2 GHz band as they are always
- *   enabled world wide. This beacon hint is only sent if your device had
- *   either disabled active scanning or beaconing on a channel. We send to
- *   userspace the wiphy on which we removed a restriction from
- *   (%NL80211_ATTR_WIPHY) and the channel on which this occurred
- *   before (%NL80211_ATTR_FREQ_BEFORE) and after (%NL80211_ATTR_FREQ_AFTER)
- *   the beacon hint was processed.
- *
- * @NL80211_CMD_AUTHENTICATE: authentication request and notification.
- *   This command is used both as a command (request to authenticate) and
- *   as an event on the "mlme" multicast group indicating completion of the
- *   authentication process.
- *   When used as a command, %NL80211_ATTR_IFINDEX is used to identify the
- *   interface. %NL80211_ATTR_MAC is used to specify PeerSTAAddress (and
- *   BSSID in case of station mode). %NL80211_ATTR_SSID is used to specify
- *   the SSID (mainly for association, but is included in authentication
- *   request, too, to help BSS selection. %NL80211_ATTR_WIPHY_FREQ is used
- *   to specify the frequence of the channel in MHz. %NL80211_ATTR_AUTH_TYPE
- *   is used to specify the authentication type. %NL80211_ATTR_IE is used to
- *   define IEs (VendorSpecificInfo, but also including RSN IE and FT IEs)
- *   to be added to the frame.
- *   When used as an event, this reports reception of an Authentication
- *   frame in station and IBSS modes when the local MLME processed the
- *   frame, i.e., it was for the local STA and was received in correct
- *   state. This is similar to MLME-AUTHENTICATE.confirm primitive in the
- *   MLME SAP interface (kernel providing MLME, userspace SME). The
- *   included %NL80211_ATTR_FRAME attribute contains the management frame
- *   (including both the header and frame body, but not FCS). This event is
- *   also used to indicate if the authentication attempt timed out. In that
- *   case the %NL80211_ATTR_FRAME attribute is replaced with a
- *   %NL80211_ATTR_TIMED_OUT flag (and %NL80211_ATTR_MAC to indicate which
- *   pending authentication timed out).
- * @NL80211_CMD_ASSOCIATE: association request and notification; like
- *   NL80211_CMD_AUTHENTICATE but for Association and Reassociation
- *   (similar to MLME-ASSOCIATE.request, MLME-REASSOCIATE.request,
- *   MLME-ASSOCIATE.confirm or MLME-REASSOCIATE.confirm primitives).
- * @NL80211_CMD_DEAUTHENTICATE: deauthentication request and notification; like
- *   NL80211_CMD_AUTHENTICATE but for Deauthentication frames (similar to
- *   MLME-DEAUTHENTICATION.request and MLME-DEAUTHENTICATE.indication
- *   primitives).
- * @NL80211_CMD_DISASSOCIATE: disassociation request and notification; like
- *   NL80211_CMD_AUTHENTICATE but for Disassociation frames (similar to
- *   MLME-DISASSOCIATE.request and MLME-DISASSOCIATE.indication primitives).
- *
- * @NL80211_CMD_MICHAEL_MIC_FAILURE: notification of a locally detected Michael
- *   MIC (part of TKIP) failure; sent on the "mlme" multicast group; the
- *   event includes %NL80211_ATTR_MAC to describe the source MAC address of
- *   the frame with invalid MIC, %NL80211_ATTR_KEY_TYPE to show the key
- *   type, %NL80211_ATTR_KEY_IDX to indicate the key identifier, and
- *   %NL80211_ATTR_KEY_SEQ to indicate the TSC value of the frame; this
- *   event matches with MLME-MICHAELMICFAILURE.indication() primitive
- *
- * @NL80211_CMD_JOIN_IBSS: Join a new IBSS -- given at least an SSID and a
- *   FREQ attribute (for the initial frequency if no peer can be found)
- *   and optionally a MAC (as BSSID) and FREQ_FIXED attribute if those
- *   should be fixed rather than automatically determined. Can only be
- *   executed on a network interface that is UP, and fixed BSSID/FREQ
- *   may be rejected. Another optional parameter is the beacon interval,
- *   given in the %NL80211_ATTR_BEACON_INTERVAL attribute, which if not
- *   given defaults to 100 TU (102.4ms).
- * @NL80211_CMD_LEAVE_IBSS: Leave the IBSS -- no special arguments, the IBSS is
- *   determined by the network interface.
- *
- * @NL80211_CMD_TESTMODE: testmode command, takes a wiphy (or ifindex) attribute
- *   to identify the device, and the TESTDATA blob attribute to pass through
- *   to the driver.
- *
- * @NL80211_CMD_CONNECT: connection request and notification; this command
- *   requests to connect to a specified network but without separating
- *   auth and assoc steps. For this, you need to specify the SSID in a
- *   %NL80211_ATTR_SSID attribute, and can optionally specify the association
- *   IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_MAC,
- *   %NL80211_ATTR_WIPHY_FREQ and %NL80211_ATTR_CONTROL_PORT.
- *   It is also sent as an event, with the BSSID and response IEs when the
- *   connection is established or failed to be established. This can be
- *   determined by the STATUS_CODE attribute.
- * @NL80211_CMD_ROAM: request that the card roam (currently not implemented),
- *   sent as an event when the card/driver roamed by itself.
- * @NL80211_CMD_DISCONNECT: drop a given connection; also used to notify
- *   userspace that a connection was dropped by the AP or due to other
- *   reasons, for this the %NL80211_ATTR_DISCONNECTED_BY_AP and
- *   %NL80211_ATTR_REASON_CODE attributes are used.
- *
- * @NL80211_CMD_SET_WIPHY_NETNS: Set a wiphy's netns. Note that all devices
- *   associated with this wiphy must be down and will follow.
- *
- * @NL80211_CMD_MAX: highest used command number
- * @__NL80211_CMD_AFTER_LAST: internal use
- */
-enum nl80211_commands {
-/* don't change the order or add anything inbetween, this is ABI! */
-   NL80211_CMD_UNSPEC,
-
-   NL80211_CMD_GET_WIPHY,      /* can dump */
-   NL80211_CMD_SET_WIPHY,
-   NL80211_CMD_NEW_WIPHY,
-   NL80211_CMD_DEL_WIPHY,
-
-   NL80211_CMD_GET_INTERFACE,   /* can dump */
-   NL80211_CMD_SET_INTERFACE,
-   NL80211_CMD_NEW_INTERFACE,
-   NL80211_CMD_DEL_INTERFACE,
-
-   NL80211_CMD_GET_KEY,
-   NL80211_CMD_SET_KEY,
-   NL80211_CMD_NEW_KEY,
-   NL80211_CMD_DEL_KEY,
-
-   NL80211_CMD_GET_BEACON,
-   NL80211_CMD_SET_BEACON,
-   NL80211_CMD_NEW_BEACON,
-   NL80211_CMD_DEL_BEACON,
-
-   NL80211_CMD_GET_STATION,
-   NL80211_CMD_SET_STATION,
-   NL80211_CMD_NEW_STATION,
-   NL80211_CMD_DEL_STATION,
-
-   NL80211_CMD_GET_MPATH,
-   NL80211_CMD_SET_MPATH,
-   NL80211_CMD_NEW_MPATH,
-   NL80211_CMD_DEL_MPATH,
-
-   NL80211_CMD_SET_BSS,
-
-   NL80211_CMD_SET_REG,
-   NL80211_CMD_REQ_SET_REG,
-
-   NL80211_CMD_GET_MESH_PARAMS,
-   NL80211_CMD_SET_MESH_PARAMS,
-
-   NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
-
-   NL80211_CMD_GET_REG,
-
-   NL80211_CMD_GET_SCAN,
-   NL80211_CMD_TRIGGER_SCAN,
-   NL80211_CMD_NEW_SCAN_RESULTS,
-   NL80211_CMD_SCAN_ABORTED,
-
-   NL80211_CMD_REG_CHANGE,
-
-   NL80211_CMD_AUTHENTICATE,
-   NL80211_CMD_ASSOCIATE,
-   NL80211_CMD_DEAUTHENTICATE,
-   NL80211_CMD_DISASSOCIATE,
-
-   NL80211_CMD_MICHAEL_MIC_FAILURE,
-
-   NL80211_CMD_REG_BEACON_HINT,
-
-   NL80211_CMD_JOIN_IBSS,
-   NL80211_CMD_LEAVE_IBSS,
-
-   NL80211_CMD_TESTMODE,
-
-   NL80211_CMD_CONNECT,
-   NL80211_CMD_ROAM,
-   NL80211_CMD_DISCONNECT,
-
-   NL80211_CMD_SET_WIPHY_NETNS,
-
-   NL80211_CMD_GET_SURVEY,
-   NL80211_CMD_NEW_SURVEY_RESULTS,
-
-   /* add new commands above here */
-
-   /* used to define NL80211_CMD_MAX below */
-   __NL80211_CMD_AFTER_LAST,
-   NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
-};
-
-/*
- * Allow user space programs to use #ifdef on new commands by defining them
- * here
- */
-#define NL80211_CMD_SET_BSS NL80211_CMD_SET_BSS
-#define NL80211_CMD_SET_MGMT_EXTRA_IE NL80211_CMD_SET_MGMT_EXTRA_IE
-#define NL80211_CMD_REG_CHANGE NL80211_CMD_REG_CHANGE
-#define NL80211_CMD_AUTHENTICATE NL80211_CMD_AUTHENTICATE
-#define NL80211_CMD_ASSOCIATE NL80211_CMD_ASSOCIATE
-#define NL80211_CMD_DEAUTHENTICATE NL80211_CMD_DEAUTHENTICATE
-#define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
-#define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
-
-/**
- * enum nl80211_attrs - nl80211 netlink attributes
- *
- * @NL80211_ATTR_UNSPEC: unspecified attribute to catch errors
- *
- * @NL80211_ATTR_WIPHY: index of wiphy to operate on, cf.
- *   /sys/class/ieee80211/<phyname>/index
- * @NL80211_ATTR_WIPHY_NAME: wiphy name (used for renaming)
- * @NL80211_ATTR_WIPHY_TXQ_PARAMS: a nested array of TX queue parameters
- * @NL80211_ATTR_WIPHY_FREQ: frequency of the selected channel in MHz
- * @NL80211_ATTR_WIPHY_CHANNEL_TYPE: included with NL80211_ATTR_WIPHY_FREQ
- *   if HT20 or HT40 are allowed (i.e., 802.11n disabled if not included):
- *   NL80211_CHAN_NO_HT = HT not allowed (i.e., same as not including
- *      this attribute)
- *   NL80211_CHAN_HT20 = HT20 only
- *   NL80211_CHAN_HT40MINUS = secondary channel is below the primary channel
- *   NL80211_CHAN_HT40PLUS = secondary channel is above the primary channel
- * @NL80211_ATTR_WIPHY_RETRY_SHORT: TX retry limit for frames whose length is
- *   less than or equal to the RTS threshold; allowed range: 1..255;
- *   dot11ShortRetryLimit; u8
- * @NL80211_ATTR_WIPHY_RETRY_LONG: TX retry limit for frames whose length is
- *   greater than the RTS threshold; allowed range: 1..255;
- *   dot11ShortLongLimit; u8
- * @NL80211_ATTR_WIPHY_FRAG_THRESHOLD: fragmentation threshold, i.e., maximum
- *   length in octets for frames; allowed range: 256..8000, disable
- *   fragmentation with (u32)-1; dot11FragmentationThreshold; u32
- * @NL80211_ATTR_WIPHY_RTS_THRESHOLD: RTS threshold (TX frames with length
- *   larger than or equal to this use RTS/CTS handshake); allowed range:
- *   0..65536, disable with (u32)-1; dot11RTSThreshold; u32
- *
- * @NL80211_ATTR_IFINDEX: network interface index of the device to operate on
- * @NL80211_ATTR_IFNAME: network interface name
- * @NL80211_ATTR_IFTYPE: type of virtual interface, see &enum nl80211_iftype
- *
- * @NL80211_ATTR_MAC: MAC address (various uses)
- *
- * @NL80211_ATTR_KEY_DATA: (temporal) key data; for TKIP this consists of
- *   16 bytes encryption key followed by 8 bytes each for TX and RX MIC
- *   keys
- * @NL80211_ATTR_KEY_IDX: key ID (u8, 0-3)
- * @NL80211_ATTR_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
- *   section 7.3.2.25.1, e.g. 0x000FAC04)
- * @NL80211_ATTR_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
- *   CCMP keys, each six bytes in little endian
- *
- * @NL80211_ATTR_BEACON_INTERVAL: beacon interval in TU
- * @NL80211_ATTR_DTIM_PERIOD: DTIM period for beaconing
- * @NL80211_ATTR_BEACON_HEAD: portion of the beacon before the TIM IE
- * @NL80211_ATTR_BEACON_TAIL: portion of the beacon after the TIM IE
- *
- * @NL80211_ATTR_STA_AID: Association ID for the station (u16)
- * @NL80211_ATTR_STA_FLAGS: flags, nested element with NLA_FLAG attributes of
- *   &enum nl80211_sta_flags (deprecated, use %NL80211_ATTR_STA_FLAGS2)
- * @NL80211_ATTR_STA_LISTEN_INTERVAL: listen interval as defined by
- *   IEEE 802.11 7.3.1.6 (u16).
- * @NL80211_ATTR_STA_SUPPORTED_RATES: supported rates, array of supported
- *   rates as defined by IEEE 802.11 7.3.2.2 but without the length
- *   restriction (at most %NL80211_MAX_SUPP_RATES).
- * @NL80211_ATTR_STA_VLAN: interface index of VLAN interface to move station
- *   to, or the AP interface the station was originally added to to.
- * @NL80211_ATTR_STA_INFO: information about a station, part of station info
- *   given for %NL80211_CMD_GET_STATION, nested attribute containing
- *   info as possible, see &enum nl80211_sta_info.
- *
- * @NL80211_ATTR_WIPHY_BANDS: Information about an operating bands,
- *   consisting of a nested array.
- *
- * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
- * @NL80211_ATTR_PLINK_ACTION: action to perform on the mesh peer link.
- * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
- * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
- *   info given for %NL80211_CMD_GET_MPATH, nested attribute described at
- *   &enum nl80211_mpath_info.
- *
- * @NL80211_ATTR_MNTR_FLAGS: flags, nested element with NLA_FLAG attributes of
- *   &enum nl80211_mntr_flags.
- *
- * @NL80211_ATTR_REG_ALPHA2: an ISO-3166-alpha2 country code for which the
- *   current regulatory domain should be set to or is already set to.
- *   For example, 'CR', for Costa Rica. This attribute is used by the kernel
- *   to query the CRDA to retrieve one regulatory domain. This attribute can
- *   also be used by userspace to query the kernel for the currently set
- *   regulatory domain. We chose an alpha2 as that is also used by the
- *   IEEE-802.11d country information element to identify a country.
- *   Users can also simply ask the wireless core to set regulatory domain
- *   to a specific alpha2.
- * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
- *   rules.
- *
- * @NL80211_ATTR_BSS_CTS_PROT: whether CTS protection is enabled (u8, 0 or 1)
- * @NL80211_ATTR_BSS_SHORT_PREAMBLE: whether short preamble is enabled
- *   (u8, 0 or 1)
- * @NL80211_ATTR_BSS_SHORT_SLOT_TIME: whether short slot time enabled
- *   (u8, 0 or 1)
- * @NL80211_ATTR_BSS_BASIC_RATES: basic rates, array of basic
- *   rates in format defined by IEEE 802.11 7.3.2.2 but without the length
- *   restriction (at most %NL80211_MAX_SUPP_RATES).
- *
- * @NL80211_ATTR_HT_CAPABILITY: HT Capability information element (from
- *   association request when used with NL80211_CMD_NEW_STATION)
- *
- * @NL80211_ATTR_SUPPORTED_IFTYPES: nested attribute containing all
- *   supported interface types, each a flag attribute with the number
- *   of the interface mode.
- *
- * @NL80211_ATTR_MGMT_SUBTYPE: Management frame subtype for
- *   %NL80211_CMD_SET_MGMT_EXTRA_IE.
- *
- * @NL80211_ATTR_IE: Information element(s) data (used, e.g., with
- *   %NL80211_CMD_SET_MGMT_EXTRA_IE).
- *
- * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
- *   a single scan request, a wiphy attribute.
- * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
- *   that can be added to a scan request
- *
- * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
- * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
- *   scanning and include a zero-length SSID (wildcard) for wildcard scan
- * @NL80211_ATTR_BSS: scan result BSS
- *
- * @NL80211_ATTR_REG_INITIATOR: indicates who requested the regulatory domain
- *   currently in effect. This could be any of the %NL80211_REGDOM_SET_BY_*
- * @NL80211_ATTR_REG_TYPE: indicates the type of the regulatory domain currently
- *   set. This can be one of the nl80211_reg_type (%NL80211_REGDOM_TYPE_*)
- *
- * @NL80211_ATTR_SUPPORTED_COMMANDS: wiphy attribute that specifies
- *   an array of command numbers (i.e. a mapping index to command number)
- *   that the driver for the given wiphy supports.
- *
- * @NL80211_ATTR_FRAME: frame data (binary attribute), including frame header
- *   and body, but not FCS; used, e.g., with NL80211_CMD_AUTHENTICATE and
- *   NL80211_CMD_ASSOCIATE events
- * @NL80211_ATTR_SSID: SSID (binary attribute, 0..32 octets)
- * @NL80211_ATTR_AUTH_TYPE: AuthenticationType, see &enum nl80211_auth_type,
- *   represented as a u32
- * @NL80211_ATTR_REASON_CODE: ReasonCode for %NL80211_CMD_DEAUTHENTICATE and
- *   %NL80211_CMD_DISASSOCIATE, u16
- *
- * @NL80211_ATTR_KEY_TYPE: Key Type, see &enum nl80211_key_type, represented as
- *   a u32
- *
- * @NL80211_ATTR_FREQ_BEFORE: A channel which has suffered a regulatory change
- *   due to considerations from a beacon hint. This attribute reflects
- *   the state of the channel _before_ the beacon hint processing. This
- *   attributes consists of a nested attribute containing
- *   NL80211_FREQUENCY_ATTR_*
- * @NL80211_ATTR_FREQ_AFTER: A channel which has suffered a regulatory change
- *   due to considerations from a beacon hint. This attribute reflects
- *   the state of the channel _after_ the beacon hint processing. This
- *   attributes consists of a nested attribute containing
- *   NL80211_FREQUENCY_ATTR_*
- *
- * @NL80211_ATTR_CIPHER_SUITES: a set of u32 values indicating the supported
- *   cipher suites
- *
- * @NL80211_ATTR_FREQ_FIXED: a flag indicating the IBSS should not try to look
- *   for other networks on different channels
- *
- * @NL80211_ATTR_TIMED_OUT: a flag indicating than an operation timed out; this
- *   is used, e.g., with %NL80211_CMD_AUTHENTICATE event
- *
- * @NL80211_ATTR_USE_MFP: Whether management frame protection (IEEE 802.11w) is
- *   used for the association (&enum nl80211_mfp, represented as a u32);
- *   this attribute can be used
- *   with %NL80211_CMD_ASSOCIATE request
- *
- * @NL80211_ATTR_STA_FLAGS2: Attribute containing a
- *   &struct nl80211_sta_flag_update.
- *
- * @NL80211_ATTR_CONTROL_PORT: A flag indicating whether user space controls
- *   IEEE 802.1X port, i.e., sets/clears %NL80211_STA_FLAG_AUTHORIZED, in
- *   station mode. If the flag is included in %NL80211_CMD_ASSOCIATE
- *   request, the driver will assume that the port is unauthorized until
- *   authorized by user space. Otherwise, port is marked authorized by
- *   default in station mode.
- *
- * @NL80211_ATTR_TESTDATA: Testmode data blob, passed through to the driver.
- *   We recommend using nested, driver-specific attributes within this.
- *
- * @NL80211_ATTR_DISCONNECTED_BY_AP: A flag indicating that the DISCONNECT
- *   event was due to the AP disconnecting the station, and not due to
- *   a local disconnect request.
- * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
- *   event (u16)
- * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
- *   that protected APs should be used.
- *
- * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT and ASSOCIATE to
- *   indicate which unicast key ciphers will be used with the connection
- *   (an array of u32).
- * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT and ASSOCIATE to indicate
- *   which group key cipher will be used with the connection (a u32).
- * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT and ASSOCIATE to indicate
- *   which WPA version(s) the AP we want to associate with is using
- *   (a u32 with flags from &enum nl80211_wpa_versions).
- * @NL80211_ATTR_AKM_SUITES: Used with CONNECT and ASSOCIATE to indicate
- *   which key management algorithm(s) to use (an array of u32).
- *
- * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
- *   sent out by the card, for ROAM and successful CONNECT events.
- * @NL80211_ATTR_RESP_IE: (Re)association response information elements as
- *   sent by peer, for ROAM and successful CONNECT events.
- *
- * @NL80211_ATTR_PREV_BSSID: previous BSSID, to be used by in ASSOCIATE
- *   commands to specify using a reassociate frame
- *
- * @NL80211_ATTR_KEY: key information in a nested attribute with
- *   %NL80211_KEY_* sub-attributes
- * @NL80211_ATTR_KEYS: array of keys for static WEP keys for connect()
- *   and join_ibss(), key information is in a nested attribute each
- *   with %NL80211_KEY_* sub-attributes
- *
- * @NL80211_ATTR_PID: Process ID of a network namespace.
- *
- * @NL80211_ATTR_GENERATION: Used to indicate consistent snapshots for
- *   dumps. This number increases whenever the object list being
- *   dumped changes, and as such userspace can verify that it has
- *   obtained a complete and consistent snapshot by verifying that
- *   all dump messages contain the same generation number. If it
- *   changed then the list changed and the dump should be repeated
- *   completely from scratch.
- *
- * @NL80211_ATTR_4ADDR: Use 4-address frames on a virtual interface
- *
- * @NL80211_ATTR_SURVEY_INFO: survey information about a channel, part of
- *      the survey response for %NL80211_CMD_GET_SURVEY, nested attribute
- *      containing info as possible, see &enum survey_info.
- *
- * @NL80211_ATTR_MAX: highest attribute number currently defined
- * @__NL80211_ATTR_AFTER_LAST: internal use
- */
-enum nl80211_attrs {
-/* don't change the order or add anything inbetween, this is ABI! */
-   NL80211_ATTR_UNSPEC,
-
-   NL80211_ATTR_WIPHY,
-   NL80211_ATTR_WIPHY_NAME,
-
-   NL80211_ATTR_IFINDEX,
-   NL80211_ATTR_IFNAME,
-   NL80211_ATTR_IFTYPE,
-
-   NL80211_ATTR_MAC,
-
-   NL80211_ATTR_KEY_DATA,
-   NL80211_ATTR_KEY_IDX,
-   NL80211_ATTR_KEY_CIPHER,
-   NL80211_ATTR_KEY_SEQ,
-   NL80211_ATTR_KEY_DEFAULT,
-
-   NL80211_ATTR_BEACON_INTERVAL,
-   NL80211_ATTR_DTIM_PERIOD,
-   NL80211_ATTR_BEACON_HEAD,
-   NL80211_ATTR_BEACON_TAIL,
-
-   NL80211_ATTR_STA_AID,
-   NL80211_ATTR_STA_FLAGS,
-   NL80211_ATTR_STA_LISTEN_INTERVAL,
-   NL80211_ATTR_STA_SUPPORTED_RATES,
-   NL80211_ATTR_STA_VLAN,
-   NL80211_ATTR_STA_INFO,
-
-   NL80211_ATTR_WIPHY_BANDS,
-
-   NL80211_ATTR_MNTR_FLAGS,
-
-   NL80211_ATTR_MESH_ID,
-   NL80211_ATTR_STA_PLINK_ACTION,
-   NL80211_ATTR_MPATH_NEXT_HOP,
-   NL80211_ATTR_MPATH_INFO,
-
-   NL80211_ATTR_BSS_CTS_PROT,
-   NL80211_ATTR_BSS_SHORT_PREAMBLE,
-   NL80211_ATTR_BSS_SHORT_SLOT_TIME,
-
-   NL80211_ATTR_HT_CAPABILITY,
-
-   NL80211_ATTR_SUPPORTED_IFTYPES,
-
-   NL80211_ATTR_REG_ALPHA2,
-   NL80211_ATTR_REG_RULES,
-
-   NL80211_ATTR_MESH_PARAMS,
-
-   NL80211_ATTR_BSS_BASIC_RATES,
-
-   NL80211_ATTR_WIPHY_TXQ_PARAMS,
-   NL80211_ATTR_WIPHY_FREQ,
-   NL80211_ATTR_WIPHY_CHANNEL_TYPE,
-
-   NL80211_ATTR_KEY_DEFAULT_MGMT,
-
-   NL80211_ATTR_MGMT_SUBTYPE,
-   NL80211_ATTR_IE,
-
-   NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
-
-   NL80211_ATTR_SCAN_FREQUENCIES,
-   NL80211_ATTR_SCAN_SSIDS,
-   NL80211_ATTR_GENERATION, /* replaces old SCAN_GENERATION */
-   NL80211_ATTR_BSS,
-
-   NL80211_ATTR_REG_INITIATOR,
-   NL80211_ATTR_REG_TYPE,
-
-   NL80211_ATTR_SUPPORTED_COMMANDS,
-
-   NL80211_ATTR_FRAME,
-   NL80211_ATTR_SSID,
-   NL80211_ATTR_AUTH_TYPE,
-   NL80211_ATTR_REASON_CODE,
-
-   NL80211_ATTR_KEY_TYPE,
-
-   NL80211_ATTR_MAX_SCAN_IE_LEN,
-   NL80211_ATTR_CIPHER_SUITES,
-
-   NL80211_ATTR_FREQ_BEFORE,
-   NL80211_ATTR_FREQ_AFTER,
-
-   NL80211_ATTR_FREQ_FIXED,
-
-
-   NL80211_ATTR_WIPHY_RETRY_SHORT,
-   NL80211_ATTR_WIPHY_RETRY_LONG,
-   NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
-   NL80211_ATTR_WIPHY_RTS_THRESHOLD,
-
-   NL80211_ATTR_TIMED_OUT,
-
-   NL80211_ATTR_USE_MFP,
-
-   NL80211_ATTR_STA_FLAGS2,
-
-   NL80211_ATTR_CONTROL_PORT,
-
-   NL80211_ATTR_TESTDATA,
-
-   NL80211_ATTR_PRIVACY,
-
-   NL80211_ATTR_DISCONNECTED_BY_AP,
-   NL80211_ATTR_STATUS_CODE,
-
-   NL80211_ATTR_CIPHER_SUITES_PAIRWISE,
-   NL80211_ATTR_CIPHER_SUITE_GROUP,
-   NL80211_ATTR_WPA_VERSIONS,
-   NL80211_ATTR_AKM_SUITES,
-
-   NL80211_ATTR_REQ_IE,
-   NL80211_ATTR_RESP_IE,
-
-   NL80211_ATTR_PREV_BSSID,
-
-   NL80211_ATTR_KEY,
-   NL80211_ATTR_KEYS,
-
-   NL80211_ATTR_PID,
-
-   NL80211_ATTR_4ADDR,
-
-   NL80211_ATTR_SURVEY_INFO,
-
-   /* add attributes here, update the policy in nl80211.c */
-
-   __NL80211_ATTR_AFTER_LAST,
-   NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
-};
-
-/* source-level API compatibility */
-#define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
-
-/*
- * Allow user space programs to use #ifdef on new attributes by defining them
- * here
- */
-#define NL80211_CMD_CONNECT NL80211_CMD_CONNECT
-#define NL80211_ATTR_HT_CAPABILITY NL80211_ATTR_HT_CAPABILITY
-#define NL80211_ATTR_BSS_BASIC_RATES NL80211_ATTR_BSS_BASIC_RATES
-#define NL80211_ATTR_WIPHY_TXQ_PARAMS NL80211_ATTR_WIPHY_TXQ_PARAMS
-#define NL80211_ATTR_WIPHY_FREQ NL80211_ATTR_WIPHY_FREQ
-#define NL80211_ATTR_WIPHY_CHANNEL_TYPE NL80211_ATTR_WIPHY_CHANNEL_TYPE
-#define NL80211_ATTR_MGMT_SUBTYPE NL80211_ATTR_MGMT_SUBTYPE
-#define NL80211_ATTR_IE NL80211_ATTR_IE
-#define NL80211_ATTR_REG_INITIATOR NL80211_ATTR_REG_INITIATOR
-#define NL80211_ATTR_REG_TYPE NL80211_ATTR_REG_TYPE
-#define NL80211_ATTR_FRAME NL80211_ATTR_FRAME
-#define NL80211_ATTR_SSID NL80211_ATTR_SSID
-#define NL80211_ATTR_AUTH_TYPE NL80211_ATTR_AUTH_TYPE
-#define NL80211_ATTR_REASON_CODE NL80211_ATTR_REASON_CODE
-#define NL80211_ATTR_CIPHER_SUITES_PAIRWISE NL80211_ATTR_CIPHER_SUITES_PAIRWISE
-#define NL80211_ATTR_CIPHER_SUITE_GROUP NL80211_ATTR_CIPHER_SUITE_GROUP
-#define NL80211_ATTR_WPA_VERSIONS NL80211_ATTR_WPA_VERSIONS
-#define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
-#define NL80211_ATTR_KEY NL80211_ATTR_KEY
-#define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
-
-#define NL80211_MAX_SUPP_RATES         32
-#define NL80211_MAX_SUPP_REG_RULES      32
-#define NL80211_TKIP_DATA_OFFSET_ENCR_KEY   0
-#define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY   16
-#define NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY   24
-#define NL80211_HT_CAPABILITY_LEN      26
-
-#define NL80211_MAX_NR_CIPHER_SUITES      5
-#define NL80211_MAX_NR_AKM_SUITES      2
-
-/**
- * enum nl80211_iftype - (virtual) interface types
- *
- * @NL80211_IFTYPE_UNSPECIFIED: unspecified type, driver decides
- * @NL80211_IFTYPE_ADHOC: independent BSS member
- * @NL80211_IFTYPE_STATION: managed BSS member
- * @NL80211_IFTYPE_AP: access point
- * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points
- * @NL80211_IFTYPE_WDS: wireless distribution interface
- * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
- * @NL80211_IFTYPE_MESH_POINT: mesh point
- * @NL80211_IFTYPE_MAX: highest interface type number currently defined
- * @__NL80211_IFTYPE_AFTER_LAST: internal use
- *
- * These values are used with the %NL80211_ATTR_IFTYPE
- * to set the type of an interface.
- *
- */
-enum nl80211_iftype {
-   NL80211_IFTYPE_UNSPECIFIED,
-   NL80211_IFTYPE_ADHOC,
-   NL80211_IFTYPE_STATION,
-   NL80211_IFTYPE_AP,
-   NL80211_IFTYPE_AP_VLAN,
-   NL80211_IFTYPE_WDS,
-   NL80211_IFTYPE_MONITOR,
-   NL80211_IFTYPE_MESH_POINT,
-
-   /* keep last */
-   __NL80211_IFTYPE_AFTER_LAST,
-   NL80211_IFTYPE_MAX = __NL80211_IFTYPE_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_sta_flags - station flags
- *
- * Station flags. When a station is added to an AP interface, it is
- * assumed to be already associated (and hence authenticated.)
- *
- * @NL80211_STA_FLAG_AUTHORIZED: station is authorized (802.1X)
- * @NL80211_STA_FLAG_SHORT_PREAMBLE: station is capable of receiving frames
- *   with short barker preamble
- * @NL80211_STA_FLAG_WME: station is WME/QoS capable
- * @NL80211_STA_FLAG_MFP: station uses management frame protection
- */
-enum nl80211_sta_flags {
-   __NL80211_STA_FLAG_INVALID,
-   NL80211_STA_FLAG_AUTHORIZED,
-   NL80211_STA_FLAG_SHORT_PREAMBLE,
-   NL80211_STA_FLAG_WME,
-   NL80211_STA_FLAG_MFP,
-
-   /* keep last */
-   __NL80211_STA_FLAG_AFTER_LAST,
-   NL80211_STA_FLAG_MAX = __NL80211_STA_FLAG_AFTER_LAST - 1
-};
-
-/**
- * struct nl80211_sta_flag_update - station flags mask/set
- * @mask: mask of station flags to set
- * @set: which values to set them to
- *
- * Both mask and set contain bits as per &enum nl80211_sta_flags.
- */
-struct nl80211_sta_flag_update {
-   __u32 mask;
-   __u32 set;
-} __attribute__((packed));
-
-/**
- * enum nl80211_rate_info - bitrate information
- *
- * These attribute types are used with %NL80211_STA_INFO_TXRATE
- * when getting information about the bitrate of a station.
- *
- * @__NL80211_RATE_INFO_INVALID: attribute number 0 is reserved
- * @NL80211_RATE_INFO_BITRATE: total bitrate (u16, 100kbit/s)
- * @NL80211_RATE_INFO_MCS: mcs index for 802.11n (u8)
- * @NL80211_RATE_INFO_40_MHZ_WIDTH: 40 Mhz dualchannel bitrate
- * @NL80211_RATE_INFO_SHORT_GI: 400ns guard interval
- * @NL80211_RATE_INFO_MAX: highest rate_info number currently defined
- * @__NL80211_RATE_INFO_AFTER_LAST: internal use
- */
-enum nl80211_rate_info {
-   __NL80211_RATE_INFO_INVALID,
-   NL80211_RATE_INFO_BITRATE,
-   NL80211_RATE_INFO_MCS,
-   NL80211_RATE_INFO_40_MHZ_WIDTH,
-   NL80211_RATE_INFO_SHORT_GI,
-
-   /* keep last */
-   __NL80211_RATE_INFO_AFTER_LAST,
-   NL80211_RATE_INFO_MAX = __NL80211_RATE_INFO_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_sta_info - station information
- *
- * These attribute types are used with %NL80211_ATTR_STA_INFO
- * when getting information about a station.
- *
- * @__NL80211_STA_INFO_INVALID: attribute number 0 is reserved
- * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
- * @NL80211_STA_INFO_RX_BYTES: total received bytes (u32, from this station)
- * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (u32, to this station)
- * @__NL80211_STA_INFO_AFTER_LAST: internal
- * @NL80211_STA_INFO_MAX: highest possible station info attribute
- * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
- * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
- *   containing info as possible, see &enum nl80211_sta_info_txrate.
- * @NL80211_STA_INFO_RX_PACKETS: total received packet (u32, from this station)
- * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (u32, to this
- *   station)
- */
-enum nl80211_sta_info {
-   __NL80211_STA_INFO_INVALID,
-   NL80211_STA_INFO_INACTIVE_TIME,
-   NL80211_STA_INFO_RX_BYTES,
-   NL80211_STA_INFO_TX_BYTES,
-   NL80211_STA_INFO_LLID,
-   NL80211_STA_INFO_PLID,
-   NL80211_STA_INFO_PLINK_STATE,
-   NL80211_STA_INFO_SIGNAL,
-   NL80211_STA_INFO_TX_BITRATE,
-   NL80211_STA_INFO_RX_PACKETS,
-   NL80211_STA_INFO_TX_PACKETS,
-
-   /* keep last */
-   __NL80211_STA_INFO_AFTER_LAST,
-   NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_mpath_flags - nl80211 mesh path flags
- *
- * @NL80211_MPATH_FLAG_ACTIVE: the mesh path is active
- * @NL80211_MPATH_FLAG_RESOLVING: the mesh path discovery process is running
- * @NL80211_MPATH_FLAG_SN_VALID: the mesh path contains a valid SN
- * @NL80211_MPATH_FLAG_FIXED: the mesh path has been manually set
- * @NL80211_MPATH_FLAG_RESOLVED: the mesh path discovery process succeeded
- */
-enum nl80211_mpath_flags {
-   NL80211_MPATH_FLAG_ACTIVE =   1<<0,
-   NL80211_MPATH_FLAG_RESOLVING =   1<<1,
-   NL80211_MPATH_FLAG_SN_VALID =   1<<2,
-   NL80211_MPATH_FLAG_FIXED =   1<<3,
-   NL80211_MPATH_FLAG_RESOLVED =   1<<4,
-};
-
-/**
- * enum nl80211_mpath_info - mesh path information
- *
- * These attribute types are used with %NL80211_ATTR_MPATH_INFO when getting
- * information about a mesh path.
- *
- * @__NL80211_MPATH_INFO_INVALID: attribute number 0 is reserved
- * @NL80211_ATTR_MPATH_FRAME_QLEN: number of queued frames for this destination
- * @NL80211_ATTR_MPATH_SN: destination sequence number
- * @NL80211_ATTR_MPATH_METRIC: metric (cost) of this mesh path
- * @NL80211_ATTR_MPATH_EXPTIME: expiration time for the path, in msec from now
- * @NL80211_ATTR_MPATH_FLAGS: mesh path flags, enumerated in
- *   &enum nl80211_mpath_flags;
- * @NL80211_ATTR_MPATH_DISCOVERY_TIMEOUT: total path discovery timeout, in msec
- * @NL80211_ATTR_MPATH_DISCOVERY_RETRIES: mesh path discovery retries
- */
-enum nl80211_mpath_info {
-   __NL80211_MPATH_INFO_INVALID,
-   NL80211_MPATH_INFO_FRAME_QLEN,
-   NL80211_MPATH_INFO_SN,
-   NL80211_MPATH_INFO_METRIC,
-   NL80211_MPATH_INFO_EXPTIME,
-   NL80211_MPATH_INFO_FLAGS,
-   NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,
-   NL80211_MPATH_INFO_DISCOVERY_RETRIES,
-
-   /* keep last */
-   __NL80211_MPATH_INFO_AFTER_LAST,
-   NL80211_MPATH_INFO_MAX = __NL80211_MPATH_INFO_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_band_attr - band attributes
- * @__NL80211_BAND_ATTR_INVALID: attribute number 0 is reserved
- * @NL80211_BAND_ATTR_FREQS: supported frequencies in this band,
- *   an array of nested frequency attributes
- * @NL80211_BAND_ATTR_RATES: supported bitrates in this band,
- *   an array of nested bitrate attributes
- * @NL80211_BAND_ATTR_HT_MCS_SET: 16-byte attribute containing the MCS set as
- *   defined in 802.11n
- * @NL80211_BAND_ATTR_HT_CAPA: HT capabilities, as in the HT information IE
- * @NL80211_BAND_ATTR_HT_AMPDU_FACTOR: A-MPDU factor, as in 11n
- * @NL80211_BAND_ATTR_HT_AMPDU_DENSITY: A-MPDU density, as in 11n
- */
-enum nl80211_band_attr {
-   __NL80211_BAND_ATTR_INVALID,
-   NL80211_BAND_ATTR_FREQS,
-   NL80211_BAND_ATTR_RATES,
-
-   NL80211_BAND_ATTR_HT_MCS_SET,
-   NL80211_BAND_ATTR_HT_CAPA,
-   NL80211_BAND_ATTR_HT_AMPDU_FACTOR,
-   NL80211_BAND_ATTR_HT_AMPDU_DENSITY,
-
-   /* keep last */
-   __NL80211_BAND_ATTR_AFTER_LAST,
-   NL80211_BAND_ATTR_MAX = __NL80211_BAND_ATTR_AFTER_LAST - 1
-};
-
-#define NL80211_BAND_ATTR_HT_CAPA NL80211_BAND_ATTR_HT_CAPA
-
-/**
- * enum nl80211_frequency_attr - frequency attributes
- * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
- * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
- *   regulatory domain.
- * @NL80211_FREQUENCY_ATTR_PASSIVE_SCAN: Only passive scanning is
- *   permitted on this channel in current regulatory domain.
- * @NL80211_FREQUENCY_ATTR_NO_IBSS: IBSS networks are not permitted
- *   on this channel in current regulatory domain.
- * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
- *   on this channel in current regulatory domain.
- * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
- *   (100 * dBm).
- */
-enum nl80211_frequency_attr {
-   __NL80211_FREQUENCY_ATTR_INVALID,
-   NL80211_FREQUENCY_ATTR_FREQ,
-   NL80211_FREQUENCY_ATTR_DISABLED,
-   NL80211_FREQUENCY_ATTR_PASSIVE_SCAN,
-   NL80211_FREQUENCY_ATTR_NO_IBSS,
-   NL80211_FREQUENCY_ATTR_RADAR,
-   NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
-
-   /* keep last */
-   __NL80211_FREQUENCY_ATTR_AFTER_LAST,
-   NL80211_FREQUENCY_ATTR_MAX = __NL80211_FREQUENCY_ATTR_AFTER_LAST - 1
-};
-
-#define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
-
-/**
- * enum nl80211_bitrate_attr - bitrate attributes
- * @NL80211_BITRATE_ATTR_RATE: Bitrate in units of 100 kbps
- * @NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE: Short preamble supported
- *   in 2.4 GHz band.
- */
-enum nl80211_bitrate_attr {
-   __NL80211_BITRATE_ATTR_INVALID,
-   NL80211_BITRATE_ATTR_RATE,
-   NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE,
-
-   /* keep last */
-   __NL80211_BITRATE_ATTR_AFTER_LAST,
-   NL80211_BITRATE_ATTR_MAX = __NL80211_BITRATE_ATTR_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_initiator - Indicates the initiator of a reg domain request
- * @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world
- *   regulatory domain.
- * @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the
- *   regulatory domain.
- * @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the
- *   wireless core it thinks its knows the regulatory domain we should be in.
- * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
- *   802.11 country information element with regulatory information it
- *   thinks we should consider.
- */
-enum nl80211_reg_initiator {
-   NL80211_REGDOM_SET_BY_CORE,
-   NL80211_REGDOM_SET_BY_USER,
-   NL80211_REGDOM_SET_BY_DRIVER,
-   NL80211_REGDOM_SET_BY_COUNTRY_IE,
-};
-
-/**
- * enum nl80211_reg_type - specifies the type of regulatory domain
- * @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains
- *   to a specific country. When this is set you can count on the
- *   ISO / IEC 3166 alpha2 country code being valid.
- * @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory
- *   domain.
- * @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom
- *   driver specific world regulatory domain. These do not apply system-wide
- *   and are only applicable to the individual devices which have requested
- *   them to be applied.
- * @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product
- *   of an intersection between two regulatory domains -- the previously
- *   set regulatory domain on the system and the last accepted regulatory
- *   domain request to be processed.
- */
-enum nl80211_reg_type {
-   NL80211_REGDOM_TYPE_COUNTRY,
-   NL80211_REGDOM_TYPE_WORLD,
-   NL80211_REGDOM_TYPE_CUSTOM_WORLD,
-   NL80211_REGDOM_TYPE_INTERSECTION,
-};
-
-/**
- * enum nl80211_reg_rule_attr - regulatory rule attributes
- * @NL80211_ATTR_REG_RULE_FLAGS: a set of flags which specify additional
- *   considerations for a given frequency range. These are the
- *   &enum nl80211_reg_rule_flags.
- * @NL80211_ATTR_FREQ_RANGE_START: starting frequencry for the regulatory
- *   rule in KHz. This is not a center of frequency but an actual regulatory
- *   band edge.
- * @NL80211_ATTR_FREQ_RANGE_END: ending frequency for the regulatory rule
- *   in KHz. This is not a center a frequency but an actual regulatory
- *   band edge.
- * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
- *   frequency range, in KHz.
- * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
- *   for a given frequency range. The value is in mBi (100 * dBi).
- *   If you don't have one then don't send this.
- * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
- *   a given frequency range. The value is in mBm (100 * dBm).
- */
-enum nl80211_reg_rule_attr {
-   __NL80211_REG_RULE_ATTR_INVALID,
-   NL80211_ATTR_REG_RULE_FLAGS,
-
-   NL80211_ATTR_FREQ_RANGE_START,
-   NL80211_ATTR_FREQ_RANGE_END,
-   NL80211_ATTR_FREQ_RANGE_MAX_BW,
-
-   NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
-   NL80211_ATTR_POWER_RULE_MAX_EIRP,
-
-   /* keep last */
-   __NL80211_REG_RULE_ATTR_AFTER_LAST,
-   NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_reg_rule_flags - regulatory rule flags
- *
- * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
- * @NL80211_RRF_NO_CCK: CCK modulation not allowed
- * @NL80211_RRF_NO_INDOOR: indoor operation not allowed
- * @NL80211_RRF_NO_OUTDOOR: outdoor operation not allowed
- * @NL80211_RRF_DFS: DFS support is required to be used
- * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
- * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
- * @NL80211_RRF_PASSIVE_SCAN: passive scan is required
- * @NL80211_RRF_NO_IBSS: no IBSS is allowed
- */
-enum nl80211_reg_rule_flags {
-   NL80211_RRF_NO_OFDM      = 1<<0,
-   NL80211_RRF_NO_CCK      = 1<<1,
-   NL80211_RRF_NO_INDOOR      = 1<<2,
-   NL80211_RRF_NO_OUTDOOR      = 1<<3,
-   NL80211_RRF_DFS         = 1<<4,
-   NL80211_RRF_PTP_ONLY      = 1<<5,
-   NL80211_RRF_PTMP_ONLY      = 1<<6,
-   NL80211_RRF_PASSIVE_SCAN   = 1<<7,
-   NL80211_RRF_NO_IBSS      = 1<<8,
-};
-
-/**
- * enum nl80211_survey_info - survey information
- *
- * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
- * when getting information about a survey.
- *
- * @__NL80211_SURVEY_INFO_INVALID: attribute number 0 is reserved
- * @NL80211_SURVEY_INFO_FREQUENCY: center frequency of channel
- * @NL80211_SURVEY_INFO_NOISE: noise level of channel (u8, dBm)
- */
-enum nl80211_survey_info {
-   __NL80211_SURVEY_INFO_INVALID,
-   NL80211_SURVEY_INFO_FREQUENCY,
-   NL80211_SURVEY_INFO_NOISE,
-
-   /* keep last */
-   __NL80211_SURVEY_INFO_AFTER_LAST,
-   NL80211_SURVEY_INFO_MAX = __NL80211_SURVEY_INFO_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_mntr_flags - monitor configuration flags
- *
- * Monitor configuration flags.
- *
- * @__NL80211_MNTR_FLAG_INVALID: reserved
- *
- * @NL80211_MNTR_FLAG_FCSFAIL: pass frames with bad FCS
- * @NL80211_MNTR_FLAG_PLCPFAIL: pass frames with bad PLCP
- * @NL80211_MNTR_FLAG_CONTROL: pass control frames
- * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
- * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
- *   overrides all other flags.
- *
- * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
- * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
- */
-enum nl80211_mntr_flags {
-   __NL80211_MNTR_FLAG_INVALID,
-   NL80211_MNTR_FLAG_FCSFAIL,
-   NL80211_MNTR_FLAG_PLCPFAIL,
-   NL80211_MNTR_FLAG_CONTROL,
-   NL80211_MNTR_FLAG_OTHER_BSS,
-   NL80211_MNTR_FLAG_COOK_FRAMES,
-
-   /* keep last */
-   __NL80211_MNTR_FLAG_AFTER_LAST,
-   NL80211_MNTR_FLAG_MAX = __NL80211_MNTR_FLAG_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_meshconf_params - mesh configuration parameters
- *
- * Mesh configuration parameters
- *
- * @__NL80211_MESHCONF_INVALID: internal use
- *
- * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
- * millisecond units, used by the Peer Link Open message
- *
- * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the inital confirm timeout, in
- * millisecond units, used by the peer link management to close a peer link
- *
- * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
- * millisecond units
- *
- * @NL80211_MESHCONF_MAX_PEER_LINKS: maximum number of peer links allowed
- * on this mesh interface
- *
- * @NL80211_MESHCONF_MAX_RETRIES: specifies the maximum number of peer link
- * open retries that can be sent to establish a new peer link instance in a
- * mesh
- *
- * @NL80211_MESHCONF_TTL: specifies the value of TTL field set at a source mesh
- * point.
- *
- * @NL80211_MESHCONF_AUTO_OPEN_PLINKS: whether we should automatically
- * open peer links when we detect compatible mesh peers.
- *
- * @NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES: the number of action frames
- * containing a PREQ that an MP can send to a particular destination (path
- * target)
- *
- * @NL80211_MESHCONF_PATH_REFRESH_TIME: how frequently to refresh mesh paths
- * (in milliseconds)
- *
- * @NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT: minimum length of time to wait
- * until giving up on a path discovery (in milliseconds)
- *
- * @NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT: The time (in TUs) for which mesh
- * points receiving a PREQ shall consider the forwarding information from the
- * root to be valid. (TU = time unit)
- *
- * @NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL: The minimum interval of time (in
- * TUs) during which an MP can send only one action frame containing a PREQ
- * reference element
- *
- * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
- * that it takes for an HWMP information element to propagate across the mesh
- *
- * @NL80211_MESHCONF_ROOTMODE: whether root mode is enabled or not
- *
- * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
- *
- * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
- */
-enum nl80211_meshconf_params {
-   __NL80211_MESHCONF_INVALID,
-   NL80211_MESHCONF_RETRY_TIMEOUT,
-   NL80211_MESHCONF_CONFIRM_TIMEOUT,
-   NL80211_MESHCONF_HOLDING_TIMEOUT,
-   NL80211_MESHCONF_MAX_PEER_LINKS,
-   NL80211_MESHCONF_MAX_RETRIES,
-   NL80211_MESHCONF_TTL,
-   NL80211_MESHCONF_AUTO_OPEN_PLINKS,
-   NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,
-   NL80211_MESHCONF_PATH_REFRESH_TIME,
-   NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,
-   NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,
-   NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
-   NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
-   NL80211_MESHCONF_HWMP_ROOTMODE,
-
-   /* keep last */
-   __NL80211_MESHCONF_ATTR_AFTER_LAST,
-   NL80211_MESHCONF_ATTR_MAX = __NL80211_MESHCONF_ATTR_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_txq_attr - TX queue parameter attributes
- * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
- * @NL80211_TXQ_ATTR_QUEUE: TX queue identifier (NL80211_TXQ_Q_*)
- * @NL80211_TXQ_ATTR_TXOP: Maximum burst time in units of 32 usecs, 0 meaning
- *   disabled
- * @NL80211_TXQ_ATTR_CWMIN: Minimum contention window [a value of the form
- *   2^n-1 in the range 1..32767]
- * @NL80211_TXQ_ATTR_CWMAX: Maximum contention window [a value of the form
- *   2^n-1 in the range 1..32767]
- * @NL80211_TXQ_ATTR_AIFS: Arbitration interframe space [0..255]
- * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
- * @NL80211_TXQ_ATTR_MAX: Maximum TXQ attribute number
- */
-enum nl80211_txq_attr {
-   __NL80211_TXQ_ATTR_INVALID,
-   NL80211_TXQ_ATTR_QUEUE,
-   NL80211_TXQ_ATTR_TXOP,
-   NL80211_TXQ_ATTR_CWMIN,
-   NL80211_TXQ_ATTR_CWMAX,
-   NL80211_TXQ_ATTR_AIFS,
-
-   /* keep last */
-   __NL80211_TXQ_ATTR_AFTER_LAST,
-   NL80211_TXQ_ATTR_MAX = __NL80211_TXQ_ATTR_AFTER_LAST - 1
-};
-
-enum nl80211_txq_q {
-   NL80211_TXQ_Q_VO,
-   NL80211_TXQ_Q_VI,
-   NL80211_TXQ_Q_BE,
-   NL80211_TXQ_Q_BK
-};
-
-enum nl80211_channel_type {
-   NL80211_CHAN_NO_HT,
-   NL80211_CHAN_HT20,
-   NL80211_CHAN_HT40MINUS,
-   NL80211_CHAN_HT40PLUS
-};
-
-/**
- * enum nl80211_bss - netlink attributes for a BSS
- *
- * @__NL80211_BSS_INVALID: invalid
- * @NL80211_BSS_FREQUENCY: frequency in MHz (u32)
- * @NL80211_BSS_TSF: TSF of the received probe response/beacon (u64)
- * @NL80211_BSS_BEACON_INTERVAL: beacon interval of the (I)BSS (u16)
- * @NL80211_BSS_CAPABILITY: capability field (CPU order, u16)
- * @NL80211_BSS_INFORMATION_ELEMENTS: binary attribute containing the
- *   raw information elements from the probe response/beacon (bin)
- * @NL80211_BSS_SIGNAL_MBM: signal strength of probe response/beacon
- *   in mBm (100 * dBm) (s32)
- * @NL80211_BSS_SIGNAL_UNSPEC: signal strength of the probe response/beacon
- *   in unspecified units, scaled to 0..100 (u8)
- * @NL80211_BSS_STATUS: status, if this BSS is "used"
- * @NL80211_BSS_SEEN_MS_AGO: age of this BSS entry in ms
- * @__NL80211_BSS_AFTER_LAST: internal
- * @NL80211_BSS_MAX: highest BSS attribute
- */
-enum nl80211_bss {
-   __NL80211_BSS_INVALID,
-   NL80211_BSS_BSSID,
-   NL80211_BSS_FREQUENCY,
-   NL80211_BSS_TSF,
-   NL80211_BSS_BEACON_INTERVAL,
-   NL80211_BSS_CAPABILITY,
-   NL80211_BSS_INFORMATION_ELEMENTS,
-   NL80211_BSS_SIGNAL_MBM,
-   NL80211_BSS_SIGNAL_UNSPEC,
-   NL80211_BSS_STATUS,
-   NL80211_BSS_SEEN_MS_AGO,
-
-   /* keep last */
-   __NL80211_BSS_AFTER_LAST,
-   NL80211_BSS_MAX = __NL80211_BSS_AFTER_LAST - 1
-};
-
-/**
- * enum nl80211_bss_status - BSS "status"
- */
-enum nl80211_bss_status {
-   NL80211_BSS_STATUS_AUTHENTICATED,
-   NL80211_BSS_STATUS_ASSOCIATED,
-   NL80211_BSS_STATUS_IBSS_JOINED,
-};
-
-/**
- * enum nl80211_auth_type - AuthenticationType
- *
- * @NL80211_AUTHTYPE_OPEN_SYSTEM: Open System authentication
- * @NL80211_AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only)
- * @NL80211_AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r)
- * @NL80211_AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP)
- * @__NL80211_AUTHTYPE_NUM: internal
- * @NL80211_AUTHTYPE_MAX: maximum valid auth algorithm
- * @NL80211_AUTHTYPE_AUTOMATIC: determine automatically (if necessary by
- *   trying multiple times); this is invalid in netlink -- leave out
- *   the attribute for this on CONNECT commands.
- */
-enum nl80211_auth_type {
-   NL80211_AUTHTYPE_OPEN_SYSTEM,
-   NL80211_AUTHTYPE_SHARED_KEY,
-   NL80211_AUTHTYPE_FT,
-   NL80211_AUTHTYPE_NETWORK_EAP,
-
-   /* keep last */
-   __NL80211_AUTHTYPE_NUM,
-   NL80211_AUTHTYPE_MAX = __NL80211_AUTHTYPE_NUM - 1,
-   NL80211_AUTHTYPE_AUTOMATIC
-};
-
-/**
- * enum nl80211_key_type - Key Type
- * @NL80211_KEYTYPE_GROUP: Group (broadcast/multicast) key
- * @NL80211_KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key
- * @NL80211_KEYTYPE_PEERKEY: PeerKey (DLS)
- */
-enum nl80211_key_type {
-   NL80211_KEYTYPE_GROUP,
-   NL80211_KEYTYPE_PAIRWISE,
-   NL80211_KEYTYPE_PEERKEY,
-};
-
-/**
- * enum nl80211_mfp - Management frame protection state
- * @NL80211_MFP_NO: Management frame protection not used
- * @NL80211_MFP_REQUIRED: Management frame protection required
- */
-enum nl80211_mfp {
-   NL80211_MFP_NO,
-   NL80211_MFP_REQUIRED,
-};
-
-enum nl80211_wpa_versions {
-   NL80211_WPA_VERSION_1 = 1 << 0,
-   NL80211_WPA_VERSION_2 = 1 << 1,
-};
-
-/**
- * enum nl80211_key_attributes - key attributes
- * @__NL80211_KEY_INVALID: invalid
- * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
- *   16 bytes encryption key followed by 8 bytes each for TX and RX MIC
- *   keys
- * @NL80211_KEY_IDX: key ID (u8, 0-3)
- * @NL80211_KEY_CIPHER: key cipher suite (u32, as defined by IEEE 802.11
- *   section 7.3.2.25.1, e.g. 0x000FAC04)
- * @NL80211_KEY_SEQ: transmit key sequence number (IV/PN) for TKIP and
- *   CCMP keys, each six bytes in little endian
- * @NL80211_KEY_DEFAULT: flag indicating default key
- * @NL80211_KEY_DEFAULT_MGMT: flag indicating default management key
- * @__NL80211_KEY_AFTER_LAST: internal
- * @NL80211_KEY_MAX: highest key attribute
- */
-enum nl80211_key_attributes {
-   __NL80211_KEY_INVALID,
-   NL80211_KEY_DATA,
-   NL80211_KEY_IDX,
-   NL80211_KEY_CIPHER,
-   NL80211_KEY_SEQ,
-   NL80211_KEY_DEFAULT,
-   NL80211_KEY_DEFAULT_MGMT,
-
-   /* keep last */
-   __NL80211_KEY_AFTER_LAST,
-   NL80211_KEY_MAX = __NL80211_KEY_AFTER_LAST - 1
-};
-
-#endif /* __LINUX_NL80211_H */
diff --git a/mac80211/ti-utils/nvs.c b/mac80211/ti-utils/nvs.c
deleted file mode 100644
index 7c55794..0000000
--- a/mac80211/ti-utils/nvs.c
+++ /dev/null
@@ -1,1202 +0,0 @@
-/*
- * PLT utility for wireless chip supported by TI's driver wl12xx
- *
- * See README and COPYING for more details.
- */
-
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdbool.h>
-#include <netinet/in.h>
-#include <time.h>
-
-#include <netlink/netlink.h>
-#include <netlink/msg.h>
-#include <netlink/attr.h>
-#include <linux/wireless.h>
-#include "nl80211.h"
-
-#include "calibrator.h"
-#include "plt.h"
-#include "ini.h"
-/* 2048 - it should be enough for any chip, until... 22dec2010 */
-#define BUF_SIZE_4_NVS_FILE	2048
-
-static const char if_name_fmt[] = "wlan%d";
-
-static char* get_opt_file(int argc, char **argv, char *dir, char *def)
-{
-	char *name = NULL;
-	if (argc < 0)
-		return NULL;
-	else if (argc == 0) {
-		name = def;
-		fprintf(stderr, "\nThe path to input %s file not provided, "
-		       "use default (%s)\n", dir, name);
-	}
-	else
-		name = *argv;
-	return name;
-}
-
-
-char *get_opt_nvsinfile(int argc, char **argv)
-{
-	char *name = get_opt_file(argc, argv, "input", CURRENT_NVS_NAME);
-	if (file_exist(name) < 0) {
-		fprintf(stderr, "File not found %s\n", name);
-		return NULL;
-	}
-	return name;
-}
-
-char *get_opt_nvsoutfile(int argc, char **argv)
-{
-	char *name = get_opt_file(argc, argv, "output", NEW_NVS_NAME);
-	return name;
-}
-
-int nvs_set_mac(char *nvsfile, char *mac)
-{
-	unsigned char mac_buff[12];
-	unsigned char in_mac[6];
-	int fd;
-	unsigned int lower;
-
-	if (mac) {
-		int ret =
-		sscanf(mac, "%2x:%2x:%2x:%2x:%2x:%2x",
-		(unsigned int *)&in_mac[0], (unsigned int *)&in_mac[1],
-		(unsigned int *)&in_mac[2], (unsigned int *)&in_mac[3],
-		(unsigned int *)&in_mac[4], (unsigned int *)&in_mac[5]);
-		if (ret != 6) {
-			fprintf(stderr, "MAC address is not valid: %s\n", mac);
-			return -1;
-		}
-	}
-	else {
-		fprintf(stderr, "No MAC address specified\n");
-		return -1;
-	}
-
-	fd = open(nvsfile, O_RDWR);
-	if (fd < 0) {
-		perror("Error opening file for reading");
-		return 1;
-	}
-
-	read(fd, mac_buff, 12);
-	mac_buff[11] = in_mac[0];
-	mac_buff[10] = in_mac[1];
-	mac_buff[6]  = in_mac[2];
-	mac_buff[5]  = in_mac[3];
-	mac_buff[4]  = in_mac[4];
-	mac_buff[3]  = in_mac[5];
-
-	lseek(fd, 0L, 0);
-
-	/* we need at least two valid NIC addresses */
-	lower = (in_mac[3] << 16) + (in_mac[4] << 8) + in_mac[5];
-	if (lower + 1 > 0xffffff)
-		fprintf(stderr,
-			"WARNING: NIC part of the MAC address wraps around!\n");
-
-	printf("Writing mac address %s to file %s\n", mac, nvsfile);
-	write(fd, mac_buff, 12);
-
-	close(fd);
-	return 0;
-}
-
-
-
-int nvs_fill_radio_params(int fd, struct wl12xx_ini *ini, char *buf)
-{
-	size_t size;
-	struct wl1271_ini *gp;
-
-	if (ini)
-		gp = &ini->ini1271;
-
-	size  = sizeof(struct wl1271_ini);
-
-	if (ini) {	/* for reference NVS */
-		unsigned char *c = (unsigned char *)gp;
-		size_t i;
-
-		for (i = 0; i < size; i++)
-			write(fd, c++, 1);
-	} else {
-		char *p = buf + 0x1D4;
-		write(fd, (const void *)p, size);
-	}
-
-	return 0;
-}
-
-static int nvs_fill_radio_params_128x(int fd, struct wl12xx_ini *ini, char *buf)
-{
-	int size;
-	struct wl128x_ini *gp = &ini->ini128x;
-
-	size  = sizeof(struct wl128x_ini);
-
-	if (ini) {	/* for reference NVS */
-		unsigned char *c = (unsigned char *)gp;
-		int i;
-
-		for (i = 0; i < size; i++)
-			write(fd, c++, 1);
-
-	} else {
-		char *p = buf + 0x1D4;
-		write(fd, p, size);
-	}
-
-	return 0;
-}
-
-int nvs_set_autofem(int fd, char *buf, unsigned char val)
-{
-	size_t size, i;
-	struct wl1271_ini *gp;
-	unsigned char *c;
-
-	if (buf == NULL)
-		return 1;
-
-	gp = (struct wl1271_ini *)(buf+0x1d4);
-	gp->general_params.tx_bip_fem_auto_detect = val;
-
-	size  = sizeof(struct wl1271_ini);
-
-	c = (unsigned char *)gp;
-
-	for (i = 0; i < size; i++)
-		write(fd, c++, 1);
-
-	return 0;
-}
-
-int nvs_set_autofem_128x(int fd, char *buf, unsigned char val)
-{
-	size_t size, i;
-	struct wl128x_ini *gp;
-	unsigned char *c;
-
-	if (buf == NULL)
-		return 1;
-
-	gp = (struct wl128x_ini *)(buf+0x1d4);
-	gp->general_params.tx_bip_fem_auto_detect = val;
-
-	size  = sizeof(struct wl128x_ini);
-
-	c = (unsigned char *)gp;
-
-	for (i = 0; i < size; i++)
-		write(fd, c++, 1);
-
-	return 0;
-}
-
-int nvs_set_fem_manuf(int fd, char *buf, unsigned char val)
-{
-	size_t size, i;
-	struct wl1271_ini *gp;
-	unsigned char *c;
-
-	if (buf == NULL)
-		return 1;
-
-	gp = (struct wl1271_ini *)(buf+0x1d4);
-	gp->general_params.tx_bip_fem_manufacturer = val;
-
-	size  = sizeof(struct wl1271_ini);
-
-	c = (unsigned char *)gp;
-
-	for (i = 0; i < size; i++)
-		write(fd, c++, 1);
-
-	return 0;
-}
-
-int nvs_set_fem_manuf_128x(int fd, char *buf, unsigned char val)
-{
-	size_t size, i;
-	struct wl128x_ini *gp;
-	unsigned char *c;
-
-	if (buf == NULL)
-		return 1;
-
-	gp = (struct wl128x_ini *)(buf+0x1d4);
-	gp->general_params.tx_bip_fem_manufacturer = val;
-
-	size  = sizeof(struct wl128x_ini);
-
-	c = (unsigned char *)gp;
-
-	for (i = 0; i < size; i++)
-		write(fd, c++, 1);
-
-	return 0;
-}
-
-static struct wl12xx_nvs_ops wl1271_nvs_ops = {
-	.nvs_fill_radio_prms = nvs_fill_radio_params,
-	.nvs_set_autofem = nvs_set_autofem,
-	.nvs_set_fem_manuf = nvs_set_fem_manuf,
-};
-
-static struct wl12xx_nvs_ops wl128x_nvs_ops = {
-	.nvs_fill_radio_prms = nvs_fill_radio_params_128x,
-	.nvs_set_autofem = nvs_set_autofem_128x,
-	.nvs_set_fem_manuf = nvs_set_fem_manuf_128x,
-};
-
-int get_mac_addr(int ifc_num, unsigned char *mac_addr)
-{
-	int s;
-	struct ifreq ifr;
-#if 0
-	if (ifc_num < 0 || ifc_num >= ETH_DEV_MAX)
-		return 1;
-#endif
-	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
-	if (s < 0) {
-		fprintf(stderr, "unable to socket (%s)\n", strerror(errno));
-		return 1;
-	}
-
-	memset(&ifr, 0, sizeof(struct ifreq));
-	sprintf(ifr.ifr_name, if_name_fmt, ifc_num) ;
-	if (ioctl(s, SIOCGIFHWADDR, &ifr) < 0) {
-		fprintf(stderr, "unable to ioctl (%s)\n", strerror(errno));
-		close(s);
-		return 1;
-	}
-
-	close(s);
-
-	memcpy(mac_addr, &ifr.ifr_ifru.ifru_hwaddr.sa_data[0], 6);
-
-	return 0;
-}
-
-int file_exist(const char *filename)
-{
-	struct stat buf;
-	int ret;
-
-	if (filename == NULL) {
-		fprintf(stderr, "wrong parameter\n");
-		return -1;
-	}
-
-	ret = stat(filename, &buf);
-	if (ret != 0) {
-		return -1;
-	}
-
-	return (int)buf.st_size;
-}
-
-void cfg_nvs_ops(struct wl12xx_common *cmn)
-{
-	if (cmn->arch == WL1271_ARCH)
-		cmn->nvs_ops = &wl1271_nvs_ops;
-	else
-		cmn->nvs_ops = &wl128x_nvs_ops;
-}
-
-static int read_from_current_nvs(const char *nvs_file,
-	char *buf, int size, int *nvs_sz)
-{
-	int curr_nvs, ret;
-
-	curr_nvs = open(nvs_file, O_RDONLY, S_IRUSR | S_IWUSR);
-	if (curr_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open NVS file for reference "
-			"(%s)\n", __func__, strerror(errno));
-		return 1;
-	}
-
-	ret = read(curr_nvs, buf, size);
-	if (ret < 0) {
-		fprintf(stderr, "Fail to read file %s (%s)", nvs_file,
-			strerror(errno));
-		close(curr_nvs);
-		return 1;
-	}
-
-	if (nvs_sz)
-		*nvs_sz = ret;
-
-	close(curr_nvs);
-
-	//printf("Read NVS file (%s) of size %d\n", nvs_file, ret);
-
-	return 0;
-}
-
-static int read_nvs(const char *nvs_file, char *buf,
-	int size, int *nvs_sz)
-{
-	int fl_sz;
-	fl_sz = file_exist(nvs_file);
-	if (fl_sz < 0) {
-		fprintf(stderr, "File %s not exists\n", nvs_file);
-		return 1;
-	}
-
-	return read_from_current_nvs(nvs_file, buf, size, nvs_sz);
-}
-
-static int fill_nvs_def_rx_params(int fd)
-{
-	unsigned char type = eNVS_RADIO_RX_PARAMETERS;
-	unsigned short length = NVS_RX_PARAM_LENGTH;
-	int i;
-
-	/* Rx type */
-	write(fd, &type, 1);
-
-	/* Rx length */
-	write(fd, &length, 2);
-
-	type = DEFAULT_EFUSE_VALUE; /* just reuse of var */
-	for (i = 0; i < NVS_RX_PARAM_LENGTH; i++)
-		write(fd, &type, 1);
-
-	return 0;
-}
-
-static void nvs_parse_data(const unsigned char *buf,
-	struct wl1271_cmd_cal_p2g *pdata, unsigned int *pver)
-{
-#define BUFFER_INDEX    (buf_idx + START_PARAM_INDEX + info_idx)
-	unsigned short buf_idx;
-	unsigned char tlv_type;
-	unsigned short tlv_len;
-	unsigned short info_idx;
-	unsigned int nvsTypeInfo = 0;
-	unsigned char nvs_ver_oct_idx;
-	unsigned char shift;
-
-	for (buf_idx = 0; buf_idx < NVS_TOTAL_LENGTH;) {
-		tlv_type = buf[buf_idx];
-
-		/* fill the correct mode to fill the NVS struct buffer */
-		/* if the tlv_type is the last type break from the loop */
-		switch (tlv_type) {
-		case eNVS_RADIO_TX_PARAMETERS:
-			nvsTypeInfo = eNVS_RADIO_TX_TYPE_PARAMETERS_INFO;
-			break;
-		case eNVS_RADIO_RX_PARAMETERS:
-			nvsTypeInfo = eNVS_RADIO_RX_TYPE_PARAMETERS_INFO;
-			break;
-		case eNVS_VERSION:
-			for (*pver = 0, nvs_ver_oct_idx = 0;
-				nvs_ver_oct_idx < NVS_VERSION_PARAMETER_LENGTH;
-				nvs_ver_oct_idx++) {
-				shift = 8 * (NVS_VERSION_PARAMETER_LENGTH -
-					1 - nvs_ver_oct_idx);
-				*pver += ((buf[buf_idx + START_PARAM_INDEX +
-					nvs_ver_oct_idx]) << shift);
-			}
-			break;
-		case eTLV_LAST:
-		default:
-			return;
-		}
-
-		tlv_len = (buf[buf_idx + START_LENGTH_INDEX  + 1] << 8) +
-			buf[buf_idx + START_LENGTH_INDEX];
-
-		/* if TLV type is not NVS ver fill the NVS according */
-		/* to the mode TX/RX */
-		if ((eNVS_RADIO_TX_PARAMETERS == tlv_type) ||
-			(eNVS_RADIO_RX_PARAMETERS == tlv_type)) {
-			pdata[nvsTypeInfo].type = tlv_type;
-			pdata[nvsTypeInfo].len = tlv_len;
-
-			for (info_idx = 0; (info_idx < tlv_len) &&
-				(BUFFER_INDEX < NVS_TOTAL_LENGTH);
-					info_idx++) {
-				pdata[nvsTypeInfo].buf[info_idx] =
-					buf[BUFFER_INDEX];
-			}
-		}
-
-		/* increment to the next TLV */
-		buf_idx += START_PARAM_INDEX + tlv_len;
-	}
-}
-
-static int nvs_fill_version(int fd, unsigned int *pdata)
-{
-	unsigned char tmp = eNVS_VERSION;
-	unsigned short tmp2 = NVS_VERSION_PARAMETER_LENGTH;
-
-	write(fd, &tmp, 1);
-
-	write(fd, &tmp2, 2);
-
-	tmp = (*pdata >> 16) & 0xff;
-	write(fd, &tmp, 1);
-
-	tmp = (*pdata >> 8) & 0xff;
-	write(fd, &tmp, 1);
-
-	tmp = *pdata & 0xff;
-	write(fd, &tmp, 1);
-
-	return 0;
-}
-
-static int nvs_fill_old_rx_data(int fd, const unsigned char *buf,
-	unsigned short len)
-{
-	unsigned short idx;
-	unsigned char rx_type;
-
-	/* RX BiP type */
-	rx_type = eNVS_RADIO_RX_PARAMETERS;
-	write(fd, &rx_type, 1);
-
-	/* RX BIP Length */
-	write(fd, &len, 2);
-
-	for (idx = 0; idx < len; idx++)
-		write(fd, &(buf[idx]), 1);
-
-	return 0;
-}
-
-static int nvs_upd_nvs_part(int fd, char *buf)
-{
-	char *p = buf;
-
-	write(fd, p, 0x1D4);
-
-	return 0;
-}
-
-static int nvs_fill_nvs_part(int fd)
-{
-	int i;
-	unsigned char mac_addr[MAC_ADDR_LEN] = {
-		 0x0b, 0xad, 0xde, 0xad, 0xbe, 0xef
-	};
-	__le16 nvs_tx_sz = NVS_TX_PARAM_LENGTH;
-	__le32 nvs_ver = 0x0;
-	const unsigned char vals[] = {
-		0x0, 0x1, 0x6d, 0x54, 0x71, eTLV_LAST, eNVS_RADIO_TX_PARAMETERS
-	};
-
-	write(fd, &vals[1], 1);
-	write(fd, &vals[2], 1);
-	write(fd, &vals[3], 1);
-#if 0
-	if (get_mac_addr(0, mac_addr)) {
-		fprintf(stderr, "%s> Fail to get mac address\n", __func__);
-		return 1;
-	}
-#endif
-	/* write down MAC address in new NVS file */
-	write(fd, &mac_addr[5], 1);
-	write(fd, &mac_addr[4], 1);
-	write(fd, &mac_addr[3], 1);
-	write(fd, &mac_addr[2], 1);
-
-	write(fd, &vals[1], 1);
-	write(fd, &vals[4], 1);
-	write(fd, &vals[3], 1);
-
-	write(fd, &mac_addr[1], 1);
-	write(fd, &mac_addr[0], 1);
-
-	write(fd, &vals[0], 1);
-	write(fd, &vals[0], 1);
-
-	/* fill end burst transaction zeros */
-	for (i = 0; i < NVS_END_BURST_TRANSACTION_LENGTH; i++)
-		write(fd, &vals[0], 1);
-
-	/* fill zeros to Align TLV start address */
-	for (i = 0; i < NVS_ALING_TLV_START_ADDRESS_LENGTH; i++)
-		write(fd, &vals[0], 1);
-
-	/* Fill Tx calibration part */
-	write(fd, &vals[6], 1);
-	write(fd, &nvs_tx_sz, 2);
-
-	for (i = 0; i < nvs_tx_sz; i++)
-		write(fd, &vals[0], 1);
-
-	/* Fill Rx calibration part */
-	fill_nvs_def_rx_params(fd);
-
-	/* fill NVS version */
-	if (nvs_fill_version(fd, &nvs_ver))
-		fprintf(stderr, "Fail to fill version\n");
-
-	/* fill end of NVS */
-	write(fd, &vals[5], 1); /* eTLV_LAST */
-	write(fd, &vals[5], 1); /* eTLV_LAST */
-	write(fd, &vals[0], 1);
-	write(fd, &vals[0], 1);
-
-	return 0;
-}
-
-int prepare_nvs_file(void *arg, char *file_name)
-{
-	int new_nvs, i, nvs_size;
-	unsigned char mac_addr[MAC_ADDR_LEN];
-	struct wl1271_cmd_cal_p2g *pdata;
-	struct wl1271_cmd_cal_p2g old_data[eNUMBER_RADIO_TYPE_PARAMETERS_INFO];
-	char buf[2048];
-	unsigned char *p;
-	struct wl12xx_common cmn = {
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL
-	};
-
-	const unsigned char vals[] = {
-		0x0, 0x1, 0x6d, 0x54, 0x71, eTLV_LAST, eNVS_RADIO_TX_PARAMETERS
-	};
-
-	if (arg == NULL) {
-		fprintf(stderr, "%s> Missing args\n", __func__);
-		return 1;
-	}
-
-	if (read_nvs(file_name, buf, BUF_SIZE_4_NVS_FILE, &nvs_size))
-		return 1;
-
-	switch (nvs_size) {
-		case NVS_FILE_SIZE_127X:
-			cmn.arch = WL1271_ARCH;
-		break;
-		case NVS_FILE_SIZE_128X:
-			cmn.arch = WL128X_ARCH;
-		break;
-		default:
-			fprintf(stderr, "%s> Wrong file size\n", __func__);
-		return 1;
-	}
-
-	cfg_nvs_ops(&cmn);
-
-	/* create new NVS file */
-	new_nvs = open(file_name,
-		O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (new_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open new NVS file\n", __func__);
-		return 1;
-	}
-
-	write(new_nvs, &vals[1], 1);
-	write(new_nvs, &vals[2], 1);
-	write(new_nvs, &vals[3], 1);
-
-	if (get_mac_addr(0, mac_addr)) {
-		fprintf(stderr, "%s> Fail to get mac addr\n", __func__);
-		close(new_nvs);
-		return 1;
-	}
-
-	/* write down MAC address in new NVS file */
-	write(new_nvs, &mac_addr[5], 1);
-	write(new_nvs, &mac_addr[4], 1);
-	write(new_nvs, &mac_addr[3], 1);
-	write(new_nvs, &mac_addr[2], 1);
-
-	write(new_nvs, &vals[1], 1);
-	write(new_nvs, &vals[4], 1);
-	write(new_nvs, &vals[3], 1);
-
-	write(new_nvs, &mac_addr[1], 1);
-	write(new_nvs, &mac_addr[0], 1);
-
-	write(new_nvs, &vals[0], 1);
-	write(new_nvs, &vals[0], 1);
-
-	/* fill end burst transaction zeros */
-	for (i = 0; i < NVS_END_BURST_TRANSACTION_LENGTH; i++)
-		write(new_nvs, &vals[0], 1);
-
-	/* fill zeros to Align TLV start address */
-	for (i = 0; i < NVS_ALING_TLV_START_ADDRESS_LENGTH; i++)
-		write(new_nvs, &vals[0], 1);
-
-	/* Fill TxBip */
-	pdata = (struct wl1271_cmd_cal_p2g *)arg;
-
-	write(new_nvs, &vals[6], 1);
-	write(new_nvs, &pdata->len, 2);
-
-	p = (unsigned char *)&(pdata->buf);
-	for (i = 0; i < pdata->len; i++)
-		write(new_nvs, p++, 1);
-
-	{
-		unsigned int old_ver;
-#if 0
-		{
-			unsigned char *p = (unsigned char *)buf;
-			for (old_ver = 0; old_ver < 1024; old_ver++) {
-				if (old_ver%16 == 0)
-					printf("\n");
-				printf("%02x ", *p++);
-			}
-		}
-#endif
-		memset(old_data, 0,
-			sizeof(struct wl1271_cmd_cal_p2g)*
-				eNUMBER_RADIO_TYPE_PARAMETERS_INFO);
-		nvs_parse_data((const unsigned char *)&buf[NVS_PRE_PARAMETERS_LENGTH],
-			old_data, &old_ver);
-
-		nvs_fill_old_rx_data(new_nvs,
-			old_data[eNVS_RADIO_RX_TYPE_PARAMETERS_INFO].buf,
-			old_data[eNVS_RADIO_RX_TYPE_PARAMETERS_INFO].len);
-	}
-
-	/* fill NVS version */
-	if (nvs_fill_version(new_nvs, &pdata->ver))
-		fprintf(stderr, "Fail to fill version\n");
-
-	/* fill end of NVS */
-	write(new_nvs, &vals[5], 1); /* eTLV_LAST */
-	write(new_nvs, &vals[5], 1); /* eTLV_LAST */
-	write(new_nvs, &vals[0], 1);
-	write(new_nvs, &vals[0], 1);
-
-	/* fill radio params */
-	if (cmn.nvs_ops->nvs_fill_radio_prms(new_nvs, NULL, buf))
-		fprintf(stderr, "Fail to fill radio params\n");
-
-	close(new_nvs);
-
-	return 0;
-}
-
-int create_nvs_file(struct wl12xx_common *cmn)
-{
-	int new_nvs, res = 0;
-	char buf[2048];
-
-	/* create new NVS file */
-	new_nvs = open(cmn->nvs_name,
-		O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (new_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open new NVS file\n", __func__);
-		return 1;
-	}
-
-	/* fill nvs part */
-	if (nvs_fill_nvs_part(new_nvs)) {
-		fprintf(stderr, "Fail to fill NVS part\n");
-		res = 1;
-
-		goto out;
-	}
-
-	/* fill radio params */
-	if (cmn->nvs_ops->nvs_fill_radio_prms(new_nvs, &cmn->ini, buf)) {
-		fprintf(stderr, "Fail to fill radio params\n");
-		res = 1;
-	}
-
-out:
-	close(new_nvs);
-
-	return res;
-}
-
-int update_nvs_file(const char *nvs_infile, const char *nvs_outfile, struct wl12xx_common *cmn)
-{
-	int new_nvs, res = 0;
-	char buf[2048];
-
-	res = read_nvs(nvs_infile, buf, BUF_SIZE_4_NVS_FILE, NULL);
-	if (res)
-		return 1;
-
-	/* create new NVS file */
-	new_nvs = open(nvs_outfile,
-		O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (new_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open new NVS file\n", __func__);
-		return 1;
-	}
-
-	/* fill nvs part */
-	if (nvs_upd_nvs_part(new_nvs, buf)) {
-		fprintf(stderr, "Fail to fill NVS part\n");
-		res = 1;
-
-		goto out;
-	}
-
-	/* fill radio params */
-	if (cmn->nvs_ops->nvs_fill_radio_prms(new_nvs, &cmn->ini, buf)) {
-		printf("Fail to fill radio params\n");
-		res = 1;
-	}
-
-out:
-	close(new_nvs);
-
-	return res;
-}
-
-int dump_nvs_file(const char *nvs_file)
-{
-	int sz=0, size;
-	char buf[2048];
-	unsigned char *p = (unsigned char *)buf;
-
-	if (read_nvs(nvs_file, buf, BUF_SIZE_4_NVS_FILE, &size))
-		return 1;
-
-	printf("\nThe size is %d bytes\n", size);
-
-	for ( ; sz < size; sz++) {
-		if (sz%16 == 0)
-			printf("\n %04X ", sz);
-		printf("%02x ", *p++);
-	}
-	printf("\n");
-
-	return 0;
-}
-
-int set_nvs_file_autofem(const char *nvs_file, unsigned char val,
-	struct wl12xx_common *cmn)
-{
-	int new_nvs, res = 0;
-	char buf[2048];
-	int nvs_file_sz;
-
-	res = read_nvs(nvs_file, buf, BUF_SIZE_4_NVS_FILE, &nvs_file_sz);
-	if (res)
-		return 1;
-
-	if (nvs_get_arch(nvs_file_sz, cmn)) {
-		fprintf(stderr, "Fail to define architecture\n");
-		return 1;
-	}
-
-	cfg_nvs_ops(cmn);
-
-	/* create new NVS file */
-	new_nvs = open(nvs_file,
-		O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (new_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open new NVS file\n", __func__);
-		return 1;
-	}
-
-	/* fill nvs part */
-	if (nvs_upd_nvs_part(new_nvs, buf)) {
-		fprintf(stderr, "Fail to fill NVS part\n");
-		res = 1;
-
-		goto out;
-	}
-
-	/* fill radio params */
-	if (cmn->nvs_ops->nvs_set_autofem(new_nvs, buf, val)) {
-		printf("Fail to fill radio params\n");
-		res = 1;
-	}
-
-out:
-	close(new_nvs);
-
-	return res;
-}
-
-int set_nvs_file_fem_manuf(const char *nvs_file, unsigned char val,
-	struct wl12xx_common *cmn)
-{
-	int new_nvs, res = 0;
-	char buf[2048];
-	int nvs_file_sz;
-
-	res = read_nvs(nvs_file, buf, BUF_SIZE_4_NVS_FILE, &nvs_file_sz);
-	if (res)
-		return 1;
-
-	if (nvs_get_arch(nvs_file_sz, cmn)) {
-		fprintf(stderr, "Fail to define architecture\n");
-		return 1;
-	}
-
-	cfg_nvs_ops(cmn);
-
-	/* create new NVS file */
-	new_nvs = open(nvs_file,
-		O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (new_nvs < 0) {
-		fprintf(stderr, "%s> Unable to open new NVS file\n", __func__);
-		return 1;
-	}
-
-	/* fill nvs part */
-	if (nvs_upd_nvs_part(new_nvs, buf)) {
-		fprintf(stderr, "Fail to fill NVS part\n");
-		res = 1;
-
-		goto out;
-	}
-
-	/* fill radio params */
-	if (cmn->nvs_ops->nvs_set_fem_manuf(new_nvs, buf, val)) {
-		printf("Fail to fill radio params\n");
-		res = 1;
-	}
-
-out:
-	close(new_nvs);
-
-	return res;
-}
-
-static void _print_hexa(char *name, unsigned char *data, size_t len)
-{
-	size_t i;
-
-	printf("%s = ", name);
-	for (i = 0; i < len; i++) {
-		printf("%02X ", *data++);
-	}
-	printf("\n");
-}
-
-#define print_hexa(name, data) _print_hexa(name, data, sizeof(data))
-
-
-static void print_128x_general_params(struct wl128x_ini_general_params *p)
-{
-	printf("# SECTION 1.1: General parameters\n");
-	printf("TXBiPFEMAutoDetect = %02X\n", p->tx_bip_fem_auto_detect);
-	printf("TXBiPFEMManufacturer = %02X\n", p->tx_bip_fem_manufacturer);
-	printf("RefClk = %02X\n", p->ref_clock);
-	printf("SettlingTime = %02X\n", p->settling_time);
-	printf("ClockValidOnWakeup = %02X\n", p->clk_valid_on_wakeup);
-	printf("TCXO_Clk = %02X\n", p->tcxo_ref_clock);
-	printf("TCXO_SettlingTime = %02X\n", p->tcxo_settling_time);
-	printf("TCXO_ClockValidOnWakeup = %02X\n", p->tcxo_valid_on_wakeup);
-	printf("TCXO_LDO_Voltage = %02X\n", p->tcxo_ldo_voltage);
-	printf("Platform_configuration = %02X\n", p->platform_conf);
-	printf("Single_Dual_Band_Solution = %02X\n", p->dual_mode_select);
-	print_hexa("Settings", p->general_settings);
-	printf("XTALItrimVal = %02X\n", p->xtal_itrim_val);
-	printf("SRState = %02X\n", p->sr_state);
-	print_hexa("SRF1", p->srf1);
-	print_hexa("SRF2", p->srf2);
-	print_hexa("SRF3", p->srf3);
-	printf("\n");
-}
-
-static void print_127x_general_params(struct wl1271_ini_general_params *p)
-{
-	printf("# SECTION 1.1: General parameters\n");
-	printf("TXBiPFEMAutoDetect = %02X\n", p->tx_bip_fem_auto_detect);
-	printf("TXBiPFEMManufacturer = %02X\n", p->tx_bip_fem_manufacturer);
-	printf("RefClk = %02X\n", p->ref_clock);
-	printf("SettlingTime = %02X\n", p->settling_time);
-	printf("ClockValidOnWakeup = %02X\n", p->clk_valid_on_wakeup);
-	printf("DC2DCMode = %02X\n", p->dc2dc_mode);
-	printf("Single_Dual_Band_Solution = %02X\n", p->dual_mode_select);
-	printf("Settings = %02X\n", p->general_settings);
-	printf("SRState = %02X\n", p->sr_state);
-	print_hexa("SRF1", p->srf1);
-	print_hexa("SRF2", p->srf2);
-	print_hexa("SRF3", p->srf3);
-	printf("\n");
-}
-
-static void print_127x_band2_params(struct wl1271_ini_band_params_2 *p)
-{
-	printf("# SECTION 1.2.1: 2.4G parameters\n");
-	printf("RxTraceInsertionLoss_2_4G = %02X\n", p->rx_trace_insertion_loss);
-	printf("TXTraceLoss_2_4G = %02X\n", p->tx_trace_loss);
-	print_hexa("RxRssiAndProcessCompensation_2_4G", p->rx_rssi_process_compens);
-	printf("\n");
-}
-
-static void print_128x_band2_params(struct wl128x_ini_band_params_2 *p)
-{
-	printf("# SECTION 1.2.1: 2.4G parameters\n");
-	printf("RxTraceInsertionLoss_2_4G = %02X\n", p->rx_trace_insertion_loss);
-	print_hexa("TXTraceLoss_2_4G", p->tx_trace_loss);
-	printf("\n");
-}
-
-static void print_127x_band5_params(struct wl1271_ini_band_params_5 *p)
-{
-	printf("# SECTION 1.2.2: 5G parameters\n");
-
-	print_hexa("RxTraceInsertionLoss_5G", p->rx_trace_insertion_loss);
-	print_hexa("TXTraceLoss_5G", p->tx_trace_loss);
-	print_hexa("RxRssiAndProcessCompensation_5G", p->rx_rssi_process_compens);
-	printf("\n");
-}
-
-static void print_128x_band5_params(struct wl128x_ini_band_params_5 *p)
-{
-	printf("# SECTION 1.2.2: 5G parameters\n");
-
-	print_hexa("RxTraceInsertionLoss_5G", p->rx_trace_insertion_loss);
-	print_hexa("TXTraceLoss_5G", p->tx_trace_loss);
-	printf("\n");
-}
-
-static void _print_femhexa(char *fem ,char *name, unsigned char *data, int size)
-{
-	printf("%s", fem);
-	_print_hexa(name, data, size);
-}
-
-static void _print_femle16a(char *fem, char *name, __le16 *data, int len)
-{
-	int i;
-
-	printf("%s%s = ", fem, name);
-	for (i = 0; i < len; i++) {
-		printf("%04X ", *data++);
-	}
-	printf("\n");
-}
-
-
-#define print_femhexa(fem, name, data) _print_femhexa(fem, name, data, sizeof(data))
-#define print_femle16a(fem, name, data) _print_femle16a(fem, name, data, sizeof(data) / 2)
-
-static void print_127x_fem_param2(int femnr, struct wl1271_ini_fem_params_2 *p)
-{
-	char fem[6];
-	int ret;
-
-	printf("# SECTION 2.1.1: 2.4G parameters\n");
-
-	ret = snprintf(fem, sizeof(fem), "FEM%d_", femnr);
-	if (ret < 0 || ret >= ((int) sizeof(fem))) {
-		printf("# Invalid FEM numer %d\n", femnr);
-		return;
-	}
-
-	printf("%sTXBiPReferencePDvoltage_2_4G = %04X\n", fem, p->tx_bip_ref_pd_voltage);
-	printf("%sTxBiPReferencePower_2_4G = %02X\n", fem, p->tx_bip_ref_power);
-	printf("%sTxBiPOffsetdB_2_4G = %02X\n", fem, p->tx_bip_ref_offset);
-
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Normal", p->tx_per_rate_pwr_limits_normal);
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Degraded", p->tx_per_rate_pwr_limits_degraded);
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Extreme", p->tx_per_rate_pwr_limits_extreme);
-
-	printf("%sDegradedLowToNormalThr_2_4G = %02X\n", fem, p->degraded_low_to_normal_thr);
-	printf("%sNormalToDegradedHighThr_2_4G = %02X\n", fem, p->normal_to_degraded_high_thr);
-
-	print_femhexa(fem, "TxPerChannelPowerLimits_2_4G_11b", p->tx_per_chan_pwr_limits_11b);
-	print_femhexa(fem, "TxPerChannelPowerLimits_2_4G_OFDM", p->tx_per_chan_pwr_limits_ofdm);
-	print_femhexa(fem, "TxPDVsRateOffsets_2_4G", p->tx_pd_vs_rate_offsets);
-	print_femhexa(fem, "TxIbiasTable_2_4G", p->tx_ibias);
-
-	printf("%sRxFemInsertionLoss_2_4G = %02X\n", fem, p->rx_fem_insertion_loss);
-}
-
-static void print_128x_fem_param2(int femnr, struct wl128x_ini_fem_params_2 *p)
-{
-	char fem[6];
-	sprintf(fem, "FEM%d_", femnr);
-
-	printf("# SECTION 2.1.1: 2.4G parameters\n");
-
-	printf("%sTXBiPReferencePDvoltage_2_4G = %04X\n", fem, p->tx_bip_ref_pd_voltage);
-	printf("%sTxBiPReferencePower_2_4G = %02X\n", fem, p->tx_bip_ref_power);
-	printf("%sTxBiPOffsetdB_2_4G = %02X\n", fem, p->tx_bip_ref_offset);
-
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Normal", p->tx_per_rate_pwr_limits_normal);
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Degraded", p->tx_per_rate_pwr_limits_degraded);
-	print_femhexa(fem, "TxPerRatePowerLimits_2_4G_Extreme", p->tx_per_rate_pwr_limits_extreme);
-
-	printf("%sDegradedLowToNormalThr_2_4G = %02X\n", fem, p->degraded_low_to_normal_thr);
-	printf("%sNormalToDegradedHighThr_2_4G = %02X\n", fem, p->normal_to_degraded_high_thr);
-
-	print_femhexa(fem, "TxPerChannelPowerLimits_2_4G_11b", p->tx_per_chan_pwr_limits_11b);
-	print_femhexa(fem, "TxPerChannelPowerLimits_2_4G_OFDM", p->tx_per_chan_pwr_limits_ofdm);
-	print_femhexa(fem, "TxPDVsRateOffsets_2_4G", p->tx_pd_vs_rate_offsets);
-	print_femhexa(fem, "TxPDVsChannelOffsets_2_4G", p->tx_pd_vs_chan_offsets);
-	print_femhexa(fem, "TxPDVsTemperature_2_4G", p->tx_pd_vs_temperature);
-	print_femhexa(fem, "TxIbiasTable_2_4G", p->tx_ibias);
-
-	printf("%sRxFemInsertionLoss_2_4G = %02X\n", fem, p->rx_fem_insertion_loss);
-}
-
-static void print_127x_fem_param5(int femnr, struct wl1271_ini_fem_params_5 *p)
-{
-	char fem[6];
-	sprintf(fem, "FEM%d_", femnr);
-
-	printf("# SECTION 2.1.2: 5G parameters\n");
-
-	print_femle16a(fem, "TxBiPReferencePDvoltage_5G", p->tx_bip_ref_pd_voltage);
-
-	print_femhexa(fem, "TxBiPReferencePower_5G", p->tx_bip_ref_power);
-	print_femhexa(fem, "TxBiPOffsetdB_5G", p->tx_bip_ref_offset);
-
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Normal", p->tx_per_rate_pwr_limits_normal);
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Degraded", p->tx_per_rate_pwr_limits_degraded);
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Extreme", p->tx_per_rate_pwr_limits_extreme);
-
-	printf("%sDegradedLowToNormalThr_5G = %02X\n", fem, p->degraded_low_to_normal_thr);
-	printf("%sNormalToDegradedHighThr_5G = %02X\n", fem, p->normal_to_degraded_high_thr);
-
-	print_femhexa(fem, "TxPerChannelPowerLimits_5G_OFDM", p->tx_per_chan_pwr_limits_ofdm);
-	print_femhexa(fem, "TxPDVsRateOffsets_5G", p->tx_pd_vs_rate_offsets);
-	print_femhexa(fem, "TxIbiasTable_5G", p->tx_ibias);
-	print_femhexa(fem, "RxFemInsertionLoss_5G", p->rx_fem_insertion_loss);
-}
-
-static void print_128x_fem_param5(int femnr, struct wl128x_ini_fem_params_5 *p)
-{
-	char fem[6];
-	sprintf(fem, "FEM%d_", femnr);
-
-	printf("# SECTION 2.1.2: 5G parameters\n");
-
-	print_femle16a(fem, "TxBiPReferencePDvoltage_5G", p->tx_bip_ref_pd_voltage);
-
-	print_femhexa(fem, "TxBiPReferencePower_5G", p->tx_bip_ref_power);
-	print_femhexa(fem, "TxBiPOffsetdB_5G", p->tx_bip_ref_offset);
-
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Normal", p->tx_per_rate_pwr_limits_normal);
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Degraded", p->tx_per_rate_pwr_limits_degraded);
-	print_femhexa(fem, "TxPerRatePowerLimits_5G_Extreme", p->tx_per_rate_pwr_limits_extreme);
-
-	printf("%sDegradedLowToNormalThr_5G = %02X\n", fem, p->degraded_low_to_normal_thr);
-	printf("%sNormalToDegradedHighThr_5G = %02X\n", fem, p->normal_to_degraded_high_thr);
-
-	print_femhexa(fem, "TxPerChannelPowerLimits_5G_OFDM", p->tx_per_chan_pwr_limits_ofdm);
-	print_femhexa(fem, "TxPDVsRateOffsets_5G", p->tx_pd_vs_rate_offsets);
-	print_femhexa(fem, "TxPDVsChannelOffsets_5G", p->tx_pd_vs_chan_offsets);
-	print_femhexa(fem, "TxPDVsTemperature_5G", p->tx_pd_vs_temperature);
-	print_femhexa(fem, "TxIbiasTable_5G", p->tx_ibias);
-	print_femhexa(fem, "RxFemInsertionLoss_5G", p->rx_fem_insertion_loss);
-}
-
-int get_fem_nr(int autodetect, int manuf, int *femcnt, int *femi)
-{
-	if (autodetect) {
-		printf("#Fem autodetect is on. Showing both FEM datas\n");
-		*femcnt = 2;
-		*femi = 0;
-	}
-	else {
-		*femcnt = 1;
-		if(manuf >= WL1271_INI_FEM_MODULE_COUNT) {
-			fprintf(stderr, "FEM index out of bounds (%d > %d)\n", manuf, WL1271_INI_FEM_MODULE_COUNT);
-			return 1;
-		}
-
-		*femi = manuf;
-		printf("#Fem autodetect is off. Fem nr used is %d\n", *femi);
-	}
-	return 0;
-}
-
-
-
-int info_nvs_file(const char *nvs_file)
-{
-	char buf[BUF_SIZE_4_NVS_FILE];
-	int ret, i, femi, femcnt, maxfem;
-
-	int fd =  open(nvs_file, O_RDONLY, S_IRUSR | S_IWUSR);
-	if (fd < 0) {
-		fprintf(stderr, "Unable to open NVS %s ", nvs_file);
-		return 1;
-	}
-
-	ret = read(fd, buf, BUF_SIZE_4_NVS_FILE);
-	if (ret < 0) {
-		fprintf(stderr, "Fail to read file %s (%s)", nvs_file,
-			strerror(errno));
-		close(fd);
-		return 1;
-	}
-	close(fd);
-
-	if (ret == sizeof(struct wl1271_nvs_file)) {
-		struct wl1271_nvs_file *nvs = (struct wl1271_nvs_file *) &buf;
-		printf("#Chip is 127x\n");
-		print_127x_general_params(&nvs->general_params);
-		print_127x_band2_params(&nvs->stat_radio_params_2);
-		if (nvs->general_params.dual_mode_select)
-			print_127x_band5_params(&nvs->stat_radio_params_5);
-
-		if( get_fem_nr(nvs->general_params.tx_bip_fem_auto_detect,
-		               nvs->general_params.tx_bip_fem_manufacturer,
-		               &femcnt, &femi))
-			return 1;
-
-		maxfem = femcnt + femi;
-		for (i = femi; i < maxfem; i++) {
-			print_127x_fem_param2(i, &nvs->dyn_radio_params_2[i].params);
-			printf("\n");
-
-			if (nvs->general_params.dual_mode_select == 1) {
-				print_127x_fem_param5(femi, &nvs->dyn_radio_params_5[i].params);
-				printf("\n");
-			}
-			femi++;
-		}
-	}
-	else if (ret == sizeof(struct wl128x_nvs_file)) {
-		struct wl128x_nvs_file *nvs = (struct wl128x_nvs_file *) &buf;
-		printf("#Chip is 128x\n");
-		print_128x_general_params(&nvs->general_params);
-		print_128x_band2_params(&nvs->stat_radio_params_2);
-		if (nvs->general_params.dual_mode_select)
-			print_128x_band5_params(&nvs->stat_radio_params_5);
-
-		printf("# SECTION 2.1:   FEM parameters\n");
-		printf("FemVendorAndOptions = %02X\n\n", nvs->fem_vendor_and_options);
-
-		if( get_fem_nr(nvs->general_params.tx_bip_fem_auto_detect,
-		               nvs->general_params.tx_bip_fem_manufacturer,
-		               &femcnt, &femi))
-			return 1;
-
-		maxfem = femcnt + femi;
-		for (i = femi; i < maxfem; i++) {
-			print_128x_fem_param2(femi, &nvs->dyn_radio_params_2[femi].params);
-			printf("\n");
-			if (nvs->general_params.dual_mode_select == 1) {
-				print_128x_fem_param5(femi, &nvs->dyn_radio_params_5[femi].params);
-				printf("\n");
-			}
-			femi++;
-		}
-	}
-	else {
-		fprintf(stderr, "Invalid file size %d. Unable to detect chip type\n", ret);
-		return 0;
-	}
-
-	return 0;
-}
-
diff --git a/mac80211/ti-utils/nvs.h b/mac80211/ti-utils/nvs.h
deleted file mode 100644
index 481fbe2..0000000
--- a/mac80211/ti-utils/nvs.h
+++ /dev/null
@@ -1,31 +0,0 @@
-#ifndef __NVS_H
-#define __NVS_H
-
-#define WL127X_NVS_FILE_SZ		912
-#define WL128X_NVS_FILE_SZ		1113
-
-char *get_opt_nvsinfile(int argc, char **argv);
-char *get_opt_nvsoutfile(int argc, char **argv);
-
-int prepare_nvs_file(void *arg, char *file_name);
-
-int nvs_set_mac(char *nvsfile, char *mac);
-
-void cfg_nvs_ops(struct wl12xx_common *cmn);
-
-int create_nvs_file(struct wl12xx_common *cmn);
-
-int update_nvs_file(const char *nvs_infile, const char *nvs_outfile,
-	struct wl12xx_common *cmn);
-
-int dump_nvs_file(const char *nvs_file);
-
-int set_nvs_file_autofem(const char *nvs_file, unsigned char val,
-	struct wl12xx_common *cmn);
-
-int set_nvs_file_fem_manuf(const char *nvs_file, unsigned char val,
-	struct wl12xx_common *cmn);
-
-int info_nvs_file(const char *nvs_file);
-
-#endif /* __NVS_H */
diff --git a/mac80211/ti-utils/plt.c b/mac80211/ti-utils/plt.c
deleted file mode 100644
index f0adc58..0000000
--- a/mac80211/ti-utils/plt.c
+++ /dev/null
@@ -1,1343 +0,0 @@
-/*
- * PLT utility for wireless chip supported by TI's driver wl12xx
- *
- * See README and COPYING for more details.
- */
-
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdbool.h>
-
-#include <netlink/genl/genl.h>
-#include <netlink/genl/family.h>
-#include <netlink/genl/ctrl.h>
-#include <netlink/msg.h>
-#include <netlink/attr.h>
-#include <linux/wireless.h>
-#include <linux/ethtool.h>
-#include "nl80211.h"
-
-#include "calibrator.h"
-#include "plt.h"
-#include "ini.h"
-#include "nvs.h"
-
-#define ZERO_MAC	"00:00:00:00:00:00"
-
-#ifndef SIOCETHTOOL
-#define SIOCETHTOOL     0x8946
-#endif
-
-SECTION(plt);
-
-#define CMDBUF_SIZE 200
-static int insmod(char *filename)
-{
-	int ret;
-	char cmd[CMDBUF_SIZE];
-	snprintf(cmd, CMDBUF_SIZE, "%s %s", INSMOD_PATH, filename);
-	ret = system(cmd);
-	if (ret)
-		fprintf(stderr, "Failed to load kernel module using command %s\n", cmd);
-	return ret;
-}
-
-static int rmmod(char *name)
-{
-	char cmd[CMDBUF_SIZE];
-	char *tmp;
-	int i, ret;
-
-	/* "basename" */
-	tmp = strrchr(name, '/');
-	if (!tmp)
-		tmp = name;
-	else
-		tmp++;
-
-	tmp = strdup(tmp);
-	if (!tmp)
-		return -ENOMEM;
-
-	/* strip trailing .ko if there */
-	i = strlen(tmp);
-	if (i < 4) {
-		ret = -EINVAL;
-		goto out;
-	}
-	if (!strcmp(tmp + i - 3, ".ko"))
-		tmp[i-3] = 0;
-
-	snprintf(cmd, CMDBUF_SIZE, "%s %s", RMMOD_PATH, tmp);
-	ret = system(cmd);
-	if (ret)
-		fprintf(stderr, "Failed to remove kernel module using command %s\n", cmd);
-out:
-	free(tmp);
-	return ret;
-}
-
-static int plt_power_mode(struct nl80211_state *state, struct nl_cb *cb,
-			  struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	unsigned int pmode;
-
-	if (argc != 1) {
-		fprintf(stderr, "%s> Missing arguments\n", __func__);
-		return 2;
-	}
-
-	if (strcmp(argv[0], "on") == 0)
-		pmode = 1;
-	else if (strcmp(argv[0], "off") == 0)
-		pmode = 0;
-	else {
-		fprintf(stderr, "%s> Invalid parameter\n", __func__);
-		return 2;
-	}
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_SET_PLT_MODE);
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_PLT_MODE, pmode);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, power_mode, "<on|off>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_power_mode,
-	"Set PLT power mode\n");
-
-static int plt_tune_channel(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_cal_channel_tune prms;
-
-	if (argc < 1 || argc > 2)
-		return 1;
-
-	prms.test.id = TEST_CMD_CHANNEL_TUNE;
-	prms.band = (unsigned char)atoi(argv[0]);
-	prms.channel = (unsigned char)atoi(argv[1]);
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA,
-		sizeof(struct wl1271_cmd_cal_channel_tune),
-		&prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, tune_channel, "<band> <channel>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_tune_channel,
-	"Set band and channel for PLT\n");
-
-static int plt_ref_point(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_cal_update_ref_point prms;
-
-	if (argc < 1 || argc > 3)
-		return 1;
-
-	prms.test.id = TEST_CMD_UPDATE_PD_REFERENCE_POINT;
-	prms.ref_detector = atoi(argv[0]);
-	prms.ref_power = atoi(argv[1]);
-	prms.sub_band = atoi(argv[2]);
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, ref_point, "<voltage> <power> <subband>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_ref_point,
-	"Set reference point for PLT\n");
-
-static int calib_valid_handler(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nlattr *td[WL1271_TM_ATTR_MAX + 1];
-	struct wl1271_cmd_cal_p2g *prms;
-#if 0
-	int i; unsigned char *pc;
-#endif
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	nla_parse(td, WL1271_TM_ATTR_MAX, nla_data(tb[NL80211_ATTR_TESTDATA]),
-		nla_len(tb[NL80211_ATTR_TESTDATA]), NULL);
-
-	prms = (struct wl1271_cmd_cal_p2g *)nla_data(td[WL1271_TM_ATTR_DATA]);
-
-	if (prms->radio_status) {
-		fprintf(stderr, "Fail to calibrate ith radio status (%d)\n",
-			(signed short)prms->radio_status);
-		return 2;
-	}
-#if 0
-	printf("%s> id %04x status %04x\ntest id %02x ver %08x len %04x=%d\n",
-		__func__,
-		prms->header.id, prms->header.status, prms->test.id,
-		prms->ver, prms->len, prms->len);
-
-		pc = (unsigned char *)prms->buf;
-		printf("++++++++++++++++++++++++\n");
-		for (i = 0; i < prms->len; i++) {
-			if (i%0xf == 0)
-				printf("\n");
-
-			printf("%02x ", *(unsigned char *)pc);
-			pc += 1;
-		}
-		printf("++++++++++++++++++++++++\n");
-#endif
-	printf("Writing calibration data to %s\n", (char*) arg);
-	if (prepare_nvs_file(prms, arg)) {
-		fprintf(stderr, "Fail to prepare calibrated NVS file\n");
-		return 2;
-	}
-#if 0
-	printf("\n\tThe NVS file (%s) is ready\n\tCopy it to %s and "
-		"reboot the system\n\n",
-		NEW_NVS_NAME, CURRENT_NVS_NAME);
-#endif
-	return NL_SKIP;
-}
-
-static void dump_regs(struct ethtool_drvinfo *info, struct ethtool_regs *regs)
-{
-	printf("\n\tDriver %s\n\t"
-		   "version %s\n\t"
-		   "FW version %s\n\t"
-		   "Bus info %s\n\t"
-		   "HW version 0x%X\n",
-		info->driver, info->version,
-		info->fw_version, info->bus_info, regs->version);
-}
-
-int do_get_drv_info(char *dev_name, int *hw_ver)
-{
-	struct ifreq ifr;
-	int fd, err;
-	struct ethtool_drvinfo drvinfo;
-	struct ethtool_regs *regs;
-
-	memset(&ifr, 0, sizeof(ifr));
-	strcpy(ifr.ifr_name, dev_name);
-
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		fprintf(stderr, "Cannot get control socket\n");
-		return 1;
-	}
-
-	drvinfo.cmd = ETHTOOL_GDRVINFO;
-	ifr.ifr_data = (caddr_t)&drvinfo;
-	err = ioctl(fd, SIOCETHTOOL, &ifr);
-	if (err < 0) {
-		fprintf(stderr, "Cannot get driver information\n");
-		goto error_out;
-	}
-
-	regs = calloc(1, sizeof(*regs)+drvinfo.regdump_len);
-	if (!regs) {
-		fprintf(stderr, "Cannot allocate memory for register dump\n");
-		goto error_out;
-	}
-
-	regs->cmd = ETHTOOL_GREGS;
-	regs->len = drvinfo.regdump_len;
-	ifr.ifr_data = (caddr_t)regs;
-	err = ioctl(fd, SIOCETHTOOL, &ifr);
-	if (err < 0) {
-		fprintf(stderr, "Cannot get register dump\n");
-		goto error_out2;
-	}
-
-	if (hw_ver)
-		*hw_ver = regs->version;
-	else
-		dump_regs(&drvinfo, regs);
-	free(regs);
-
-	return 0;
-
-error_out2:
-	free(regs);
-
-error_out:
-	close(fd);
-
-	return 1;
-}
-
-static int get_chip_arch(char *dev_name, enum wl12xx_arch *arch)
-{
-	int hw_ver, ret;
-
-	ret = do_get_drv_info(dev_name, &hw_ver);
-	if (ret)
-		return 1;
-
-	*arch = hw_ver >> 16;
-
-	return 0;
-}
-
-static int do_nvs_ver21(struct nl_msg *msg, enum wl12xx_arch arch)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_set_nvs_ver prms;
-
-	memset(&prms, 0, sizeof(struct wl1271_cmd_set_nvs_ver));
-
-	if (arch == WL1271_ARCH)
-		prms.test.id = TEST_CMD_SET_NVS_VERSION;
-	else if(arch == WL128X_ARCH)
-		prms.test.id = TEST_CMD_SET_NVS_VERSION - 1;
-	else {
-		fprintf(stderr, "Unkown arch %x\n", arch);
-		return 1;
-	}
-
-	prms.nvs_ver = NVS_VERSION_2_1;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-
-static int plt_nvs_ver(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	enum wl12xx_arch arch = UNKNOWN_ARCH;
-	int ret;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing device name\n");
-		return 2;
-	}
-
-	ret = get_chip_arch(argv[0], &arch);
-	if (ret || (arch == UNKNOWN_ARCH)) {
-		fprintf(stderr, "Unknown chip arch\n");
-		return 2;
-	}
-
-	return do_nvs_ver21(msg, arch);
-}
-
-COMMAND(plt, nvs_ver, "<device name>",
-	NL80211_CMD_TESTMODE, 0, CIB_PHY, plt_nvs_ver,
-	"Set NVS version\n");
-
-
-static int plt_nvs_ver2(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	enum wl12xx_arch arch = UNKNOWN_ARCH;
-	int ret;
-
-	if (argc < 1) {
-		fprintf(stderr, "Missing device name\n");
-		return 2;
-	}
-
-	ret = sscanf(argv[0], "%x", &arch);
-	if(ret != 1) {
-		fprintf(stderr, "Unknown chip arch\n");
-		return 2;
-	}
-
-	return do_nvs_ver21(msg, arch);
-}
-
-COMMAND(plt, nvs_ver, "<arch>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_nvs_ver2,
-	"Set NVS version\n");
-
-static int plt_tx_bip(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_cal_p2g prms;
-	int i;
-	char nvs_path[PATH_MAX];
-
-	if (argc < 8) {
-		fprintf(stderr, "%s> Missing arguments\n", __func__);
-		return 2;
-	}
-
-	if (argc > 8)
-		strncpy(nvs_path, argv[8], strlen(argv[8]));
-	else
-		nvs_path[0] = '\0';
-
-	memset(&prms, 0, sizeof(struct wl1271_cmd_cal_p2g));
-
-	prms.test.id = TEST_CMD_P2G_CAL;
-	for (i = 0; i < 8; i++)
-		prms.sub_band_mask |= (atoi(argv[i]) & 0x1)<<i;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-	NLA_PUT_U8(msg, WL1271_TM_ATTR_ANSWER, 1);
-
-	nla_nest_end(msg, key);
-
-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, calib_valid_handler, nvs_path);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, tx_bip,
-	"<0|1> <0|1> <0|1> <0|1> <0|1> <0|1> <0|1> <0|1> [<nvs file>]",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_tx_bip,
-	"Do calibrate\n");
-
-static int plt_tx_tone(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_cal_tx_tone prms;
-
-	if (argc < 2) {
-		fprintf(stderr, "%s> Missing arguments\n", __func__);
-		return 2;
-	}
-
-	memset(&prms, 0, sizeof(struct wl1271_cmd_cal_tx_tone));
-
-	prms.test.id = TEST_CMD_TELEC;
-
-	prms.tone_type = atoi(argv[0]);
-	if (prms.tone_type < 1 || prms.tone_type > 2) {
-		fprintf(stderr, "%s> Invalit tone type parameter %d\n",
-			__func__, prms.tone_type);
-		return 2;
-	}
-
-	prms.power = atoi(argv[1]);
-	if (prms.power > 10000) {
-		fprintf(stderr, "%s> Invalit power parameter %d\n",
-			__func__, prms.power);
-		return 2;
-	}
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, tx_tone, "<tone type 1|2> <power 0 - 10000>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_tx_tone,
-	"Do command tx_tone to transmit a tone\n");
-
-static int plt_tx_cont(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_pkt_params prms = {
-		.src_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
-	};
-
-	if (argc != 15)
-		return 1;
-#if 0
-	printf("%s> delay (%d) rate (%08x) size (%d) amount (%d) power (%d) "
-		"seed (%d) pkt_mode (%d) DCF (%d) GI (%d) preamble (%d) type "
-		"(%d) scramble (%d) CLPC (%d), SeqNbrMode (%d) DestMAC (%s)\n",
-		__func__,
-		atoi(argv[0]),  atoi(argv[1]),  atoi(argv[2]),  atoi(argv[3]),
-		atoi(argv[4]),  atoi(argv[5]),  atoi(argv[6]),  atoi(argv[7]),
-		atoi(argv[8]),  atoi(argv[9]),  atoi(argv[10]), atoi(argv[11]),
-		atoi(argv[12]), atoi(argv[13]), argv[14]
-	);
-#endif
-	memset((void *)&prms, 0, sizeof(struct wl1271_cmd_pkt_params));
-
-	prms.test.id = TEST_CMD_FCC;
-	prms.delay = atoi(argv[0]);
-	prms.rate = strtol(argv[1], NULL, 0);
-	prms.size = (unsigned short)atoi(argv[2]);
-	prms.amount = (unsigned short)atoi(argv[3]);
-	prms.power = atoi(argv[4]);
-	prms.seed = (unsigned short)atoi(argv[5]);
-	prms.pkt_mode = (unsigned char)atoi(argv[6]);
-	prms.dcf_enable = (unsigned char)atoi(argv[7]);
-	prms.g_interval = (unsigned char)atoi(argv[8]);
-	prms.preamble = (unsigned char)atoi(argv[9]);
-	prms.type = (unsigned char)atoi(argv[10]);
-	prms.scramble = (unsigned char)atoi(argv[11]);
-	prms.clpc_enable = (unsigned char)atoi(argv[12]);
-	prms.seq_nbr_mode = (unsigned char)atoi(argv[13]);
-	str2mac(prms.dst_mac, argv[14]);
-
-	if (get_mac_addr(0, prms.src_mac))
-		fprintf(stderr, "fail to get MAC addr\n");
-
-	printf("%02X:%02X:%02X:%02X:%02X:%02X\n",
-		prms.src_mac[0], prms.src_mac[1], prms.src_mac[2],
-		prms.src_mac[3], prms.src_mac[4], prms.src_mac[5]);
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, tx_cont, "<delay> <rate> <size> <amount> <power>\n\t\t<seed> "
-	"<pkt mode> <DC on/off> <gi> <preamble>\n\t\t<type> <scramble> "
-	"<clpc> <seq nbr mode> <dest mac>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_tx_cont,
-	"Start Tx Cont\n");
-
-static int plt_tx_stop(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_pkt_params prms;
-
-	prms.test.id = TEST_CMD_STOP_TX;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, tx_stop, NULL,
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_tx_stop,
-	"Stop Tx Cont\n");
-
-static int plt_start_rx_statcs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_pkt_params prms;
-
-	prms.test.id = TEST_CMD_RX_STAT_START;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, start_rx_statcs, NULL,
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_start_rx_statcs,
-	"Start Rx statistics collection\n");
-
-static int plt_stop_rx_statcs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_pkt_params prms;
-
-	prms.test.id = TEST_CMD_RX_STAT_STOP;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, stop_rx_statcs, NULL,
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_stop_rx_statcs,
-	"Stop Rx statistics collection\n");
-
-static int plt_reset_rx_statcs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_cmd_pkt_params prms;
-
-	prms.test.id = TEST_CMD_RX_STAT_RESET;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, reset_rx_statcs, NULL,
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_reset_rx_statcs,
-	"Reset Rx statistics collection\n");
-
-static int display_rx_statcs(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nlattr *td[WL1271_TM_ATTR_MAX + 1];
-	struct wl1271_radio_rx_statcs *prms;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	nla_parse(td, WL1271_TM_ATTR_MAX, nla_data(tb[NL80211_ATTR_TESTDATA]),
-		nla_len(tb[NL80211_ATTR_TESTDATA]), NULL);
-
-	prms =
-		(struct wl1271_radio_rx_statcs *)
-			nla_data(td[WL1271_TM_ATTR_DATA]);
-
-	printf("\n\tTotal number of pkts\t- %d\n\tAccepted pkts\t\t- %d\n\t"
-		"FCS error pkts\t\t- %d\n\tAddress mismatch pkts\t- %d\n\t"
-		"Average SNR\t\t- % d dBm\n\tAverage RSSI\t\t- % d dBm\n\n",
-		prms->base_pkt_id, prms->rx_path_statcs.nbr_rx_valid_pkts,
-		prms->rx_path_statcs.nbr_rx_fcs_err_pkts,
-		prms->rx_path_statcs.nbr_rx_plcp_err_pkts,
-		(signed short)prms->rx_path_statcs.ave_snr/8,
-		(signed short)prms->rx_path_statcs.ave_rssi/8);
-
-	return NL_SKIP;
-}
-
-static int plt_get_rx_statcs(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl1271_radio_rx_statcs prms;
-
-	prms.test.id = TEST_CMD_RX_STAT_GET;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-	NLA_PUT_U8(msg, WL1271_TM_ATTR_ANSWER, 1);
-
-	nla_nest_end(msg, key);
-
-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, display_rx_statcs, NULL);
-
-	/* Important: needed gap between tx_start and tx_get */
-	sleep(2);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(plt, get_rx_statcs, NULL,
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_get_rx_statcs,
-	"Get Rx statistics\n");
-
-static int plt_rx_statistics(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	int ret;
-
-	/* power mode on */
-	{
-		char *prms[4] = { "wlan0", "plt", "power_mode", "on" };
-
-		ret = handle_cmd(state, II_NETDEV, 4, prms);
-		if (ret < 0) {
-			fprintf(stderr, "Fail to set PLT power mode on\n");
-			return 1;
-		}
-	}
-
-	/* start_rx_statcs */
-	{
-		char *prms[3] = { "wlan0", "plt", "start_rx_statcs" };
-
-		ret = handle_cmd(state, II_NETDEV, 3, prms);
-		if (ret < 0) {
-			fprintf(stderr, "Fail to start Rx statistics\n");
-			goto fail_out;
-		}
-	}
-
-	/* get_rx_statcs */
-	{
-		int err;
-		char *prms[3] = { "wlan0", "plt", "get_rx_statcs" };
-
-		err = handle_cmd(state, II_NETDEV, 3, prms);
-		if (err < 0) {
-			fprintf(stderr, "Fail to get Rx statistics\n");
-			ret = err;
-		}
-	}
-
-
-	/* stop_rx_statcs */
-	{
-		int err;
-		char *prms[3] = { "wlan0", "plt", "stop_rx_statcs" };
-
-		err = handle_cmd(state, II_NETDEV, 3, prms);
-		if (err < 0) {
-			fprintf(stderr, "Fail to stop Rx statistics\n");
-			ret = err;
-		}
-	}
-
-fail_out:
-	/* power mode off */
-	{
-		int err;
-		char *prms[4] = { "wlan0", "plt", "power_mode", "off"};
-
-		err = handle_cmd(state, II_NETDEV, 4, prms);
-		if (err < 0) {
-			fprintf(stderr, "Fail to set PLT power mode on\n");
-			return 1;
-		}
-	}
-
-	if (ret < 0)
-		return 1;
-
-	return 0;
-}
-
-COMMAND(plt, rx_statistics, NULL, 0, 0, CIB_NONE, plt_rx_statistics,
-	"Get Rx statistics\n");
-
-static int plt_do_power_on(struct nl80211_state *state, char *devname)
-{
-	int err;
-	char *pm_on[4] = { devname, "plt", "power_mode", "on" };
-
-	err = handle_cmd(state, II_NETDEV, ARRAY_SIZE(pm_on), pm_on);
-	if (err < 0)
-		fprintf(stderr, "Fail to set PLT power mode on\n");
-
-	return err;
-}
-
-static int plt_do_power_off(struct nl80211_state *state, char *devname)
-{
-	int err;
-	char *prms[4] = { devname, "plt", "power_mode", "off"};
-
-	err = handle_cmd(state, II_NETDEV, ARRAY_SIZE(prms), prms);
-	if (err < 0)
-		fprintf(stderr, "Failed to set PLT power mode on\n");
-
-	return err;
-}
-
-
-static int plt_do_calibrate(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int single_dual, char *nvs_file,
-			char *devname, enum wl12xx_arch arch)
-{
-	int ret = 0, err;
-
-	/* tune channel */
-	{
-		char *tune[5] = {
-			devname, "plt", "tune_channel", "0", "7"
-		};
-
-		err = handle_cmd(state, II_NETDEV, ARRAY_SIZE(tune), tune);
-		if (err < 0) {
-			fprintf(stderr, "Fail to tune channel\n");
-			ret = err;
-			goto fail_out;
-		}
-	}
-
-	/* Set nvs version 2.1 */
-	if (arch == UNKNOWN_ARCH) {
-		fprintf(stderr, "Unknown arch. Not setting nvs ver 2.1");
-	}
-	else {
-		size_t ret;
-		char archstr[5] = "";
-		char *prms[4] = {
-			"wlan0", "plt", "nvs_ver", archstr
-		};
-
-		ret = snprintf(archstr, sizeof(archstr), "%x", arch);
-		if (ret > sizeof(archstr)) {
-			fprintf(stderr, "Bad arch\n");
-			goto fail_out;
-		}
-
-		printf("Using nvs version 2.1\n");
-		err = handle_cmd(state, II_NETDEV, 4, prms);
-		if (err < 0) {
-			fprintf(stderr, "Fail to set nvs ver 2.1\n");
-			ret = err;
-		}
-	}
-
-	/* calibrate it */
-	{
-		char *prms[12] = {
-			devname, "plt", "tx_bip", "1", "0", "0", "0",
-			"0", "0", "0", "0", nvs_file
-		};
-		printf("Calibrate %s\n", nvs_file);
-
-		/* set flags in case of dual band */
-		if (single_dual) {
-			prms[4] = prms[5] = prms[6] = prms[7] = prms[8] =
-				prms[9] = prms[10] = "1";
-		}
-
-		err = handle_cmd(state, II_NETDEV, ARRAY_SIZE(prms), prms);
-		if (err < 0) {
-			fprintf(stderr, "Failed to calibrate\n");
-			ret = err;
-		}
-	}
-
-fail_out:
-	if (ret < 0)
-		return 1;
-
-	return 0;
-}
-
-static int plt_calibrate(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	int ret, err;
-	int single_dual = 0;
-
-	if (argc > 2 && (strncmp(argv[2], "dual", 4) ==  0))
-		single_dual = 1;	/* going for dual band calibration */
-	else
-		single_dual = 0;	/* going for single band calibration */
-
-
-	err = plt_do_power_on(state, "wlan0");
-	if (err < 0)
-		goto out;
-
-	err = plt_do_calibrate(state, cb, msg, single_dual, NEW_NVS_NAME,
-			       "wlan0", UNKNOWN_ARCH);
-
-	ret = plt_do_power_off(state, "wlan0");
-	if (ret < 0)
-		err = ret;
-out:
-	return err;
-}
-
-COMMAND(plt, calibrate, "[<single|dual>]", 0, 0, CIB_NONE,
-	plt_calibrate, "Do calibrate for single or dual band chip\n");
-
-
-static int plt_autocalibrate(struct nl80211_state *state, struct nl_cb *cb,
-			struct nl_msg *msg, int argc, char **argv)
-{
-	struct wl12xx_common cmn = {
-		.auto_fem = 0,
-		.arch = UNKNOWN_ARCH,
-		.parse_ops = NULL,
-	};
-
-	char *devname, *modpath, *inifile1, *macaddr;
-	char *set_mac_prms[5];
-	int single_dual = 0, res, fems_parsed;
-
-	argc -= 2;
-	argv += 2;
-
-	if (argc < 4 || argc > 5) {
-		return 1;
-	}
-
-	devname = *argv++;
-	argc--;
-
-	modpath = *argv++;
-	argc--;
-
-	inifile1 = *argv++;
-	argc--;
-
-	cmn.nvs_name = get_opt_nvsoutfile(argc--, argv++);
-
-	if (argc) {
-		macaddr = *argv++;
-		argc--;
-	} else {
-		macaddr = NULL;
-	}
-
-	if (file_exist(cmn.nvs_name) >= 0) {
-		fprintf(stderr, "nvs file %s. File already exists. Won't overwrite.\n", cmn.nvs_name);
-		return 0;
-	}
-
-	/* Create ref nvs */
-	if (read_ini(inifile1, &cmn)) {
-		fprintf(stderr, "Failed to read ini file %s\n", inifile1);
-		goto out_removenvs;
-	}
-
-	fems_parsed = cmn.fem0_bands + cmn.fem1_bands;
-
-	/* Get nr bands from parsed ini */
-	single_dual = ini_get_dual_mode(&cmn);
-
-	if (single_dual == 0) {
-		if (fems_parsed < 1 || fems_parsed > 2) {
-			fprintf(stderr, "Incorrect number of FEM sections %d for single mode\n",
-			        fems_parsed);
-			return 1;
-		}
-	}
-	else if (single_dual == 1) {
-		if (fems_parsed < 2 && fems_parsed > 4) {
-			fprintf(stderr, "Incorrect number of FEM sections %d for dual mode\n",
-			        fems_parsed);
-			return 1;
-		}
-	}
-	else {
-		fprintf(stderr, "Invalid value for TXBiPFEMAutoDetect %d",
-		        single_dual);
-		return 1;
-	}
-
-	/* I suppose you can have one FEM with 2.4 only and one in dual band
-	   but it's more likely a mistake */
-	if ((single_dual + 1) * (cmn.auto_fem + 1) != fems_parsed) {
-		printf("WARNING: %d FEMS for %d bands with autofem %s looks "
-			"like a strange configuration\n",
-			fems_parsed, single_dual + 1,
-			cmn.auto_fem ? "on" : "off");
-	}
-
-	cfg_nvs_ops(&cmn);
-
-	if (create_nvs_file(&cmn)) {
-		fprintf(stderr, "Failed to create reference NVS file\n");
-		return 1;
-	}
-
-	/* Load module */
-	res = insmod(modpath);
-	if (res) {
-		goto out_removenvs;
-	}
-
-	res = plt_do_power_on(state, devname);
-	if (res < 0)
-		goto out_rmmod;
-
-	res = plt_do_calibrate(state, cb, msg, single_dual,
-	                      cmn.nvs_name, devname, cmn.arch);
-	if (res) {
-		goto out_power_off;
-	}
-
-	set_mac_prms[0] = devname;
-	set_mac_prms[1] = "plt";
-	set_mac_prms[2] = "set_mac";
-	set_mac_prms[3] = cmn.nvs_name;
-	set_mac_prms[4] = macaddr;
-
-	res = handle_cmd(state, II_NETDEV,
-			 ARRAY_SIZE(set_mac_prms) - (!macaddr),
-			 set_mac_prms);
-	if (res) {
-		goto out_power_off;
-	}
-
-	/* we can ignore the return value, because we rmmod anyway */
-	plt_do_power_off(state, devname);
-	rmmod(modpath);
-
-	printf("Calibration done. ");
-	if (cmn.fem0_bands) {
-		printf("FEM0 has %d bands. ", cmn.fem0_bands);
-	}
-	if (cmn.fem1_bands) {
-		printf("FEM1 has %d bands. ", cmn.fem1_bands);
-	}
-
-	printf("AutoFEM is %s. ", cmn.auto_fem ? "on" : "off");
-
-	printf("Resulting nvs is %s\n",
-	       cmn.nvs_name);
-	return 0;
-
-out_power_off:
-	/* we can ignore the return value, because we rmmod anyway */
-	plt_do_power_off(state, devname);
-out_rmmod:
-	rmmod(modpath);
-
-out_removenvs:
-	fprintf(stderr, "Calibration not complete. Removing half-baked nvs\n");
-	unlink(cmn.nvs_name);
-	return 0;
-
-}
-COMMAND(plt, autocalibrate, "<dev> <module path> <ini file1> <nvs file> "
-	"[<MAC address>|from_fuse|default]", 0, 0, CIB_NONE, plt_autocalibrate,
-	"Do automatic calibration.\n"
-	"The MAC address value can be:\n"
-	"from_fuse\ttry to read from the fuse ROM, if not available the command fails\n"
-	"default\t\twrite 00:00:00:00:00:00 to have the driver read from the fuse ROM,\n"
-	"\t\t\tfails if not available\n"
-	"00:00:00:00:00:00\tforce use of a zeroed MAC address (use with caution!)\n");
-
-static int plt_get_mac_cb(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nlattr *td[WL1271_TM_ATTR_MAX + 1];
-	char *addr;
-	int lower;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	nla_parse(td, WL1271_TM_ATTR_MAX, nla_data(tb[NL80211_ATTR_TESTDATA]),
-		  nla_len(tb[NL80211_ATTR_TESTDATA]), NULL);
-
-	addr = (char *) nla_data(td[WL1271_TM_ATTR_DATA]);
-
-	printf("BD_ADDR from fuse:\t0x%0x:0x%0x:0x%0x:0x%0x:0x%0x:0x%0x\n",
-	       addr[0], addr[1], addr[2],
-	       addr[3], addr[4], addr[5]);
-
-	lower = (addr[3] << 16) + (addr[4] << 8) + addr[5];
-
-	lower++;
-	printf("First WLAN MAC:\t\t0x%0x:0x%0x:0x%0x:0x%0x:0x%0x:0x%0x\n",
-	       addr[0], addr[1], addr[2],
-	       (lower & 0xff0000) >> 16,
-	       (lower & 0xff00) >> 8,
-	       (lower & 0xff));
-
-	lower++;
-	printf("Second WLAN MAC:\t0x%0x:0x%0x:0x%0x:0x%0x:0x%0x:0x%0x\n",
-	       addr[0], addr[1], addr[2],
-	       (lower & 0xff0000) >> 16,
-	       (lower & 0xff00) >> 8,
-	       (lower & 0xff));
-
-	return NL_SKIP;
-}
-
-static int plt_get_mac_from_fuse(struct nl_msg *msg, struct nl_cb *cb,
-				 nl_recvmsg_msg_cb_t callback, void *arg)
-{
-	struct nlattr *key;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "%s> fail to nla_nest_start()\n", __func__);
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_GET_MAC);
-
-	nla_nest_end(msg, key);
-
-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, callback, arg);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-static int plt_get_mac(struct nl80211_state *state, struct nl_cb *cb,
-		       struct nl_msg *msg, int argc, char **argv)
-{
-	if (argc != 0)
-		return 1;
-
-	return plt_get_mac_from_fuse(msg, cb, plt_get_mac_cb, NULL);
-}
-COMMAND(plt, get_mac, "",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_get_mac,
-	"Read MAC address from the Fuse ROM.\n");
-
-static int plt_set_mac_from_fuse_cb(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nlattr *td[WL1271_TM_ATTR_MAX + 1];
-	char mac[sizeof(ZERO_MAC)];
-	char *addr;
-	char *nvs_file = (char *) arg;
-	int lower;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	nla_parse(td, WL1271_TM_ATTR_MAX, nla_data(tb[NL80211_ATTR_TESTDATA]),
-		  nla_len(tb[NL80211_ATTR_TESTDATA]), NULL);
-
-	addr = (char *) nla_data(td[WL1271_TM_ATTR_DATA]);
-
-	/*
-	 * The first address is the BD_ADDR, the next is the first
-	 * MAC.  Increment only the lower part, so we don't overflow
-	 * to the OUI */
-	lower = (addr[3] << 16) + (addr[4] << 8) + addr[5] + 1;
-
-	snprintf(mac, sizeof(mac), "%02x:%02x:%02x:%02x:%02x:%02x",
-		 addr[0], addr[1], addr[2], (lower & 0xff0000) >> 16,
-		 (lower & 0xff00) >> 8, (lower & 0xff));
-
-	/* ignore the return value, since a message was already printed out */
-	nvs_set_mac(nvs_file, mac);
-
-	return NL_SKIP;
-}
-
-static int plt_set_mac_default_cb(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	char *nvs_file = (char *) arg;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		  genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	/*
-	 * No need to parse, we just need to know if the command
-	 * worked (ie. the hardware supports MAC from fuse) so the
-	 * driver can fetch it by itself.
-	 */
-
-	/* ignore the return value, since a message was already printed out */
-	nvs_set_mac(nvs_file, ZERO_MAC);
-
-	return NL_SKIP;
-}
-
-static int plt_set_mac_from_fuse(struct nl80211_state *state, struct nl_cb *cb,
-				 struct nl_msg *msg, int argc, char **argv)
-{
-	return plt_get_mac_from_fuse(msg, cb, plt_set_mac_from_fuse_cb, argv[0]);
-}
-HIDDEN(plt, set_mac_from_fuse, "<nvs file>",
-       NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_set_mac_from_fuse);
-
-static int plt_set_mac_default(struct nl80211_state *state, struct nl_cb *cb,
-			       struct nl_msg *msg, int argc, char **argv)
-{
-	return plt_get_mac_from_fuse(msg, cb, plt_set_mac_default_cb, argv[0]);
-}
-HIDDEN(plt, set_mac_default, "<nvs file>",
-       NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_set_mac_default);
-
-static int plt_set_mac(struct nl80211_state *state, struct nl_cb *cb,
-		       struct nl_msg *msg, int argc, char **argv)
-{
-	char *nvs_file;
-
-	if (argc < 4 || argc > 5)
-		return 1;
-
-	nvs_file = argv[3];
-
-	if (argc == 4 || !strcmp(argv[4], "default")) {
-		char *prms[] = { argv[0], argv[1], "set_mac_default",
-				 nvs_file };
-
-		return handle_cmd(state, II_NETDEV, ARRAY_SIZE(prms), prms);
-	}
-
-	if (!strcmp(argv[4], "from_fuse")) {
-		char *prms[] = { argv[0], argv[1], "set_mac_from_fuse",
-				 nvs_file };
-
-		return handle_cmd(state, II_NETDEV, ARRAY_SIZE(prms), prms);
-	}
-
-	if (nvs_set_mac(nvs_file, argv[4]) != 0)
-		return 1;
-
-	return 0;
-}
-COMMAND(plt, set_mac, "<nvs file> [<MAC address>|from_fuse|default]",
-	0, 0, CIB_NETDEV, plt_set_mac,
-	"Set a MAC address to the NVS file.\n\n"
-	"<MAC address>\tspecific address to use (XX:XX:XX:XX:XX:XX)\n"
-	"from_fuse\ttry to read from the fuse ROM, if not available the command fails\n"
-	"default\t\twrite 00:00:00:00:00:00 to have the driver read from the fuse ROM,\n"
-	"\t\t\tfails if not available\n"
-	"00:00:00:00:00:00\tforce use of a zeroed MAC address (use with caution!)\n");
diff --git a/mac80211/ti-utils/plt.h b/mac80211/ti-utils/plt.h
deleted file mode 100644
index d6ca9eb..0000000
--- a/mac80211/ti-utils/plt.h
+++ /dev/null
@@ -1,397 +0,0 @@
-#ifndef __PLT_H
-#define __PLT_H
-
-#ifdef ANDROID
-#define CURRENT_NVS_NAME	"/system/etc/firmware/ti-connectivity/wl12xx-nvs.bin"
-#define INSMOD_PATH		"/system/bin/insmod"
-#define RMMOD_PATH		"/system/bin/rmmod"
-#else
-#define CURRENT_NVS_NAME	"/lib/firmware/ti-connectivity/wl12xx-nvs.bin"
-#define INSMOD_PATH		"/sbin/insmod"
-#define RMMOD_PATH		"/sbin/rmmod"
-#endif
-#define NEW_NVS_NAME		"./new-nvs.bin"
-#define NVS_FILE_SIZE_127X	0x390
-#define NVS_FILE_SIZE_128X	0x459
-
-/* NVS definition start here */
-
-#define NVS_TX_TYPE_INDEX               0
-
-#define START_TYPE_INDEX_IN_TLV		0
-#define TLV_TYPE_LENGTH                 1
-#define START_LENGTH_INDEX              \
-(START_TYPE_INDEX_IN_TLV + TLV_TYPE_LENGTH) /* 1 */
-#define TLV_LENGTH_LENGTH               2
-#define START_PARAM_INDEX               \
-(START_LENGTH_INDEX + TLV_LENGTH_LENGTH) /* 3 */
-
-#define NVS_MAC_FIRST_LENGTH_INDEX      0
-#define NVS_MAC_FIRST_LENGHT_VALUE      1
-
-#define NVS_MAC_L_ADDRESS_INDEX         \
-((NVS_MAC_FIRST_LENGTH_INDEX) + 1) /* 1*/
-#define NVS_MAC_L_ADDRESS_LENGTH        2
-
-#define NVS_MAC_L_VALUE_INDEX \
-((NVS_MAC_L_ADDRESS_INDEX) + (NVS_MAC_L_ADDRESS_LENGTH)) /* 3 */
-
-#define NVS_MAC_L_VALUE_LENGTH          4
-
-#define NVS_MAC_SECONDE_LENGTH_INDEX    \
-((NVS_MAC_L_VALUE_INDEX) + 4) /* 7 */
-#define NVS_MAC_SECONDE_LENGHT_VALUE    1
-
-#define NVS_MAC_H_ADDRESS_INDEX         \
-((NVS_MAC_SECONDE_LENGTH_INDEX) + 1) /* 8*/
-#define NVS_MAC_H_ADDRESS_LENGTH        2
-
-#define NVS_MAC_H_VALUE_INDEX           \
-((NVS_MAC_H_ADDRESS_INDEX) + (NVS_MAC_H_ADDRESS_LENGTH)) /* 10 */
-#define NVS_MAC_H_VALUE_LENGTH          4
-
-#define NVS_END_BURST_TRANSACTION_INDEX         \
-((NVS_MAC_H_VALUE_INDEX) + (NVS_MAC_H_VALUE_LENGTH))    /* 14 */
-#define NVS_END_BURST_TRANSACTION_VALUE         0
-#define NVS_END_BURST_TRANSACTION_LENGTH        7
-
-#define NVS_ALING_TLV_START_ADDRESS_INDEX       \
-((NVS_END_BURST_TRANSACTION_INDEX) + \
-(NVS_END_BURST_TRANSACTION_LENGTH)) /* 21 */
-#define NVS_ALING_TLV_START_ADDRESS_VALUE       0
-#define NVS_ALING_TLV_START_ADDRESS_LENGTH      3
-
-
-/* NVS pre TLV length */
-#define NVS_PRE_PARAMETERS_LENGTH               \
-((NVS_ALING_TLV_START_ADDRESS_INDEX) + \
-(NVS_ALING_TLV_START_ADDRESS_LENGTH)) /* 24 */
-
-/* NVS P2G table */
-#define NVS_TX_P2G_TABLE_LENGTH                 \
-((NUMBER_OF_SUB_BANDS_E) * 1 /* byte */) /* 8 */
-
-/* NVS PPA table */
-#define NVS_TX_PPA_STEPS_TABLE_LENGTH   \
-((NUMBER_OF_SUB_BANDS_E) * ((TXPWR_CFG0__VGA_STEP__NUMBER_OF_STEPS_E) \
-- 1) * 1 /* byte */)  /* 32 */
-
-/* NVS version 1 TX PD curve table length */
-#define NVS_TX_PD_TABLE_LENGTH_NVS_V1   (1 /* byte to set size of table */ + \
-((NUMBER_OF_SUB_BANDS_E) * (2 /* 1 byte offset, 1 byte low range */ + \
-2 /* first index in table */ + (((SIZE_OF_POWER_DETECTOR_TABLE) - 1) * \
-1 /* 1 byte */)))) /* 233 */
-
-/* NVS version 2 TX PD curve table length */
-#define NVS_TX_PD_TABLE_LENGTH_NVS_V2   \
-((NUMBER_OF_SUB_BANDS_E) * (12 /* 12index of one byte -2 dBm - 9dBm */ +\
-28 /* 14 indexes of 2 byte -3dBm, 10dBm - 22 dBm */)) /* 320 */
-
-/* NVS version 1 TX parameters Length */
-#define NVS_TX_PARAM_LENGTH_NVS_V1      \
-((NVS_TX_P2G_TABLE_LENGTH) + (NVS_TX_PPA_STEPS_TABLE_LENGTH) +\
-(NVS_TX_PD_TABLE_LENGTH_NVS_V1)) /* 273 */
-
-/* NVS version 2 TX parameters Length */
-#define NVS_TX_PARAM_LENGTH_NVS_V2       \
-((NVS_TX_P2G_TABLE_LENGTH) + (NVS_TX_PPA_STEPS_TABLE_LENGTH) +\
-(NVS_TX_PD_TABLE_LENGTH_NVS_V2) +\
-(NUMBER_OF_RADIO_CHANNEL_INDEXS_E /* for Per Channel power Gain Offset tabl */))
-
-/* NVS TX version */
-/* #define NVS_TX_PARAM_LENGTH     NVS_TX_PARAM_LENGTH_NVS_V2 */
-#define NVS_TX_PARAM_LENGTH     0x199
-
-/* NVS RX version */
-#define NVS_RX_PARAM_LENGTH	NUMBER_OF_RX_BIP_EFUSE_PARAMETERS_E /* 19 */
-
-/* NVS version parameter length */
-#define NVS_VERSION_PARAMETER_LENGTH    3
-
-/* NVS max length */
-/* original ((NVS_TOTAL_LENGTH) + 4 - ((NVS_TOTAL_LENGTH) % 4)) */
-#define NVS_TOTAL_LENGTH	500
-
-/* TLV max length */
-#define  MAX_TLV_LENGTH                                 NVS_TOTAL_LENGTH
-
-#define  MAX_NVS_VERSION_LENGTH                 12
-
-enum wl1271_tm_commands {
-	WL1271_TM_CMD_UNSPEC,
-	WL1271_TM_CMD_TEST,
-	WL1271_TM_CMD_INTERROGATE,
-	WL1271_TM_CMD_CONFIGURE,
-	WL1271_TM_CMD_NVS_PUSH,
-	WL1271_TM_CMD_SET_PLT_MODE,
-	WL1271_TM_CMD_RECOVER,
-	WL1271_TM_CMD_GET_MAC,
-
-	__WL1271_TM_CMD_AFTER_LAST
-};
-
-enum wl1271_tm_attrs {
-	WL1271_TM_ATTR_UNSPEC,
-	WL1271_TM_ATTR_CMD_ID,
-	WL1271_TM_ATTR_ANSWER,
-	WL1271_TM_ATTR_DATA,
-	WL1271_TM_ATTR_IE_ID,
-	WL1271_TM_ATTR_PLT_MODE,
-	__WL1271_TM_ATTR_AFTER_LAST
-};
-
-#define WL1271_TM_ATTR_MAX (__WL1271_TM_ATTR_AFTER_LAST - 1)
-
-enum wl1271_test_cmds {
-	TEST_CMD_PD_BUFFER_CAL = 0x1, /* TX PLT */
-	TEST_CMD_P2G_CAL,             /* TX BiP */
-	TEST_CMD_RX_PLT_ENTER,
-	TEST_CMD_RX_PLT_CAL,          /* RSSI Cal */
-	TEST_CMD_RX_PLT_EXIT,
-	TEST_CMD_RX_PLT_GET,
-	TEST_CMD_FCC,                 /* Continuous TX */
-	TEST_CMD_TELEC,  /* Carrier wave in a specific channel and band */
-	TEST_CMD_STOP_TX,             /* Stop FCC or TELEC */
-	TEST_CMD_PLT_TEMPLATE,        /* define Template for TX */
-	TEST_CMD_PLT_GAIN_ADJUST,
-	TEST_CMD_PLT_GAIN_GET,
-	TEST_CMD_CHANNEL_TUNE,
-	TEST_CMD_FREE_RUN_RSSI,        /* Free running RSSI measurement */
-	TEST_CMD_DEBUG,     /* test command for debug using the struct: */
-	TEST_CMD_CLPC_COMMANDS,
-	RESERVED_4,
-	TEST_CMD_RX_STAT_STOP,
-	TEST_CMD_RX_STAT_START,
-	TEST_CMD_RX_STAT_RESET,
-	TEST_CMD_RX_STAT_GET,
-	TEST_CMD_LOOPBACK_START,       /* for FW Test Debug */
-	TEST_CMD_LOOPBACK_STOP,        /* for FW Test Debug */
-	TEST_CMD_GET_FW_VERSIONS,
-	TEST_CMD_INI_FILE_RADIO_PARAM,
-	TEST_CMD_RUN_CALIBRATION_TYPE,
-	TEST_CMD_TX_GAIN_ADJUST,
-	TEST_CMD_UPDATE_PD_BUFFER_ERRORS,
-	TEST_CMD_UPDATE_PD_REFERENCE_POINT,
-	TEST_CMD_INI_FILE_GENERAL_PARAM,
-	TEST_CMD_SET_EFUSE,
-	TEST_CMD_GET_EFUSE,
-	TEST_CMD_TEST_TONE,
-	TEST_CMD_POWER_MODE,
-	TEST_CMD_SMART_REFLEX,
-	TEST_CMD_CHANNEL_RESPONSE,
-	TEST_CMD_DCO_ITRIM_FEATURE,
-	TEST_CMD_INI_FILE_RF_EXTENDED_PARAM, /* !!! Not exists in 128x */
-	TEST_CMD_SET_NVS_VERSION, /* For wl128x, the value is minus 1 */
-	MAX_TEST_CMD_ID = 0xFF
-};
-
-struct wl1271_cmd_header {
-	__u16 id;
-	__u16 status;
-	/* payload */
-	unsigned char data[0];
-} __attribute__((packed));
-
-struct wl1271_cmd_test_header {
-	unsigned char id;
-	unsigned char padding[3];
-} __attribute__((packed));
-
-struct wl1271_cmd_cal_channel_tune {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	unsigned char band;
-	unsigned char channel;
-
-	__le16 radio_status;
-} __attribute__((packed));
-
-struct wl1271_cmd_cal_update_ref_point {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	__le32 ref_power;
-	__le32 ref_detector;
-	unsigned char  sub_band;
-	unsigned char  padding[3];
-} __attribute__((packed));
-
-struct wl1271_cmd_cal_tx_tone {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	__le16 radio_status;
-	unsigned char padding[2];
-	__le32 power;
-	unsigned char tone_type;
-	unsigned char unused[11];
-} __attribute__((packed));
-
-#define NVS_VERSION_2		2
-#define NVS_VERSION_2_1		21
-
-struct wl1271_cmd_set_nvs_ver {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	__le16 radio_status;
-
-	unsigned char  nvs_ver;
-	unsigned char  padding;
-} __attribute__((packed));
-
-struct wl1271_cmd_cal_p2g {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	__le32 ver;
-	__le16 len;
-	unsigned char  buf[MAX_TLV_LENGTH];
-	unsigned char  type;
-	unsigned char  padding;
-
-	__le16 radio_status;
-
-	unsigned char  sub_band_mask;
-	unsigned char  padding2;
-} __attribute__((packed));
-
-#define MAC_ADDR_LEN  6
-
-struct wl1271_cmd_pkt_params {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	__le16 radio_status;
-	unsigned char padding[2];
-	__le32 delay;
-	__le32 rate;
-	__le16 size;
-	__le16 amount;
-	__le32 power;
-	__le16 seed;
-	unsigned char pkt_mode;
-	unsigned char dcf_enable;
-	unsigned char g_interval;
-	unsigned char preamble;
-	unsigned char type;
-	unsigned char scramble;
-	unsigned char clpc_enable;
-	unsigned char seq_nbr_mode;
-	unsigned char src_mac[MAC_ADDR_LEN];
-	unsigned char dst_mac[MAC_ADDR_LEN];
-	unsigned char padding1[2];
-} __attribute__((packed));
-
-struct wl1271_rx_path_statcs {
-	__le32 nbr_rx_valid_pkts;
-	__le32 nbr_rx_fcs_err_pkts;
-	__le32 nbr_rx_plcp_err_pkts;
-	__le32 seq_nbr_miss_cnt; /* For PER calculation */
-	__le16 ave_snr; /* average SNR */
-	__le16 ave_rssi; /* average RSSI */
-	__le16 ave_evm;
-	unsigned char padding[2];
-} __attribute__((packed));
-
-struct wl1271_rx_pkt_statcs {
-	__le32 length;
-	__le32 evm;
-	__le32 rssi;
-	__le16 freq_delta;
-	__le16 flags;
-	char type;
-	unsigned char rate;
-	unsigned char noise;
-	unsigned char agc_gain;
-	unsigned char padding[2];
-} __attribute__((packed));
-
-#define RX_STAT_PACKETS_PER_MESSAGE		(20)
-
-struct wl1271_radio_rx_statcs {
-	struct wl1271_cmd_header header;
-
-	struct wl1271_cmd_test_header test;
-
-	struct wl1271_rx_path_statcs rx_path_statcs;
-	__le32 base_pkt_id;
-	__le32 nbr_pkts; /* input/output: number of following packets */
-	__le32 nbr_miss_pkts;
-	__le16 radio_status;
-	unsigned char padding[2];
-} __attribute__((packed));
-
-enum wl1271_nvs_type {
-	eNVS_VERSION = 0xaa,
-	eNVS_RADIO_TX_PARAMETERS = 1,
-	eNVS_RADIO_RX_PARAMETERS = 2,
-	eNVS_RADIO_INI = 16,
-	eNVS_NON_FILE = 0xFE,
-	eTLV_LAST = 0xFF /* last TLV type */
-};
-
-#define DEFAULT_EFUSE_VALUE			(0)
-
-enum wl1271_nvs_type_info {
-	eFIRST_RADIO_TYPE_PARAMETERS_INFO,
-	eNVS_RADIO_TX_TYPE_PARAMETERS_INFO = eFIRST_RADIO_TYPE_PARAMETERS_INFO,
-	eNVS_RADIO_RX_TYPE_PARAMETERS_INFO,
-	eLAST_RADIO_TYPE_PARAMETERS_INFO = eNVS_RADIO_RX_TYPE_PARAMETERS_INFO,
-	UNUSED_RADIO_TYPE_PARAMETERS_INFO,
-	eNUMBER_RADIO_TYPE_PARAMETERS_INFO = UNUSED_RADIO_TYPE_PARAMETERS_INFO,
-	LAST_RADIO_TYPE_PARAMETERS_INFO =
-		(eNUMBER_RADIO_TYPE_PARAMETERS_INFO - 1)
-};
-
-enum EFUSE_PARAMETER_TYPE_ENMT {
-	EFUSE_FIRST_PARAMETER_E,
-	/* RX PARAMETERS */
-	EFUSE_FIRST_RX_PARAMETER_E = EFUSE_FIRST_PARAMETER_E,
-	RX_BIP_MAX_GAIN_ERROR_BAND_B_E = EFUSE_FIRST_RX_PARAMETER_E,
-
-	RX_BIP_MAX_GAIN_ERROR_J_LOW_MID_E,
-	RX_BIP_MAX_GAIN_ERROR_J_HIGH_E,
-
-	RX_BIP_MAX_GAIN_ERROR_5G_1ST_E,
-	RX_BIP_MAX_GAIN_ERROR_5G_2ND_E,
-	RX_BIP_MAX_GAIN_ERROR_5G_3RD_E,
-	RX_BIP_MAX_GAIN_ERROR_5G_4TH_E,
-
-	RX_BIP_LNA_STEP_CORR_BAND_B_4TO3_E,
-	RX_BIP_LNA_STEP_CORR_BAND_B_3TO2_E,
-	RX_BIP_LNA_STEP_CORR_BAND_B_2TO1_E,
-	RX_BIP_LNA_STEP_CORR_BAND_B_1TO0_E,
-
-	RX_BIP_LNA_STEP_CORR_BAND_A_4TO3_E,
-	RX_BIP_LNA_STEP_CORR_BAND_A_3TO2_E,
-	RX_BIP_LNA_STEP_CORR_BAND_A_2TO1_E,
-	RX_BIP_LNA_STEP_CORR_BAND_A_1TO0_E,
-
-	RX_BIP_TA_STEP_CORR_BAND_B_2TO1_E,
-	RX_BIP_TA_STEP_CORR_BAND_B_1TO0_E,
-	RX_BIP_TA_STEP_CORR_BAND_A_2TO1_E,
-	RX_BIP_TA_STEP_CORR_BAND_A_1TO0_E,
-	NUMBER_OF_RX_BIP_EFUSE_PARAMETERS_E,
-
-	/* TX PARAMETERS */
-	TX_BIP_PD_BUFFER_GAIN_ERROR_E = NUMBER_OF_RX_BIP_EFUSE_PARAMETERS_E,
-	TX_BIP_PD_BUFFER_VBIAS_ERROR_E,
-	EFUSE_NUMBER_OF_PARAMETERS_E,
-	EFUSE_LAST_PARAMETER_E = (EFUSE_NUMBER_OF_PARAMETERS_E - 1)
-} EFUSE_PARAMETER_TYPE_ENM;
-
-int get_mac_addr(int ifc_num, unsigned char *mac_addr);
-
-int file_exist(const char *filename);
-
-int do_get_drv_info(char *dev_name, int *arch);
-
-#endif /* __PLT_H */
diff --git a/mac80211/ti-utils/wl18xx_plt.c b/mac80211/ti-utils/wl18xx_plt.c
deleted file mode 100644
index ac46bf4..0000000
--- a/mac80211/ti-utils/wl18xx_plt.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * This file is part of calibrator
- *
- * Copyright (C) 2011 Texas Instruments
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include "calibrator.h"
-#include "plt.h"
-#include "wl18xx_plt.h"
-
-SECTION(wl18xx_plt);
-
-static int plt_wl18xx_tune_channel(struct nl80211_state *state, struct nl_cb *cb,
-				   struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_channel_tune prms;
-
-	if (argc != 3)
-		return 1;
-
-	prms.test.id	= WL18XX_TEST_CMD_CHANNEL_TUNE;
-	prms.channel	= (__u8)atoi(argv[0]);
-	prms.band	= (__u8)atoi(argv[1]);
-	prms.bandwidth	= (__u8)atoi(argv[2]);
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, tune_channel, "<channel> <band> <bandwidth>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_tune_channel,
-	"Set channel, band and bandwidth for PLT.\n");
-
-static int plt_wl18xx_start_rx(struct nl80211_state *state, struct nl_cb *cb,
-			       struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_start_rx prms;
-
-	if (argc != 0)
-		return 1;
-
-	prms.test.id	= WL18XX_TEST_CMD_START_RX_SIMULATION;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, start_rx, "",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_start_rx,
-	"Start gathering RX statistics for PLT.\n");
-
-static int plt_wl18xx_stop_rx(struct nl80211_state *state, struct nl_cb *cb,
-			      struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_stop_rx prms;
-
-	if (argc != 0)
-		return 1;
-
-	prms.test.id	= WL18XX_TEST_CMD_STOP_RX_SIMULATION;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, stop_rx, "",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_stop_rx,
-	"Stop gathering RX statistics for PLT.\n");
-
-static int plt_wl18xx_display_rx_stats(struct nl_msg *msg, void *arg)
-{
-	struct nlattr *tb[NL80211_ATTR_MAX + 1];
-	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
-	struct nlattr *td[WL1271_TM_ATTR_MAX + 1];
-	struct wl18xx_cmd_rx_stats *prms;
-
-	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		genlmsg_attrlen(gnlh, 0), NULL);
-
-	if (!tb[NL80211_ATTR_TESTDATA]) {
-		fprintf(stderr, "no data!\n");
-		return NL_SKIP;
-	}
-
-	nla_parse(td, WL1271_TM_ATTR_MAX, nla_data(tb[NL80211_ATTR_TESTDATA]),
-		  nla_len(tb[NL80211_ATTR_TESTDATA]), NULL);
-
-	prms = (struct wl18xx_cmd_rx_stats *) nla_data(td[WL1271_TM_ATTR_DATA]);
-
-	printf("\nRX statistics (status %d)\n", prms->radio_status);
-	printf("Total packets:\t%d\n", prms->total);
-	printf("FCS errors:\t%d\n", prms->errors);
-	printf("MAC mismatch:\t%d\n", prms->addr_mm);
-	printf("Good packets:\t%d\n", prms->good);
-
-	return NL_SKIP;
-}
-
-static int plt_wl18xx_get_rx_stats(struct nl80211_state *state, struct nl_cb *cb,
-				   struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_rx_stats prms;
-
-	if (argc != 0)
-		return 1;
-
-	prms.test.id = WL18XX_TEST_CMD_GET_RX_STATISTICS;
-
-	printf("test.id = 0x%0x\n", prms.test.id);
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-	NLA_PUT_U8(msg, WL1271_TM_ATTR_ANSWER, 1);
-
-	nla_nest_end(msg, key);
-
-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM,
-		  plt_wl18xx_display_rx_stats, NULL);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, get_rx_stats, "",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_get_rx_stats,
-	"Retrieve RX statistics for PLT.\n");
-
-static int plt_wl18xx_start_tx(struct nl80211_state *state, struct nl_cb *cb,
-			       struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_start_tx prms;
-
-	if (argc != 11)
-		return 1;
-
-	prms.test.id	= WL18XX_TEST_CMD_START_TX_SIMULATION;
-
-	prms.delay = atoi(argv[0]);
-	prms.rate = atoi(argv[1]);
-	prms.size = atoi(argv[2]);
-	prms.mode = atoi(argv[3]);
-	prms.data_type = atoi(argv[4]);
-	prms.gi = atoi(argv[5]);
-	prms.options1 = atoi(argv[6]);
-	prms.options2 = atoi(argv[7]);
-	str2mac(prms.src_addr, argv[8]);
-	str2mac(prms.dst_addr, argv[9]);
-	prms.bandwidth = atoi(argv[10]);
-
-	if (prms.rate < 0 || prms.rate > 29)
-		return 1;
-	if (prms.gi != 0 && prms.gi != 1)
-		return 1;
-	if (prms.bandwidth != 0 && prms.bandwidth != 1)
-		return 1;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, start_tx, "<delay> <rate> <size> <mode> <data_type> <gi> "
-	"<options1> <options2> <source MAC> <dest MAC> <20|40>",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_start_tx,
-	"Start TX transmissions for PLT.\n\n"
-	"<delay>\t\tdelay between packets in us\n"
-	"<rate>\t\ttransmission rate:\n"
-	"\t\t\t0  =  1.0 Mbps\t\t\t1  =  2.0 Mbps\n"
-	"\t\t\t2  =  5.0 Mbps\t\t\t3  = 11.0 Mbps\n"
-	"\t\t\t4  =  6.0 Mbps\t\t\t5  =  9.0 Mbps\n"
-	"\t\t\t6  = 12.0 Mbps\t\t\t7  = 18.0 Mbps\n"
-	"\t\t\t8  = 24.0 Mbps\t\t\t9  = 36.0 Mbps\n"
-	"\t\t\t10 = 48.0 Mbps\t\t\t11 = 54.0 Mbps\n"
-	"\t\t\t12 =  6.5 Mbps (MCS0)\t\t13 = 13.0 Mbps (MCS1)\n"
-	"\t\t\t14 = 19.5 Mbps (MCS2)\t\t15 = 26.0 Mbps (MCS3)\n"
-	"\t\t\t16 = 39.0 Mbps (MCS4)\t\t17 = 52.0 Mbps (MCS5)\n"
-	"\t\t\t18 = 58.5 Mbps (MCS6)\t\t19 = 65.0 Mbps (MCS7)\n"
-	"\t\t\t20 = 65.0 Mbps + 10% (MCS7 SGI)\t21 = MCS8/MCS4  at 40MHz\n"
-	"\t\t\t22 = MCS9/MCS5  at 40MHz\t23 = MCS10/MCS6 at 40MHz\n"
-	"\t\t\t24 = MCS11/MCS7 at 40MHz\t25 = MCS12/MCS7 at 40MHz SGI\n"
-	"\t\t\t26 = MCS13\t\t\t27 = MCS14\n"
-	"\t\t\t28 = MCS15\t\t\t29 = MCS15 SGI\n"
-	"<size>\t\tpacket size (bytes)\n"
-	"<mode>\t\tnumber of packets (0 = endless)\n"
-	"<data_type>\tTBD\n"
-	"<gi>\t\tguard interval (0 = normal, 1 = short)\n"
-	"<options1>\tTBD\n"
-	"<options2>\tTBD\n"
-	"<source MAC>\tsource MAC address (XX:XX:XX:XX:XX:XX)\n"
-	"<dest MAC>\tdestination MAC address (XX:XX:XX:XX:XX:XX)\n"
-	"<channel width>\tchannel width (0 = 20 MHz, 1 = 40 MHz)");
-
-static int plt_wl18xx_stop_tx(struct nl80211_state *state, struct nl_cb *cb,
-			      struct nl_msg *msg, int argc, char **argv)
-{
-	struct nlattr *key;
-	struct wl18xx_cmd_stop_tx prms;
-
-	if (argc != 0)
-		return 1;
-
-	prms.test.id	= WL18XX_TEST_CMD_STOP_TX_SIMULATION;
-
-	key = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
-	if (!key) {
-		fprintf(stderr, "fail to nla_nest_start()\n");
-		return 1;
-	}
-
-	NLA_PUT_U32(msg, WL1271_TM_ATTR_CMD_ID, WL1271_TM_CMD_TEST);
-	NLA_PUT(msg, WL1271_TM_ATTR_DATA, sizeof(prms), &prms);
-
-	nla_nest_end(msg, key);
-
-	return 0;
-
-nla_put_failure:
-	fprintf(stderr, "%s> building message failed\n", __func__);
-	return 2;
-}
-
-COMMAND(wl18xx_plt, stop_tx, "",
-	NL80211_CMD_TESTMODE, 0, CIB_NETDEV, plt_wl18xx_stop_tx,
-	"Stop TX transmissions for PLT.\n");
diff --git a/mac80211/ti-utils/wl18xx_plt.h b/mac80211/ti-utils/wl18xx_plt.h
deleted file mode 100644
index 0bd6cb0..0000000
--- a/mac80211/ti-utils/wl18xx_plt.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * This file is part of calibrator
- *
- * Copyright (C) 2011 Texas Instruments
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL18XX_PLT_H__
-#define __WL18XX_PLT_H__
-
-enum wl18xx_test_cmds {
-	WL18XX_TEST_CMD_PD_BUFFER_CAL = 0x1,
-	WL18XX_TEST_CMD_P2G_CAL,
-	WL18XX_TEST_CMD_RX_PLT_ENTER,
-	WL18XX_TEST_CMD_RX_PLT_CAL,
-	WL18XX_TEST_CMD_RX_PLT_EXIT,
-	WL18XX_TEST_CMD_RX_PLT_GET,
-	WL18XX_TEST_CMD_FCC,
-	WL18XX_TEST_CMD_TELEC,
-	WL18XX_TEST_CMD_STOP_TX,
-	WL18XX_TEST_CMD_PLT_TEMPLATE,
-	WL18XX_TEST_CMD_PLT_GAIN_ADJUST,
-	WL18XX_TEST_CMD_PLT_GAIN_GET,
-	WL18XX_TEST_CMD_CHANNEL_TUNE_OLD,
-	WL18XX_TEST_CMD_FREE_RUN_RSSI,
-	WL18XX_TEST_CMD_DEBUG,
-	WL18XX_TEST_CMD_CLPC_COMMANDS,
-	WL18XX_TEST_CMD_RESERVED,
-	WL18XX_TEST_CMD_RX_STAT_STOP,
-	WL18XX_TEST_CMD_RX_STAT_START,
-	WL18XX_TEST_CMD_RX_STAT_RESET,
-	WL18XX_TEST_CMD_RX_STAT_GET,
-	WL18XX_TEST_CMD_LOOPBACK_START,
-	WL18XX_TEST_CMD_LOOPBACK_STOP,
-	WL18XX_TEST_CMD_GET_FW_VERSIONS,
-	WL18XX_TEST_CMD_INI_FILE_RADIO_PARAM,
-	WL18XX_TEST_CMD_RUN_CALIBRATION_TYPE,
-	WL18XX_TEST_CMD_TX_GAIN_ADJUST,
-	WL18XX_TEST_CMD_UPDATE_PD_BUFFER_ERRORS,
-	WL18XX_TEST_CMD_UPDATE_PD_REFERENCE_POINT,
-	WL18XX_TEST_CMD_INI_FILE_GENERAL_PARAM,
-	WL18XX_TEST_CMD_SET_EFUSE,
-	WL18XX_TEST_CMD_GET_EFUSE,
-	WL18XX_TEST_CMD_TEST_TONE,
-	WL18XX_TEST_CMD_POWER_MODE,
-	WL18XX_TEST_CMD_SMART_REFLEX,
-	WL18XX_TEST_CMD_CHANNEL_RESPONSE,
-	WL18XX_TEST_CMD_DCO_ITRIM_FEATURE,
-	WL18XX_TEST_CMD_START_TX_SIMULATION,
-	WL18XX_TEST_CMD_STOP_TX_SIMULATION,
-	WL18XX_TEST_CMD_START_RX_SIMULATION,
-	WL18XX_TEST_CMD_STOP_RX_SIMULATION,
-	WL18XX_TEST_CMD_GET_RX_STATISTICS,
-	WL18XX_TEST_CMD_SET_NVS_VERSION,
-	WL18XX_TEST_CMD_CHANNEL_TUNE,
-};
-
-struct wl18xx_cmd_channel_tune {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-
-	__le16	radio_status;
-	__u8	channel;
-	__u8	band;
-	__u8	bandwidth;
-	__u8	padding[3];
-} __attribute__((packed));
-
-struct wl18xx_cmd_start_rx {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-} __attribute__((packed));
-
-struct wl18xx_cmd_stop_rx {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-} __attribute__((packed));
-
-struct wl18xx_cmd_rx_stats {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-
-	__le32 radio_status;
-
-	__le32 total;
-	__le32 errors;
-	__le32 addr_mm;
-	__le32 good;
-} __attribute__((packed));
-
-struct wl18xx_cmd_start_tx {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-
-	__le32 radio_status;
-
-	__le32 delay;
-	__le32 rate;
-	__le32 size;
-	__le32 mode;
-	__le32 data_type;
-	__le32 gi;
-	__le32 options1;
-	__le32 options2;
-	__u8   src_addr[MAC_ADDR_LEN];
-	__u8   dst_addr[MAC_ADDR_LEN];
-	__le32 bandwidth;
-	__le32 padding;
-} __attribute__((packed));
-
-struct wl18xx_cmd_stop_tx {
-	struct wl1271_cmd_header header;
-	struct wl1271_cmd_test_header test;
-} __attribute__((packed));
-
-#endif /* __WL18XX_PLT_H__ */
-- 
1.7.9

